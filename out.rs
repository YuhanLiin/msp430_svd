# ! [ doc = "Peripheral access API for CC430F5123 microcontrollers (generated using svd2rust v0.7.0)" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ feature ( const_fn ) ] # ! [ no_std ]extern crate cortex_m ;
extern crate vcell ;
use core::ops::Deref;
use cortex_m::peripheral::Peripheral;
# [ doc = r" Interrupts" ]
pub mod interrupt {
    use cortex_m::ctxt::Context;
    use cortex_m::exception;
    use cortex_m::interrupt::Nr;
    # [ doc = r" Interrupt handlers" ]
    # [ allow ( non_snake_case ) ]
    # [ repr ( C ) ]
    pub struct Handlers {}
    # [ doc = r" Default interrupt handlers" ]
    pub const DEFAULT_HANDLERS: Handlers = Handlers {};
    # [ doc = r" Enumeration of all the interrupts" ]
    pub enum Interrupt { }
    unsafe impl Nr for Interrupt {
        # [ inline ( always ) ]
        fn nr(&self) -> u8 {
            match * self { }
        }
    }
}
pub use cortex_m::peripheral::Cpuid;
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::Dcb;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::Dwt;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::Fpb;
pub use cortex_m::peripheral::FPB;
pub use cortex_m::peripheral::Fpu;
pub use cortex_m::peripheral::FPU;
pub use cortex_m::peripheral::Itm;
pub use cortex_m::peripheral::ITM;
pub use cortex_m::peripheral::Mpu;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::Nvic;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::Scb;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::Syst;
pub use cortex_m::peripheral::SYST;
pub use cortex_m::peripheral::Tpiu;
pub use cortex_m::peripheral::TPIU;
# [ doc = "ADC10_A" ]
pub const ADC10_A: Peripheral<Adc10A> = unsafe { Peripheral::new(0) };
# [ doc = "ADC10_A" ]
pub mod adc10_a {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1856usize],
        # [ doc = "0x740 - ADC10 Control 0" ]
        pub adc10ctl0: Adc10ctl0,
        # [ doc = "0x742 - ADC10 Control 1" ]
        pub adc10ctl1: Adc10ctl1,
        # [ doc = "0x744 - ADC10 Control 2" ]
        pub adc10ctl2: Adc10ctl2,
        # [ doc = "0x746 - ADC10 Window Comparator High Threshold" ]
        pub adc10lo: Adc10lo,
        # [ doc = "0x748 - ADC10 Window Comparator High Threshold" ]
        pub adc10hi: Adc10hi,
        # [ doc = "0x74a - ADC10 Memory Control 0" ]
        pub adc10mctl0: Adc10mctl0,
        _reserved1: [u8; 6usize],
        # [ doc = "0x752 - ADC10 Conversion Memory 0" ]
        pub adc10mem0: Adc10mem0,
        _reserved2: [u8; 6usize],
        # [ doc = "0x75a - ADC10 Interrupt Enable" ]
        pub adc10ie: Adc10ie,
        # [ doc = "0x75c - ADC10 Interrupt Flag" ]
        pub adc10ifg: Adc10ifg,
        # [ doc = "0x75e - ADC10 Interrupt Vector Word" ]
        pub adc10iv: Adc10iv,
    }
    # [ doc = "ADC10 Control 0" ]
    pub struct Adc10ctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Control 0" ]
    pub mod adc10ctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10ctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10scR {
            bits: u8,
        }
        impl Adc10scR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10encR {
            bits: u8,
        }
        impl Adc10encR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10onR {
            bits: u8,
        }
        impl Adc10onR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10mscR {
            bits: u8,
        }
        impl Adc10mscR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `ADC10SHT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10shtR {
            # [ doc = "ADC10 Sample Hold Select 0" ]
            Adc10sht0,
            # [ doc = "ADC10 Sample Hold Select 1" ]
            Adc10sht1,
            # [ doc = "ADC10 Sample Hold Select 2" ]
            Adc10sht2,
            # [ doc = "ADC10 Sample Hold Select 3" ]
            Adc10sht3,
            # [ doc = "ADC10 Sample Hold Select 4" ]
            Adc10sht4,
            # [ doc = "ADC10 Sample Hold Select 5" ]
            Adc10sht5,
            # [ doc = "ADC10 Sample Hold Select 6" ]
            Adc10sht6,
            # [ doc = "ADC10 Sample Hold Select 7" ]
            Adc10sht7,
            # [ doc = "ADC10 Sample Hold Select 8" ]
            Adc10sht8,
            # [ doc = "ADC10 Sample Hold Select 9" ]
            Adc10sht9,
            # [ doc = "ADC10 Sample Hold Select 10" ]
            Adc10sht10,
            # [ doc = "ADC10 Sample Hold Select 11" ]
            Adc10sht11,
            # [ doc = "ADC10 Sample Hold Select 12" ]
            Adc10sht12,
            # [ doc = "ADC10 Sample Hold Select 13" ]
            Adc10sht13,
            # [ doc = "ADC10 Sample Hold Select 14" ]
            Adc10sht14,
            # [ doc = "ADC10 Sample Hold Select 15" ]
            Adc10sht15,
        }
        impl Adc10shtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10shtR::Adc10sht0 => 0,
                    Adc10shtR::Adc10sht1 => 1,
                    Adc10shtR::Adc10sht2 => 2,
                    Adc10shtR::Adc10sht3 => 3,
                    Adc10shtR::Adc10sht4 => 4,
                    Adc10shtR::Adc10sht5 => 5,
                    Adc10shtR::Adc10sht6 => 6,
                    Adc10shtR::Adc10sht7 => 7,
                    Adc10shtR::Adc10sht8 => 8,
                    Adc10shtR::Adc10sht9 => 9,
                    Adc10shtR::Adc10sht10 => 10,
                    Adc10shtR::Adc10sht11 => 11,
                    Adc10shtR::Adc10sht12 => 12,
                    Adc10shtR::Adc10sht13 => 13,
                    Adc10shtR::Adc10sht14 => 14,
                    Adc10shtR::Adc10sht15 => 15,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10shtR {
                match bits {
                    0 => Adc10shtR::Adc10sht0,
                    1 => Adc10shtR::Adc10sht1,
                    2 => Adc10shtR::Adc10sht2,
                    3 => Adc10shtR::Adc10sht3,
                    4 => Adc10shtR::Adc10sht4,
                    5 => Adc10shtR::Adc10sht5,
                    6 => Adc10shtR::Adc10sht6,
                    7 => Adc10shtR::Adc10sht7,
                    8 => Adc10shtR::Adc10sht8,
                    9 => Adc10shtR::Adc10sht9,
                    10 => Adc10shtR::Adc10sht10,
                    11 => Adc10shtR::Adc10sht11,
                    12 => Adc10shtR::Adc10sht12,
                    13 => Adc10shtR::Adc10sht13,
                    14 => Adc10shtR::Adc10sht14,
                    15 => Adc10shtR::Adc10sht15,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10sht0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_0(&self) -> bool {
                *self == Adc10shtR::Adc10sht0
            }
            # [ doc = "Checks if the value of the field is `Adc10sht1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_1(&self) -> bool {
                *self == Adc10shtR::Adc10sht1
            }
            # [ doc = "Checks if the value of the field is `Adc10sht2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_2(&self) -> bool {
                *self == Adc10shtR::Adc10sht2
            }
            # [ doc = "Checks if the value of the field is `Adc10sht3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_3(&self) -> bool {
                *self == Adc10shtR::Adc10sht3
            }
            # [ doc = "Checks if the value of the field is `Adc10sht4`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_4(&self) -> bool {
                *self == Adc10shtR::Adc10sht4
            }
            # [ doc = "Checks if the value of the field is `Adc10sht5`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_5(&self) -> bool {
                *self == Adc10shtR::Adc10sht5
            }
            # [ doc = "Checks if the value of the field is `Adc10sht6`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_6(&self) -> bool {
                *self == Adc10shtR::Adc10sht6
            }
            # [ doc = "Checks if the value of the field is `Adc10sht7`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_7(&self) -> bool {
                *self == Adc10shtR::Adc10sht7
            }
            # [ doc = "Checks if the value of the field is `Adc10sht8`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_8(&self) -> bool {
                *self == Adc10shtR::Adc10sht8
            }
            # [ doc = "Checks if the value of the field is `Adc10sht9`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_9(&self) -> bool {
                *self == Adc10shtR::Adc10sht9
            }
            # [ doc = "Checks if the value of the field is `Adc10sht10`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_10(&self) -> bool {
                *self == Adc10shtR::Adc10sht10
            }
            # [ doc = "Checks if the value of the field is `Adc10sht11`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_11(&self) -> bool {
                *self == Adc10shtR::Adc10sht11
            }
            # [ doc = "Checks if the value of the field is `Adc10sht12`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_12(&self) -> bool {
                *self == Adc10shtR::Adc10sht12
            }
            # [ doc = "Checks if the value of the field is `Adc10sht13`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_13(&self) -> bool {
                *self == Adc10shtR::Adc10sht13
            }
            # [ doc = "Checks if the value of the field is `Adc10sht14`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_14(&self) -> bool {
                *self == Adc10shtR::Adc10sht14
            }
            # [ doc = "Checks if the value of the field is `Adc10sht15`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sht_15(&self) -> bool {
                *self == Adc10shtR::Adc10sht15
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10scW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10scW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10encW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10encW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10onW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10onW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10mscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10mscW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10SHT`" ]
        pub enum Adc10shtW {
            # [ doc = "ADC10 Sample Hold Select 0" ]
            Adc10sht0,
            # [ doc = "ADC10 Sample Hold Select 1" ]
            Adc10sht1,
            # [ doc = "ADC10 Sample Hold Select 2" ]
            Adc10sht2,
            # [ doc = "ADC10 Sample Hold Select 3" ]
            Adc10sht3,
            # [ doc = "ADC10 Sample Hold Select 4" ]
            Adc10sht4,
            # [ doc = "ADC10 Sample Hold Select 5" ]
            Adc10sht5,
            # [ doc = "ADC10 Sample Hold Select 6" ]
            Adc10sht6,
            # [ doc = "ADC10 Sample Hold Select 7" ]
            Adc10sht7,
            # [ doc = "ADC10 Sample Hold Select 8" ]
            Adc10sht8,
            # [ doc = "ADC10 Sample Hold Select 9" ]
            Adc10sht9,
            # [ doc = "ADC10 Sample Hold Select 10" ]
            Adc10sht10,
            # [ doc = "ADC10 Sample Hold Select 11" ]
            Adc10sht11,
            # [ doc = "ADC10 Sample Hold Select 12" ]
            Adc10sht12,
            # [ doc = "ADC10 Sample Hold Select 13" ]
            Adc10sht13,
            # [ doc = "ADC10 Sample Hold Select 14" ]
            Adc10sht14,
            # [ doc = "ADC10 Sample Hold Select 15" ]
            Adc10sht15,
        }
        impl Adc10shtW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10shtW::Adc10sht0 => 0,
                    Adc10shtW::Adc10sht1 => 1,
                    Adc10shtW::Adc10sht2 => 2,
                    Adc10shtW::Adc10sht3 => 3,
                    Adc10shtW::Adc10sht4 => 4,
                    Adc10shtW::Adc10sht5 => 5,
                    Adc10shtW::Adc10sht6 => 6,
                    Adc10shtW::Adc10sht7 => 7,
                    Adc10shtW::Adc10sht8 => 8,
                    Adc10shtW::Adc10sht9 => 9,
                    Adc10shtW::Adc10sht10 => 10,
                    Adc10shtW::Adc10sht11 => 11,
                    Adc10shtW::Adc10sht12 => 12,
                    Adc10shtW::Adc10sht13 => 13,
                    Adc10shtW::Adc10sht14 => 14,
                    Adc10shtW::Adc10sht15 => 15,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10shtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10shtW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10shtW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Sample Hold Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10sht_0(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht0)
            }
            # [ doc = "ADC10 Sample Hold Select 1" ]
            # [ inline ( always ) ]
            pub fn adc10sht_1(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht1)
            }
            # [ doc = "ADC10 Sample Hold Select 2" ]
            # [ inline ( always ) ]
            pub fn adc10sht_2(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht2)
            }
            # [ doc = "ADC10 Sample Hold Select 3" ]
            # [ inline ( always ) ]
            pub fn adc10sht_3(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht3)
            }
            # [ doc = "ADC10 Sample Hold Select 4" ]
            # [ inline ( always ) ]
            pub fn adc10sht_4(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht4)
            }
            # [ doc = "ADC10 Sample Hold Select 5" ]
            # [ inline ( always ) ]
            pub fn adc10sht_5(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht5)
            }
            # [ doc = "ADC10 Sample Hold Select 6" ]
            # [ inline ( always ) ]
            pub fn adc10sht_6(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht6)
            }
            # [ doc = "ADC10 Sample Hold Select 7" ]
            # [ inline ( always ) ]
            pub fn adc10sht_7(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht7)
            }
            # [ doc = "ADC10 Sample Hold Select 8" ]
            # [ inline ( always ) ]
            pub fn adc10sht_8(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht8)
            }
            # [ doc = "ADC10 Sample Hold Select 9" ]
            # [ inline ( always ) ]
            pub fn adc10sht_9(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht9)
            }
            # [ doc = "ADC10 Sample Hold Select 10" ]
            # [ inline ( always ) ]
            pub fn adc10sht_10(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht10)
            }
            # [ doc = "ADC10 Sample Hold Select 11" ]
            # [ inline ( always ) ]
            pub fn adc10sht_11(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht11)
            }
            # [ doc = "ADC10 Sample Hold Select 12" ]
            # [ inline ( always ) ]
            pub fn adc10sht_12(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht12)
            }
            # [ doc = "ADC10 Sample Hold Select 13" ]
            # [ inline ( always ) ]
            pub fn adc10sht_13(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht13)
            }
            # [ doc = "ADC10 Sample Hold Select 14" ]
            # [ inline ( always ) ]
            pub fn adc10sht_14(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht14)
            }
            # [ doc = "ADC10 Sample Hold Select 15" ]
            # [ inline ( always ) ]
            pub fn adc10sht_15(self) -> &'a mut W {
                self.variant(Adc10shtW::Adc10sht15)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - ADC10 Start Conversion" ]
            # [ inline ( always ) ]
            pub fn adc10sc(&self) -> Adc10scR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10scR { bits }
            }
            # [ doc = "Bit 1 - ADC10 Enable Conversion" ]
            # [ inline ( always ) ]
            pub fn adc10enc(&self) -> Adc10encR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10encR { bits }
            }
            # [ doc = "Bit 4 - ADC10 On/enable" ]
            # [ inline ( always ) ]
            pub fn adc10on(&self) -> Adc10onR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10onR { bits }
            }
            # [ doc = "Bit 7 - ADC10 Multiple SampleConversion" ]
            # [ inline ( always ) ]
            pub fn adc10msc(&self) -> Adc10mscR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10mscR { bits }
            }
            # [ doc = "Bits 11:14 - ADC10 Sample Hold Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn adc10sht(&self) -> Adc10shtR {
                Adc10shtR::_from({
                                     const MASK: u8 = 15;
                                     const OFFSET: u8 = 11;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - ADC10 Start Conversion" ]
            # [ inline ( always ) ]
            pub fn adc10sc(&mut self) -> _Adc10scW {
                _Adc10scW { w: self }
            }
            # [ doc = "Bit 1 - ADC10 Enable Conversion" ]
            # [ inline ( always ) ]
            pub fn adc10enc(&mut self) -> _Adc10encW {
                _Adc10encW { w: self }
            }
            # [ doc = "Bit 4 - ADC10 On/enable" ]
            # [ inline ( always ) ]
            pub fn adc10on(&mut self) -> _Adc10onW {
                _Adc10onW { w: self }
            }
            # [ doc = "Bit 7 - ADC10 Multiple SampleConversion" ]
            # [ inline ( always ) ]
            pub fn adc10msc(&mut self) -> _Adc10mscW {
                _Adc10mscW { w: self }
            }
            # [ doc = "Bits 11:14 - ADC10 Sample Hold Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn adc10sht(&mut self) -> _Adc10shtW {
                _Adc10shtW { w: self }
            }
        }
    }
    # [ doc = "ADC10 Control 1" ]
    pub struct Adc10ctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Control 1" ]
    pub mod adc10ctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10ctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10busyR {
            bits: u8,
        }
        impl Adc10busyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `ADC10CONSEQ`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10conseqR {
            # [ doc = "ADC10 Conversion Sequence Select: 0" ]
            Adc10conseq0,
            # [ doc = "ADC10 Conversion Sequence Select: 1" ]
            Adc10conseq1,
            # [ doc = "ADC10 Conversion Sequence Select: 2" ]
            Adc10conseq2,
            # [ doc = "ADC10 Conversion Sequence Select: 3" ]
            Adc10conseq3,
        }
        impl Adc10conseqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10conseqR::Adc10conseq0 => 0,
                    Adc10conseqR::Adc10conseq1 => 1,
                    Adc10conseqR::Adc10conseq2 => 2,
                    Adc10conseqR::Adc10conseq3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10conseqR {
                match bits {
                    0 => Adc10conseqR::Adc10conseq0,
                    1 => Adc10conseqR::Adc10conseq1,
                    2 => Adc10conseqR::Adc10conseq2,
                    3 => Adc10conseqR::Adc10conseq3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10conseq0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10conseq_0(&self) -> bool {
                *self == Adc10conseqR::Adc10conseq0
            }
            # [ doc = "Checks if the value of the field is `Adc10conseq1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10conseq_1(&self) -> bool {
                *self == Adc10conseqR::Adc10conseq1
            }
            # [ doc = "Checks if the value of the field is `Adc10conseq2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10conseq_2(&self) -> bool {
                *self == Adc10conseqR::Adc10conseq2
            }
            # [ doc = "Checks if the value of the field is `Adc10conseq3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10conseq_3(&self) -> bool {
                *self == Adc10conseqR::Adc10conseq3
            }
        }
        # [ doc = "Possible values of the field `ADC10SSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10sselR {
            # [ doc = "ADC10 Clock Source Select: 0" ]
            Adc10ssel0,
            # [ doc = "ADC10 Clock Source Select: 1" ]
            Adc10ssel1,
            # [ doc = "ADC10 Clock Source Select: 2" ]
            Adc10ssel2,
            # [ doc = "ADC10 Clock Source Select: 3" ]
            Adc10ssel3,
        }
        impl Adc10sselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10sselR::Adc10ssel0 => 0,
                    Adc10sselR::Adc10ssel1 => 1,
                    Adc10sselR::Adc10ssel2 => 2,
                    Adc10sselR::Adc10ssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10sselR {
                match bits {
                    0 => Adc10sselR::Adc10ssel0,
                    1 => Adc10sselR::Adc10ssel1,
                    2 => Adc10sselR::Adc10ssel2,
                    3 => Adc10sselR::Adc10ssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10ssel0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10ssel_0(&self) -> bool {
                *self == Adc10sselR::Adc10ssel0
            }
            # [ doc = "Checks if the value of the field is `Adc10ssel1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10ssel_1(&self) -> bool {
                *self == Adc10sselR::Adc10ssel1
            }
            # [ doc = "Checks if the value of the field is `Adc10ssel2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10ssel_2(&self) -> bool {
                *self == Adc10sselR::Adc10ssel2
            }
            # [ doc = "Checks if the value of the field is `Adc10ssel3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10ssel_3(&self) -> bool {
                *self == Adc10sselR::Adc10ssel3
            }
        }
        # [ doc = "Possible values of the field `ADC10DIV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10divR {
            # [ doc = "ADC10 Clock Divider Select: 0" ]
            Adc10div0,
            # [ doc = "ADC10 Clock Divider Select: 1" ]
            Adc10div1,
            # [ doc = "ADC10 Clock Divider Select: 2" ]
            Adc10div2,
            # [ doc = "ADC10 Clock Divider Select: 3" ]
            Adc10div3,
            # [ doc = "ADC10 Clock Divider Select: 4" ]
            Adc10div4,
            # [ doc = "ADC10 Clock Divider Select: 5" ]
            Adc10div5,
            # [ doc = "ADC10 Clock Divider Select: 6" ]
            Adc10div6,
            # [ doc = "ADC10 Clock Divider Select: 7" ]
            Adc10div7,
        }
        impl Adc10divR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10divR::Adc10div0 => 0,
                    Adc10divR::Adc10div1 => 1,
                    Adc10divR::Adc10div2 => 2,
                    Adc10divR::Adc10div3 => 3,
                    Adc10divR::Adc10div4 => 4,
                    Adc10divR::Adc10div5 => 5,
                    Adc10divR::Adc10div6 => 6,
                    Adc10divR::Adc10div7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10divR {
                match bits {
                    0 => Adc10divR::Adc10div0,
                    1 => Adc10divR::Adc10div1,
                    2 => Adc10divR::Adc10div2,
                    3 => Adc10divR::Adc10div3,
                    4 => Adc10divR::Adc10div4,
                    5 => Adc10divR::Adc10div5,
                    6 => Adc10divR::Adc10div6,
                    7 => Adc10divR::Adc10div7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10div0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_0(&self) -> bool {
                *self == Adc10divR::Adc10div0
            }
            # [ doc = "Checks if the value of the field is `Adc10div1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_1(&self) -> bool {
                *self == Adc10divR::Adc10div1
            }
            # [ doc = "Checks if the value of the field is `Adc10div2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_2(&self) -> bool {
                *self == Adc10divR::Adc10div2
            }
            # [ doc = "Checks if the value of the field is `Adc10div3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_3(&self) -> bool {
                *self == Adc10divR::Adc10div3
            }
            # [ doc = "Checks if the value of the field is `Adc10div4`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_4(&self) -> bool {
                *self == Adc10divR::Adc10div4
            }
            # [ doc = "Checks if the value of the field is `Adc10div5`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_5(&self) -> bool {
                *self == Adc10divR::Adc10div5
            }
            # [ doc = "Checks if the value of the field is `Adc10div6`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_6(&self) -> bool {
                *self == Adc10divR::Adc10div6
            }
            # [ doc = "Checks if the value of the field is `Adc10div7`" ]
            # [ inline ( always ) ]
            pub fn is_adc10div_7(&self) -> bool {
                *self == Adc10divR::Adc10div7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10isshR {
            bits: u8,
        }
        impl Adc10isshR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10shpR {
            bits: u8,
        }
        impl Adc10shpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `ADC10SHS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10shsR {
            # [ doc = "ADC10 Sample/Hold Source: 0" ]
            Adc10shs0,
            # [ doc = "ADC10 Sample/Hold Source: 1" ]
            Adc10shs1,
            # [ doc = "ADC10 Sample/Hold Source: 2" ]
            Adc10shs2,
            # [ doc = "ADC10 Sample/Hold Source: 3" ]
            Adc10shs3,
        }
        impl Adc10shsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10shsR::Adc10shs0 => 0,
                    Adc10shsR::Adc10shs1 => 1,
                    Adc10shsR::Adc10shs2 => 2,
                    Adc10shsR::Adc10shs3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10shsR {
                match bits {
                    0 => Adc10shsR::Adc10shs0,
                    1 => Adc10shsR::Adc10shs1,
                    2 => Adc10shsR::Adc10shs2,
                    3 => Adc10shsR::Adc10shs3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10shs0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10shs_0(&self) -> bool {
                *self == Adc10shsR::Adc10shs0
            }
            # [ doc = "Checks if the value of the field is `Adc10shs1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10shs_1(&self) -> bool {
                *self == Adc10shsR::Adc10shs1
            }
            # [ doc = "Checks if the value of the field is `Adc10shs2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10shs_2(&self) -> bool {
                *self == Adc10shsR::Adc10shs2
            }
            # [ doc = "Checks if the value of the field is `Adc10shs3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10shs_3(&self) -> bool {
                *self == Adc10shsR::Adc10shs3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10busyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10busyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10CONSEQ`" ]
        pub enum Adc10conseqW {
            # [ doc = "ADC10 Conversion Sequence Select: 0" ]
            Adc10conseq0,
            # [ doc = "ADC10 Conversion Sequence Select: 1" ]
            Adc10conseq1,
            # [ doc = "ADC10 Conversion Sequence Select: 2" ]
            Adc10conseq2,
            # [ doc = "ADC10 Conversion Sequence Select: 3" ]
            Adc10conseq3,
        }
        impl Adc10conseqW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10conseqW::Adc10conseq0 => 0,
                    Adc10conseqW::Adc10conseq1 => 1,
                    Adc10conseqW::Adc10conseq2 => 2,
                    Adc10conseqW::Adc10conseq3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10conseqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10conseqW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10conseqW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Conversion Sequence Select: 0" ]
            # [ inline ( always ) ]
            pub fn adc10conseq_0(self) -> &'a mut W {
                self.variant(Adc10conseqW::Adc10conseq0)
            }
            # [ doc = "ADC10 Conversion Sequence Select: 1" ]
            # [ inline ( always ) ]
            pub fn adc10conseq_1(self) -> &'a mut W {
                self.variant(Adc10conseqW::Adc10conseq1)
            }
            # [ doc = "ADC10 Conversion Sequence Select: 2" ]
            # [ inline ( always ) ]
            pub fn adc10conseq_2(self) -> &'a mut W {
                self.variant(Adc10conseqW::Adc10conseq2)
            }
            # [ doc = "ADC10 Conversion Sequence Select: 3" ]
            # [ inline ( always ) ]
            pub fn adc10conseq_3(self) -> &'a mut W {
                self.variant(Adc10conseqW::Adc10conseq3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10SSEL`" ]
        pub enum Adc10sselW {
            # [ doc = "ADC10 Clock Source Select: 0" ]
            Adc10ssel0,
            # [ doc = "ADC10 Clock Source Select: 1" ]
            Adc10ssel1,
            # [ doc = "ADC10 Clock Source Select: 2" ]
            Adc10ssel2,
            # [ doc = "ADC10 Clock Source Select: 3" ]
            Adc10ssel3,
        }
        impl Adc10sselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10sselW::Adc10ssel0 => 0,
                    Adc10sselW::Adc10ssel1 => 1,
                    Adc10sselW::Adc10ssel2 => 2,
                    Adc10sselW::Adc10ssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10sselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10sselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10sselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Clock Source Select: 0" ]
            # [ inline ( always ) ]
            pub fn adc10ssel_0(self) -> &'a mut W {
                self.variant(Adc10sselW::Adc10ssel0)
            }
            # [ doc = "ADC10 Clock Source Select: 1" ]
            # [ inline ( always ) ]
            pub fn adc10ssel_1(self) -> &'a mut W {
                self.variant(Adc10sselW::Adc10ssel1)
            }
            # [ doc = "ADC10 Clock Source Select: 2" ]
            # [ inline ( always ) ]
            pub fn adc10ssel_2(self) -> &'a mut W {
                self.variant(Adc10sselW::Adc10ssel2)
            }
            # [ doc = "ADC10 Clock Source Select: 3" ]
            # [ inline ( always ) ]
            pub fn adc10ssel_3(self) -> &'a mut W {
                self.variant(Adc10sselW::Adc10ssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10DIV`" ]
        pub enum Adc10divW {
            # [ doc = "ADC10 Clock Divider Select: 0" ]
            Adc10div0,
            # [ doc = "ADC10 Clock Divider Select: 1" ]
            Adc10div1,
            # [ doc = "ADC10 Clock Divider Select: 2" ]
            Adc10div2,
            # [ doc = "ADC10 Clock Divider Select: 3" ]
            Adc10div3,
            # [ doc = "ADC10 Clock Divider Select: 4" ]
            Adc10div4,
            # [ doc = "ADC10 Clock Divider Select: 5" ]
            Adc10div5,
            # [ doc = "ADC10 Clock Divider Select: 6" ]
            Adc10div6,
            # [ doc = "ADC10 Clock Divider Select: 7" ]
            Adc10div7,
        }
        impl Adc10divW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10divW::Adc10div0 => 0,
                    Adc10divW::Adc10div1 => 1,
                    Adc10divW::Adc10div2 => 2,
                    Adc10divW::Adc10div3 => 3,
                    Adc10divW::Adc10div4 => 4,
                    Adc10divW::Adc10div5 => 5,
                    Adc10divW::Adc10div6 => 6,
                    Adc10divW::Adc10div7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10divW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10divW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10divW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Clock Divider Select: 0" ]
            # [ inline ( always ) ]
            pub fn adc10div_0(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div0)
            }
            # [ doc = "ADC10 Clock Divider Select: 1" ]
            # [ inline ( always ) ]
            pub fn adc10div_1(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div1)
            }
            # [ doc = "ADC10 Clock Divider Select: 2" ]
            # [ inline ( always ) ]
            pub fn adc10div_2(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div2)
            }
            # [ doc = "ADC10 Clock Divider Select: 3" ]
            # [ inline ( always ) ]
            pub fn adc10div_3(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div3)
            }
            # [ doc = "ADC10 Clock Divider Select: 4" ]
            # [ inline ( always ) ]
            pub fn adc10div_4(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div4)
            }
            # [ doc = "ADC10 Clock Divider Select: 5" ]
            # [ inline ( always ) ]
            pub fn adc10div_5(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div5)
            }
            # [ doc = "ADC10 Clock Divider Select: 6" ]
            # [ inline ( always ) ]
            pub fn adc10div_6(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div6)
            }
            # [ doc = "ADC10 Clock Divider Select: 7" ]
            # [ inline ( always ) ]
            pub fn adc10div_7(self) -> &'a mut W {
                self.variant(Adc10divW::Adc10div7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10isshW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10isshW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10shpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10shpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10SHS`" ]
        pub enum Adc10shsW {
            # [ doc = "ADC10 Sample/Hold Source: 0" ]
            Adc10shs0,
            # [ doc = "ADC10 Sample/Hold Source: 1" ]
            Adc10shs1,
            # [ doc = "ADC10 Sample/Hold Source: 2" ]
            Adc10shs2,
            # [ doc = "ADC10 Sample/Hold Source: 3" ]
            Adc10shs3,
        }
        impl Adc10shsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10shsW::Adc10shs0 => 0,
                    Adc10shsW::Adc10shs1 => 1,
                    Adc10shsW::Adc10shs2 => 2,
                    Adc10shsW::Adc10shs3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10shsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10shsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10shsW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Sample/Hold Source: 0" ]
            # [ inline ( always ) ]
            pub fn adc10shs_0(self) -> &'a mut W {
                self.variant(Adc10shsW::Adc10shs0)
            }
            # [ doc = "ADC10 Sample/Hold Source: 1" ]
            # [ inline ( always ) ]
            pub fn adc10shs_1(self) -> &'a mut W {
                self.variant(Adc10shsW::Adc10shs1)
            }
            # [ doc = "ADC10 Sample/Hold Source: 2" ]
            # [ inline ( always ) ]
            pub fn adc10shs_2(self) -> &'a mut W {
                self.variant(Adc10shsW::Adc10shs2)
            }
            # [ doc = "ADC10 Sample/Hold Source: 3" ]
            # [ inline ( always ) ]
            pub fn adc10shs_3(self) -> &'a mut W {
                self.variant(Adc10shsW::Adc10shs3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - ADC10 Busy" ]
            # [ inline ( always ) ]
            pub fn adc10busy(&self) -> Adc10busyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10busyR { bits }
            }
            # [ doc = "Bits 2:3 - ADC10 Conversion Sequence Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10conseq(&self) -> Adc10conseqR {
                Adc10conseqR::_from({
                                        const MASK: u8 = 3;
                                        const OFFSET: u8 = 2;
                                        ((self.bits >> OFFSET) & MASK as u16) as u8
                                    })
            }
            # [ doc = "Bits 4:5 - ADC10 Clock Source Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10ssel(&self) -> Adc10sselR {
                Adc10sselR::_from({
                                      const MASK: u8 = 3;
                                      const OFFSET: u8 = 4;
                                      ((self.bits >> OFFSET) & MASK as u16) as u8
                                  })
            }
            # [ doc = "Bits 7:9 - ADC10 Clock Divider Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10div(&self) -> Adc10divR {
                Adc10divR::_from({
                                     const MASK: u8 = 7;
                                     const OFFSET: u8 = 7;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bit 8 - ADC10 Invert Sample Hold Signal" ]
            # [ inline ( always ) ]
            pub fn adc10issh(&self) -> Adc10isshR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10isshR { bits }
            }
            # [ doc = "Bit 9 - ADC10 Sample/Hold Pulse Mode" ]
            # [ inline ( always ) ]
            pub fn adc10shp(&self) -> Adc10shpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10shpR { bits }
            }
            # [ doc = "Bits 11:12 - ADC10 Sample/Hold Source 0" ]
            # [ inline ( always ) ]
            pub fn adc10shs(&self) -> Adc10shsR {
                Adc10shsR::_from({
                                     const MASK: u8 = 3;
                                     const OFFSET: u8 = 11;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - ADC10 Busy" ]
            # [ inline ( always ) ]
            pub fn adc10busy(&mut self) -> _Adc10busyW {
                _Adc10busyW { w: self }
            }
            # [ doc = "Bits 2:3 - ADC10 Conversion Sequence Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10conseq(&mut self) -> _Adc10conseqW {
                _Adc10conseqW { w: self }
            }
            # [ doc = "Bits 4:5 - ADC10 Clock Source Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10ssel(&mut self) -> _Adc10sselW {
                _Adc10sselW { w: self }
            }
            # [ doc = "Bits 7:9 - ADC10 Clock Divider Select 0" ]
            # [ inline ( always ) ]
            pub fn adc10div(&mut self) -> _Adc10divW {
                _Adc10divW { w: self }
            }
            # [ doc = "Bit 8 - ADC10 Invert Sample Hold Signal" ]
            # [ inline ( always ) ]
            pub fn adc10issh(&mut self) -> _Adc10isshW {
                _Adc10isshW { w: self }
            }
            # [ doc = "Bit 9 - ADC10 Sample/Hold Pulse Mode" ]
            # [ inline ( always ) ]
            pub fn adc10shp(&mut self) -> _Adc10shpW {
                _Adc10shpW { w: self }
            }
            # [ doc = "Bits 11:12 - ADC10 Sample/Hold Source 0" ]
            # [ inline ( always ) ]
            pub fn adc10shs(&mut self) -> _Adc10shsW {
                _Adc10shsW { w: self }
            }
        }
    }
    # [ doc = "ADC10 Control 2" ]
    pub struct Adc10ctl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Control 2" ]
    pub mod adc10ctl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10ctl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10refburstR {
            bits: u8,
        }
        impl Adc10refburstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10srR {
            bits: u8,
        }
        impl Adc10srR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10dfR {
            bits: u8,
        }
        impl Adc10dfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10resR {
            bits: u8,
        }
        impl Adc10resR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `ADC10PDIV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10pdivR {
            # [ doc = "ADC10 predivider /1" ]
            Adc10pdiv0,
            # [ doc = "ADC10 predivider /2" ]
            Adc10pdiv1,
            # [ doc = "ADC10 predivider /64" ]
            Adc10pdiv2,
            # [ doc = "ADC10 predivider reserved" ]
            Adc10pdiv3,
        }
        impl Adc10pdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10pdivR::Adc10pdiv0 => 0,
                    Adc10pdivR::Adc10pdiv1 => 1,
                    Adc10pdivR::Adc10pdiv2 => 2,
                    Adc10pdivR::Adc10pdiv3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10pdivR {
                match bits {
                    0 => Adc10pdivR::Adc10pdiv0,
                    1 => Adc10pdivR::Adc10pdiv1,
                    2 => Adc10pdivR::Adc10pdiv2,
                    3 => Adc10pdivR::Adc10pdiv3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10pdiv0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10pdiv_0(&self) -> bool {
                *self == Adc10pdivR::Adc10pdiv0
            }
            # [ doc = "Checks if the value of the field is `Adc10pdiv1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10pdiv_1(&self) -> bool {
                *self == Adc10pdivR::Adc10pdiv1
            }
            # [ doc = "Checks if the value of the field is `Adc10pdiv2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10pdiv_2(&self) -> bool {
                *self == Adc10pdivR::Adc10pdiv2
            }
            # [ doc = "Checks if the value of the field is `Adc10pdiv3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10pdiv_3(&self) -> bool {
                *self == Adc10pdivR::Adc10pdiv3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10refburstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10refburstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10srW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10srW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10dfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10dfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10resW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10resW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10PDIV`" ]
        pub enum Adc10pdivW {
            # [ doc = "ADC10 predivider /1" ]
            Adc10pdiv0,
            # [ doc = "ADC10 predivider /2" ]
            Adc10pdiv1,
            # [ doc = "ADC10 predivider /64" ]
            Adc10pdiv2,
            # [ doc = "ADC10 predivider reserved" ]
            Adc10pdiv3,
        }
        impl Adc10pdivW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10pdivW::Adc10pdiv0 => 0,
                    Adc10pdivW::Adc10pdiv1 => 1,
                    Adc10pdivW::Adc10pdiv2 => 2,
                    Adc10pdivW::Adc10pdiv3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10pdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10pdivW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10pdivW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 predivider /1" ]
            # [ inline ( always ) ]
            pub fn adc10pdiv_0(self) -> &'a mut W {
                self.variant(Adc10pdivW::Adc10pdiv0)
            }
            # [ doc = "ADC10 predivider /2" ]
            # [ inline ( always ) ]
            pub fn adc10pdiv_1(self) -> &'a mut W {
                self.variant(Adc10pdivW::Adc10pdiv1)
            }
            # [ doc = "ADC10 predivider /64" ]
            # [ inline ( always ) ]
            pub fn adc10pdiv_2(self) -> &'a mut W {
                self.variant(Adc10pdivW::Adc10pdiv2)
            }
            # [ doc = "ADC10 predivider reserved" ]
            # [ inline ( always ) ]
            pub fn adc10pdiv_3(self) -> &'a mut W {
                self.variant(Adc10pdivW::Adc10pdiv3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - ADC10 Reference Burst" ]
            # [ inline ( always ) ]
            pub fn adc10refburst(&self) -> Adc10refburstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10refburstR { bits }
            }
            # [ doc = "Bit 2 - ADC10 Sampling Rate" ]
            # [ inline ( always ) ]
            pub fn adc10sr(&self) -> Adc10srR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10srR { bits }
            }
            # [ doc = "Bit 3 - ADC10 Data Format" ]
            # [ inline ( always ) ]
            pub fn adc10df(&self) -> Adc10dfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10dfR { bits }
            }
            # [ doc = "Bit 4 - ADC10 Resolution Bit" ]
            # [ inline ( always ) ]
            pub fn adc10res(&self) -> Adc10resR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10resR { bits }
            }
            # [ doc = "Bits 9:10 - ADC10 predivider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn adc10pdiv(&self) -> Adc10pdivR {
                Adc10pdivR::_from({
                                      const MASK: u8 = 3;
                                      const OFFSET: u8 = 9;
                                      ((self.bits >> OFFSET) & MASK as u16) as u8
                                  })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - ADC10 Reference Burst" ]
            # [ inline ( always ) ]
            pub fn adc10refburst(&mut self) -> _Adc10refburstW {
                _Adc10refburstW { w: self }
            }
            # [ doc = "Bit 2 - ADC10 Sampling Rate" ]
            # [ inline ( always ) ]
            pub fn adc10sr(&mut self) -> _Adc10srW {
                _Adc10srW { w: self }
            }
            # [ doc = "Bit 3 - ADC10 Data Format" ]
            # [ inline ( always ) ]
            pub fn adc10df(&mut self) -> _Adc10dfW {
                _Adc10dfW { w: self }
            }
            # [ doc = "Bit 4 - ADC10 Resolution Bit" ]
            # [ inline ( always ) ]
            pub fn adc10res(&mut self) -> _Adc10resW {
                _Adc10resW { w: self }
            }
            # [ doc = "Bits 9:10 - ADC10 predivider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn adc10pdiv(&mut self) -> _Adc10pdivW {
                _Adc10pdivW { w: self }
            }
        }
    }
    # [ doc = "ADC10 Window Comparator High Threshold" ]
    pub struct Adc10lo {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Window Comparator High Threshold" ]
    pub mod adc10lo {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10lo {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ADC10 Window Comparator High Threshold" ]
    pub struct Adc10hi {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Window Comparator High Threshold" ]
    pub mod adc10hi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10hi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ADC10 Memory Control 0" ]
    pub struct Adc10mctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Memory Control 0" ]
    pub mod adc10mctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10mctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `ADC10INCH`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10inchR {
            # [ doc = "ADC10 Input Channel 0" ]
            Adc10inch0,
            # [ doc = "ADC10 Input Channel 1" ]
            Adc10inch1,
            # [ doc = "ADC10 Input Channel 2" ]
            Adc10inch2,
            # [ doc = "ADC10 Input Channel 3" ]
            Adc10inch3,
            # [ doc = "ADC10 Input Channel 4" ]
            Adc10inch4,
            # [ doc = "ADC10 Input Channel 5" ]
            Adc10inch5,
            # [ doc = "ADC10 Input Channel 6" ]
            Adc10inch6,
            # [ doc = "ADC10 Input Channel 7" ]
            Adc10inch7,
            # [ doc = "ADC10 Input Channel 8" ]
            Adc10inch8,
            # [ doc = "ADC10 Input Channel 9" ]
            Adc10inch9,
            # [ doc = "ADC10 Input Channel 10" ]
            Adc10inch10,
            # [ doc = "ADC10 Input Channel 11" ]
            Adc10inch11,
            # [ doc = "ADC10 Input Channel 12" ]
            Adc10inch12,
            # [ doc = "ADC10 Input Channel 13" ]
            Adc10inch13,
            # [ doc = "ADC10 Input Channel 14" ]
            Adc10inch14,
            # [ doc = "ADC10 Input Channel 15" ]
            Adc10inch15,
        }
        impl Adc10inchR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10inchR::Adc10inch0 => 0,
                    Adc10inchR::Adc10inch1 => 1,
                    Adc10inchR::Adc10inch2 => 2,
                    Adc10inchR::Adc10inch3 => 3,
                    Adc10inchR::Adc10inch4 => 4,
                    Adc10inchR::Adc10inch5 => 5,
                    Adc10inchR::Adc10inch6 => 6,
                    Adc10inchR::Adc10inch7 => 7,
                    Adc10inchR::Adc10inch8 => 8,
                    Adc10inchR::Adc10inch9 => 9,
                    Adc10inchR::Adc10inch10 => 10,
                    Adc10inchR::Adc10inch11 => 11,
                    Adc10inchR::Adc10inch12 => 12,
                    Adc10inchR::Adc10inch13 => 13,
                    Adc10inchR::Adc10inch14 => 14,
                    Adc10inchR::Adc10inch15 => 15,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10inchR {
                match bits {
                    0 => Adc10inchR::Adc10inch0,
                    1 => Adc10inchR::Adc10inch1,
                    2 => Adc10inchR::Adc10inch2,
                    3 => Adc10inchR::Adc10inch3,
                    4 => Adc10inchR::Adc10inch4,
                    5 => Adc10inchR::Adc10inch5,
                    6 => Adc10inchR::Adc10inch6,
                    7 => Adc10inchR::Adc10inch7,
                    8 => Adc10inchR::Adc10inch8,
                    9 => Adc10inchR::Adc10inch9,
                    10 => Adc10inchR::Adc10inch10,
                    11 => Adc10inchR::Adc10inch11,
                    12 => Adc10inchR::Adc10inch12,
                    13 => Adc10inchR::Adc10inch13,
                    14 => Adc10inchR::Adc10inch14,
                    15 => Adc10inchR::Adc10inch15,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10inch0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_0(&self) -> bool {
                *self == Adc10inchR::Adc10inch0
            }
            # [ doc = "Checks if the value of the field is `Adc10inch1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_1(&self) -> bool {
                *self == Adc10inchR::Adc10inch1
            }
            # [ doc = "Checks if the value of the field is `Adc10inch2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_2(&self) -> bool {
                *self == Adc10inchR::Adc10inch2
            }
            # [ doc = "Checks if the value of the field is `Adc10inch3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_3(&self) -> bool {
                *self == Adc10inchR::Adc10inch3
            }
            # [ doc = "Checks if the value of the field is `Adc10inch4`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_4(&self) -> bool {
                *self == Adc10inchR::Adc10inch4
            }
            # [ doc = "Checks if the value of the field is `Adc10inch5`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_5(&self) -> bool {
                *self == Adc10inchR::Adc10inch5
            }
            # [ doc = "Checks if the value of the field is `Adc10inch6`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_6(&self) -> bool {
                *self == Adc10inchR::Adc10inch6
            }
            # [ doc = "Checks if the value of the field is `Adc10inch7`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_7(&self) -> bool {
                *self == Adc10inchR::Adc10inch7
            }
            # [ doc = "Checks if the value of the field is `Adc10inch8`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_8(&self) -> bool {
                *self == Adc10inchR::Adc10inch8
            }
            # [ doc = "Checks if the value of the field is `Adc10inch9`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_9(&self) -> bool {
                *self == Adc10inchR::Adc10inch9
            }
            # [ doc = "Checks if the value of the field is `Adc10inch10`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_10(&self) -> bool {
                *self == Adc10inchR::Adc10inch10
            }
            # [ doc = "Checks if the value of the field is `Adc10inch11`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_11(&self) -> bool {
                *self == Adc10inchR::Adc10inch11
            }
            # [ doc = "Checks if the value of the field is `Adc10inch12`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_12(&self) -> bool {
                *self == Adc10inchR::Adc10inch12
            }
            # [ doc = "Checks if the value of the field is `Adc10inch13`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_13(&self) -> bool {
                *self == Adc10inchR::Adc10inch13
            }
            # [ doc = "Checks if the value of the field is `Adc10inch14`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_14(&self) -> bool {
                *self == Adc10inchR::Adc10inch14
            }
            # [ doc = "Checks if the value of the field is `Adc10inch15`" ]
            # [ inline ( always ) ]
            pub fn is_adc10inch_15(&self) -> bool {
                *self == Adc10inchR::Adc10inch15
            }
        }
        # [ doc = "Possible values of the field `ADC10SREF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Adc10srefR {
            # [ doc = "ADC10 Select Reference 0" ]
            Adc10sref0,
            # [ doc = "ADC10 Select Reference 1" ]
            Adc10sref1,
            # [ doc = "ADC10 Select Reference 2" ]
            Adc10sref2,
            # [ doc = "ADC10 Select Reference 3" ]
            Adc10sref3,
            # [ doc = "ADC10 Select Reference 4" ]
            Adc10sref4,
            # [ doc = "ADC10 Select Reference 5" ]
            Adc10sref5,
            # [ doc = "ADC10 Select Reference 6" ]
            Adc10sref6,
            # [ doc = "ADC10 Select Reference 7" ]
            Adc10sref7,
        }
        impl Adc10srefR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Adc10srefR::Adc10sref0 => 0,
                    Adc10srefR::Adc10sref1 => 1,
                    Adc10srefR::Adc10sref2 => 2,
                    Adc10srefR::Adc10sref3 => 3,
                    Adc10srefR::Adc10sref4 => 4,
                    Adc10srefR::Adc10sref5 => 5,
                    Adc10srefR::Adc10sref6 => 6,
                    Adc10srefR::Adc10sref7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Adc10srefR {
                match bits {
                    0 => Adc10srefR::Adc10sref0,
                    1 => Adc10srefR::Adc10sref1,
                    2 => Adc10srefR::Adc10sref2,
                    3 => Adc10srefR::Adc10sref3,
                    4 => Adc10srefR::Adc10sref4,
                    5 => Adc10srefR::Adc10sref5,
                    6 => Adc10srefR::Adc10sref6,
                    7 => Adc10srefR::Adc10sref7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Adc10sref0`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_0(&self) -> bool {
                *self == Adc10srefR::Adc10sref0
            }
            # [ doc = "Checks if the value of the field is `Adc10sref1`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_1(&self) -> bool {
                *self == Adc10srefR::Adc10sref1
            }
            # [ doc = "Checks if the value of the field is `Adc10sref2`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_2(&self) -> bool {
                *self == Adc10srefR::Adc10sref2
            }
            # [ doc = "Checks if the value of the field is `Adc10sref3`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_3(&self) -> bool {
                *self == Adc10srefR::Adc10sref3
            }
            # [ doc = "Checks if the value of the field is `Adc10sref4`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_4(&self) -> bool {
                *self == Adc10srefR::Adc10sref4
            }
            # [ doc = "Checks if the value of the field is `Adc10sref5`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_5(&self) -> bool {
                *self == Adc10srefR::Adc10sref5
            }
            # [ doc = "Checks if the value of the field is `Adc10sref6`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_6(&self) -> bool {
                *self == Adc10srefR::Adc10sref6
            }
            # [ doc = "Checks if the value of the field is `Adc10sref7`" ]
            # [ inline ( always ) ]
            pub fn is_adc10sref_7(&self) -> bool {
                *self == Adc10srefR::Adc10sref7
            }
        }
        # [ doc = "Values that can be written to the field `ADC10INCH`" ]
        pub enum Adc10inchW {
            # [ doc = "ADC10 Input Channel 0" ]
            Adc10inch0,
            # [ doc = "ADC10 Input Channel 1" ]
            Adc10inch1,
            # [ doc = "ADC10 Input Channel 2" ]
            Adc10inch2,
            # [ doc = "ADC10 Input Channel 3" ]
            Adc10inch3,
            # [ doc = "ADC10 Input Channel 4" ]
            Adc10inch4,
            # [ doc = "ADC10 Input Channel 5" ]
            Adc10inch5,
            # [ doc = "ADC10 Input Channel 6" ]
            Adc10inch6,
            # [ doc = "ADC10 Input Channel 7" ]
            Adc10inch7,
            # [ doc = "ADC10 Input Channel 8" ]
            Adc10inch8,
            # [ doc = "ADC10 Input Channel 9" ]
            Adc10inch9,
            # [ doc = "ADC10 Input Channel 10" ]
            Adc10inch10,
            # [ doc = "ADC10 Input Channel 11" ]
            Adc10inch11,
            # [ doc = "ADC10 Input Channel 12" ]
            Adc10inch12,
            # [ doc = "ADC10 Input Channel 13" ]
            Adc10inch13,
            # [ doc = "ADC10 Input Channel 14" ]
            Adc10inch14,
            # [ doc = "ADC10 Input Channel 15" ]
            Adc10inch15,
        }
        impl Adc10inchW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10inchW::Adc10inch0 => 0,
                    Adc10inchW::Adc10inch1 => 1,
                    Adc10inchW::Adc10inch2 => 2,
                    Adc10inchW::Adc10inch3 => 3,
                    Adc10inchW::Adc10inch4 => 4,
                    Adc10inchW::Adc10inch5 => 5,
                    Adc10inchW::Adc10inch6 => 6,
                    Adc10inchW::Adc10inch7 => 7,
                    Adc10inchW::Adc10inch8 => 8,
                    Adc10inchW::Adc10inch9 => 9,
                    Adc10inchW::Adc10inch10 => 10,
                    Adc10inchW::Adc10inch11 => 11,
                    Adc10inchW::Adc10inch12 => 12,
                    Adc10inchW::Adc10inch13 => 13,
                    Adc10inchW::Adc10inch14 => 14,
                    Adc10inchW::Adc10inch15 => 15,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10inchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10inchW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10inchW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Input Channel 0" ]
            # [ inline ( always ) ]
            pub fn adc10inch_0(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch0)
            }
            # [ doc = "ADC10 Input Channel 1" ]
            # [ inline ( always ) ]
            pub fn adc10inch_1(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch1)
            }
            # [ doc = "ADC10 Input Channel 2" ]
            # [ inline ( always ) ]
            pub fn adc10inch_2(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch2)
            }
            # [ doc = "ADC10 Input Channel 3" ]
            # [ inline ( always ) ]
            pub fn adc10inch_3(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch3)
            }
            # [ doc = "ADC10 Input Channel 4" ]
            # [ inline ( always ) ]
            pub fn adc10inch_4(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch4)
            }
            # [ doc = "ADC10 Input Channel 5" ]
            # [ inline ( always ) ]
            pub fn adc10inch_5(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch5)
            }
            # [ doc = "ADC10 Input Channel 6" ]
            # [ inline ( always ) ]
            pub fn adc10inch_6(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch6)
            }
            # [ doc = "ADC10 Input Channel 7" ]
            # [ inline ( always ) ]
            pub fn adc10inch_7(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch7)
            }
            # [ doc = "ADC10 Input Channel 8" ]
            # [ inline ( always ) ]
            pub fn adc10inch_8(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch8)
            }
            # [ doc = "ADC10 Input Channel 9" ]
            # [ inline ( always ) ]
            pub fn adc10inch_9(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch9)
            }
            # [ doc = "ADC10 Input Channel 10" ]
            # [ inline ( always ) ]
            pub fn adc10inch_10(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch10)
            }
            # [ doc = "ADC10 Input Channel 11" ]
            # [ inline ( always ) ]
            pub fn adc10inch_11(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch11)
            }
            # [ doc = "ADC10 Input Channel 12" ]
            # [ inline ( always ) ]
            pub fn adc10inch_12(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch12)
            }
            # [ doc = "ADC10 Input Channel 13" ]
            # [ inline ( always ) ]
            pub fn adc10inch_13(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch13)
            }
            # [ doc = "ADC10 Input Channel 14" ]
            # [ inline ( always ) ]
            pub fn adc10inch_14(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch14)
            }
            # [ doc = "ADC10 Input Channel 15" ]
            # [ inline ( always ) ]
            pub fn adc10inch_15(self) -> &'a mut W {
                self.variant(Adc10inchW::Adc10inch15)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ADC10SREF`" ]
        pub enum Adc10srefW {
            # [ doc = "ADC10 Select Reference 0" ]
            Adc10sref0,
            # [ doc = "ADC10 Select Reference 1" ]
            Adc10sref1,
            # [ doc = "ADC10 Select Reference 2" ]
            Adc10sref2,
            # [ doc = "ADC10 Select Reference 3" ]
            Adc10sref3,
            # [ doc = "ADC10 Select Reference 4" ]
            Adc10sref4,
            # [ doc = "ADC10 Select Reference 5" ]
            Adc10sref5,
            # [ doc = "ADC10 Select Reference 6" ]
            Adc10sref6,
            # [ doc = "ADC10 Select Reference 7" ]
            Adc10sref7,
        }
        impl Adc10srefW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Adc10srefW::Adc10sref0 => 0,
                    Adc10srefW::Adc10sref1 => 1,
                    Adc10srefW::Adc10sref2 => 2,
                    Adc10srefW::Adc10sref3 => 3,
                    Adc10srefW::Adc10sref4 => 4,
                    Adc10srefW::Adc10sref5 => 5,
                    Adc10srefW::Adc10sref6 => 6,
                    Adc10srefW::Adc10sref7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10srefW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10srefW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Adc10srefW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ADC10 Select Reference 0" ]
            # [ inline ( always ) ]
            pub fn adc10sref_0(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref0)
            }
            # [ doc = "ADC10 Select Reference 1" ]
            # [ inline ( always ) ]
            pub fn adc10sref_1(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref1)
            }
            # [ doc = "ADC10 Select Reference 2" ]
            # [ inline ( always ) ]
            pub fn adc10sref_2(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref2)
            }
            # [ doc = "ADC10 Select Reference 3" ]
            # [ inline ( always ) ]
            pub fn adc10sref_3(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref3)
            }
            # [ doc = "ADC10 Select Reference 4" ]
            # [ inline ( always ) ]
            pub fn adc10sref_4(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref4)
            }
            # [ doc = "ADC10 Select Reference 5" ]
            # [ inline ( always ) ]
            pub fn adc10sref_5(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref5)
            }
            # [ doc = "ADC10 Select Reference 6" ]
            # [ inline ( always ) ]
            pub fn adc10sref_6(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref6)
            }
            # [ doc = "ADC10 Select Reference 7" ]
            # [ inline ( always ) ]
            pub fn adc10sref_7(self) -> &'a mut W {
                self.variant(Adc10srefW::Adc10sref7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 3:6 - ADC10 Input Channel Select Bit 0" ]
            # [ inline ( always ) ]
            pub fn adc10inch(&self) -> Adc10inchR {
                Adc10inchR::_from({
                                      const MASK: u8 = 15;
                                      const OFFSET: u8 = 3;
                                      ((self.bits >> OFFSET) & MASK as u16) as u8
                                  })
            }
            # [ doc = "Bits 6:8 - ADC10 Select Reference Bit 0" ]
            # [ inline ( always ) ]
            pub fn adc10sref(&self) -> Adc10srefR {
                Adc10srefR::_from({
                                      const MASK: u8 = 7;
                                      const OFFSET: u8 = 6;
                                      ((self.bits >> OFFSET) & MASK as u16) as u8
                                  })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 3:6 - ADC10 Input Channel Select Bit 0" ]
            # [ inline ( always ) ]
            pub fn adc10inch(&mut self) -> _Adc10inchW {
                _Adc10inchW { w: self }
            }
            # [ doc = "Bits 6:8 - ADC10 Select Reference Bit 0" ]
            # [ inline ( always ) ]
            pub fn adc10sref(&mut self) -> _Adc10srefW {
                _Adc10srefW { w: self }
            }
        }
    }
    # [ doc = "ADC10 Conversion Memory 0" ]
    pub struct Adc10mem0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Conversion Memory 0" ]
    pub mod adc10mem0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10mem0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "ADC10 Interrupt Enable" ]
    pub struct Adc10ie {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Interrupt Enable" ]
    pub mod adc10ie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10ie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10ie0R {
            bits: u8,
        }
        impl Adc10ie0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10inieR {
            bits: u8,
        }
        impl Adc10inieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10loieR {
            bits: u8,
        }
        impl Adc10loieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10hiieR {
            bits: u8,
        }
        impl Adc10hiieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10ovieR {
            bits: u8,
        }
        impl Adc10ovieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10tovieR {
            bits: u8,
        }
        impl Adc10tovieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10ie0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10ie0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10inieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10inieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10loieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10loieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10hiieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10hiieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10ovieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10ovieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10tovieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10tovieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - ADC10_A Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn adc10ie0(&self) -> Adc10ie0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10ie0R { bits }
            }
            # [ doc = "Bit 1 - ADC10_A Interrupt enable for the inside of window of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10inie(&self) -> Adc10inieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10inieR { bits }
            }
            # [ doc = "Bit 2 - ADC10_A Interrupt enable for lower threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10loie(&self) -> Adc10loieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10loieR { bits }
            }
            # [ doc = "Bit 3 - ADC10_A Interrupt enable for upper threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10hiie(&self) -> Adc10hiieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10hiieR { bits }
            }
            # [ doc = "Bit 4 - ADC10_A ADC10MEM overflow Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn adc10ovie(&self) -> Adc10ovieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10ovieR { bits }
            }
            # [ doc = "Bit 5 - ADC10_A conversion-time-overflow Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn adc10tovie(&self) -> Adc10tovieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10tovieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - ADC10_A Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn adc10ie0(&mut self) -> _Adc10ie0W {
                _Adc10ie0W { w: self }
            }
            # [ doc = "Bit 1 - ADC10_A Interrupt enable for the inside of window of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10inie(&mut self) -> _Adc10inieW {
                _Adc10inieW { w: self }
            }
            # [ doc = "Bit 2 - ADC10_A Interrupt enable for lower threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10loie(&mut self) -> _Adc10loieW {
                _Adc10loieW { w: self }
            }
            # [ doc = "Bit 3 - ADC10_A Interrupt enable for upper threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10hiie(&mut self) -> _Adc10hiieW {
                _Adc10hiieW { w: self }
            }
            # [ doc = "Bit 4 - ADC10_A ADC10MEM overflow Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn adc10ovie(&mut self) -> _Adc10ovieW {
                _Adc10ovieW { w: self }
            }
            # [ doc = "Bit 5 - ADC10_A conversion-time-overflow Interrupt enable" ]
            # [ inline ( always ) ]
            pub fn adc10tovie(&mut self) -> _Adc10tovieW {
                _Adc10tovieW { w: self }
            }
        }
    }
    # [ doc = "ADC10 Interrupt Flag" ]
    pub struct Adc10ifg {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Interrupt Flag" ]
    pub mod adc10ifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10ifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10ifg0R {
            bits: u8,
        }
        impl Adc10ifg0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10inifgR {
            bits: u8,
        }
        impl Adc10inifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10loifgR {
            bits: u8,
        }
        impl Adc10loifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10hiifgR {
            bits: u8,
        }
        impl Adc10hiifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10ovifgR {
            bits: u8,
        }
        impl Adc10ovifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Adc10tovifgR {
            bits: u8,
        }
        impl Adc10tovifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10ifg0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10ifg0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10inifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10inifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10loifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10loifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10hiifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10hiifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10ovifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10ovifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Adc10tovifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Adc10tovifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - ADC10_A Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn adc10ifg0(&self) -> Adc10ifg0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10ifg0R { bits }
            }
            # [ doc = "Bit 1 - ADC10_A Interrupt Flag for the inside of window of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10inifg(&self) -> Adc10inifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10inifgR { bits }
            }
            # [ doc = "Bit 2 - ADC10_A Interrupt Flag for lower threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10loifg(&self) -> Adc10loifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10loifgR { bits }
            }
            # [ doc = "Bit 3 - ADC10_A Interrupt Flag for upper threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10hiifg(&self) -> Adc10hiifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10hiifgR { bits }
            }
            # [ doc = "Bit 4 - ADC10_A ADC10MEM overflow Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn adc10ovifg(&self) -> Adc10ovifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10ovifgR { bits }
            }
            # [ doc = "Bit 5 - ADC10_A conversion-time-overflow Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn adc10tovifg(&self) -> Adc10tovifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Adc10tovifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - ADC10_A Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn adc10ifg0(&mut self) -> _Adc10ifg0W {
                _Adc10ifg0W { w: self }
            }
            # [ doc = "Bit 1 - ADC10_A Interrupt Flag for the inside of window of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10inifg(&mut self) -> _Adc10inifgW {
                _Adc10inifgW { w: self }
            }
            # [ doc = "Bit 2 - ADC10_A Interrupt Flag for lower threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10loifg(&mut self) -> _Adc10loifgW {
                _Adc10loifgW { w: self }
            }
            # [ doc = "Bit 3 - ADC10_A Interrupt Flag for upper threshold of the Window comparator" ]
            # [ inline ( always ) ]
            pub fn adc10hiifg(&mut self) -> _Adc10hiifgW {
                _Adc10hiifgW { w: self }
            }
            # [ doc = "Bit 4 - ADC10_A ADC10MEM overflow Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn adc10ovifg(&mut self) -> _Adc10ovifgW {
                _Adc10ovifgW { w: self }
            }
            # [ doc = "Bit 5 - ADC10_A conversion-time-overflow Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn adc10tovifg(&mut self) -> _Adc10tovifgW {
                _Adc10tovifgW { w: self }
            }
        }
    }
    # [ doc = "ADC10 Interrupt Vector Word" ]
    pub struct Adc10iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "ADC10 Interrupt Vector Word" ]
    pub mod adc10iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Adc10iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "ADC10_A" ]
pub struct Adc10A {
    register_block: adc10_a::RegisterBlock,
}
impl Deref for Adc10A {
    type Target = adc10_a::RegisterBlock;
    fn deref(&self) -> &adc10_a::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "AES Accelerator" ]
pub const AES_ACCELERATOR: Peripheral<AesAccelerator> = unsafe { Peripheral::new(0) };
# [ doc = "AES Accelerator" ]
pub mod aes_accelerator {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 2496usize],
        # [ doc = "0x9c0 - AES accelerator control register 0" ]
        pub aesactl0: Aesactl0,
        _reserved1: [u8; 2usize],
        # [ doc = "0x9c4 - AES accelerator status register" ]
        pub aesastat: Aesastat,
        # [ doc = "0x9c6 - AES accelerator key register" ]
        pub aesakey: Aesakey,
        # [ doc = "0x9c8 - AES accelerator data in register" ]
        pub aesadin: Aesadin,
        # [ doc = "0x9ca - AES accelerator data out register" ]
        pub aesadout: Aesadout,
    }
    # [ doc = "AES accelerator control register 0" ]
    pub struct Aesactl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "AES accelerator control register 0" ]
    pub mod aesactl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Aesactl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `AESOP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum AesopR {
            # [ doc = "AES Operation: Encrypt" ]
            Aesop0,
            # [ doc = "AES Operation: Decrypt (same Key)" ]
            Aesop1,
            # [ doc = "AES Operation: Generate first round Key" ]
            Aesop2,
            # [ doc = "AES Operation: Decrypt (first round Key)" ]
            Aesop3,
        }
        impl AesopR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    AesopR::Aesop0 => 0,
                    AesopR::Aesop1 => 1,
                    AesopR::Aesop2 => 2,
                    AesopR::Aesop3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> AesopR {
                match bits {
                    0 => AesopR::Aesop0,
                    1 => AesopR::Aesop1,
                    2 => AesopR::Aesop2,
                    3 => AesopR::Aesop3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Aesop0`" ]
            # [ inline ( always ) ]
            pub fn is_aesop_0(&self) -> bool {
                *self == AesopR::Aesop0
            }
            # [ doc = "Checks if the value of the field is `Aesop1`" ]
            # [ inline ( always ) ]
            pub fn is_aesop_1(&self) -> bool {
                *self == AesopR::Aesop1
            }
            # [ doc = "Checks if the value of the field is `Aesop2`" ]
            # [ inline ( always ) ]
            pub fn is_aesop_2(&self) -> bool {
                *self == AesopR::Aesop2
            }
            # [ doc = "Checks if the value of the field is `Aesop3`" ]
            # [ inline ( always ) ]
            pub fn is_aesop_3(&self) -> bool {
                *self == AesopR::Aesop3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AesswrstR {
            bits: u8,
        }
        impl AesswrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AesrdyifgR {
            bits: u8,
        }
        impl AesrdyifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AeserrfgR {
            bits: u8,
        }
        impl AeserrfgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AesrdyieR {
            bits: u8,
        }
        impl AesrdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `AESOP`" ]
        pub enum AesopW {
            # [ doc = "AES Operation: Encrypt" ]
            Aesop0,
            # [ doc = "AES Operation: Decrypt (same Key)" ]
            Aesop1,
            # [ doc = "AES Operation: Generate first round Key" ]
            Aesop2,
            # [ doc = "AES Operation: Decrypt (first round Key)" ]
            Aesop3,
        }
        impl AesopW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AesopW::Aesop0 => 0,
                    AesopW::Aesop1 => 1,
                    AesopW::Aesop2 => 2,
                    AesopW::Aesop3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesopW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: AesopW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "AES Operation: Encrypt" ]
            # [ inline ( always ) ]
            pub fn aesop_0(self) -> &'a mut W {
                self.variant(AesopW::Aesop0)
            }
            # [ doc = "AES Operation: Decrypt (same Key)" ]
            # [ inline ( always ) ]
            pub fn aesop_1(self) -> &'a mut W {
                self.variant(AesopW::Aesop1)
            }
            # [ doc = "AES Operation: Generate first round Key" ]
            # [ inline ( always ) ]
            pub fn aesop_2(self) -> &'a mut W {
                self.variant(AesopW::Aesop2)
            }
            # [ doc = "AES Operation: Decrypt (first round Key)" ]
            # [ inline ( always ) ]
            pub fn aesop_3(self) -> &'a mut W {
                self.variant(AesopW::Aesop3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesswrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesswrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesrdyifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesrdyifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AeserrfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AeserrfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesrdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesrdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 1:2 - AES Operation Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aesop(&self) -> AesopR {
                AesopR::_from({
                                  const MASK: u8 = 3;
                                  const OFFSET: u8 = 1;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
            # [ doc = "Bit 7 - AES Software Reset" ]
            # [ inline ( always ) ]
            pub fn aesswrst(&self) -> AesswrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AesswrstR { bits }
            }
            # [ doc = "Bit 8 - AES ready interrupt flag" ]
            # [ inline ( always ) ]
            pub fn aesrdyifg(&self) -> AesrdyifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AesrdyifgR { bits }
            }
            # [ doc = "Bit 11 - AES Error Flag" ]
            # [ inline ( always ) ]
            pub fn aeserrfg(&self) -> AeserrfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AeserrfgR { bits }
            }
            # [ doc = "Bit 12 - AES ready interrupt enable" ]
            # [ inline ( always ) ]
            pub fn aesrdyie(&self) -> AesrdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AesrdyieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 1:2 - AES Operation Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aesop(&mut self) -> _AesopW {
                _AesopW { w: self }
            }
            # [ doc = "Bit 7 - AES Software Reset" ]
            # [ inline ( always ) ]
            pub fn aesswrst(&mut self) -> _AesswrstW {
                _AesswrstW { w: self }
            }
            # [ doc = "Bit 8 - AES ready interrupt flag" ]
            # [ inline ( always ) ]
            pub fn aesrdyifg(&mut self) -> _AesrdyifgW {
                _AesrdyifgW { w: self }
            }
            # [ doc = "Bit 11 - AES Error Flag" ]
            # [ inline ( always ) ]
            pub fn aeserrfg(&mut self) -> _AeserrfgW {
                _AeserrfgW { w: self }
            }
            # [ doc = "Bit 12 - AES ready interrupt enable" ]
            # [ inline ( always ) ]
            pub fn aesrdyie(&mut self) -> _AesrdyieW {
                _AesrdyieW { w: self }
            }
        }
    }
    # [ doc = "AES accelerator status register" ]
    pub struct Aesastat {
        register: VolatileCell<u16>,
    }
    # [ doc = "AES accelerator status register" ]
    pub mod aesastat {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Aesastat {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AesbusyR {
            bits: u8,
        }
        impl AesbusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AeskeywrR {
            bits: u8,
        }
        impl AeskeywrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AesdinwrR {
            bits: u8,
        }
        impl AesdinwrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AesdoutrdR {
            bits: u8,
        }
        impl AesdoutrdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aeskeycnt0R {
            bits: u8,
        }
        impl Aeskeycnt0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aeskeycnt1R {
            bits: u8,
        }
        impl Aeskeycnt1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aeskeycnt2R {
            bits: u8,
        }
        impl Aeskeycnt2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aeskeycnt3R {
            bits: u8,
        }
        impl Aeskeycnt3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdincnt0R {
            bits: u8,
        }
        impl Aesdincnt0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdincnt1R {
            bits: u8,
        }
        impl Aesdincnt1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdincnt2R {
            bits: u8,
        }
        impl Aesdincnt2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdincnt3R {
            bits: u8,
        }
        impl Aesdincnt3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdoutcnt0R {
            bits: u8,
        }
        impl Aesdoutcnt0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdoutcnt1R {
            bits: u8,
        }
        impl Aesdoutcnt1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdoutcnt2R {
            bits: u8,
        }
        impl Aesdoutcnt2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Aesdoutcnt3R {
            bits: u8,
        }
        impl Aesdoutcnt3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesbusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesbusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AeskeywrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AeskeywrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesdinwrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesdinwrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AesdoutrdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AesdoutrdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aeskeycnt0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aeskeycnt0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aeskeycnt1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aeskeycnt1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aeskeycnt2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aeskeycnt2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aeskeycnt3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aeskeycnt3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdincnt0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdincnt0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdincnt1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdincnt1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdincnt2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdincnt2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdincnt3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdincnt3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdoutcnt0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdoutcnt0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdoutcnt1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdoutcnt1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdoutcnt2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdoutcnt2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Aesdoutcnt3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Aesdoutcnt3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - AES Busy" ]
            # [ inline ( always ) ]
            pub fn aesbusy(&self) -> AesbusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AesbusyR { bits }
            }
            # [ doc = "Bit 1 - AES All 16 bytes written to AESAKEY" ]
            # [ inline ( always ) ]
            pub fn aeskeywr(&self) -> AeskeywrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AeskeywrR { bits }
            }
            # [ doc = "Bit 2 - AES All 16 bytes written to AESADIN" ]
            # [ inline ( always ) ]
            pub fn aesdinwr(&self) -> AesdinwrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AesdinwrR { bits }
            }
            # [ doc = "Bit 3 - AES All 16 bytes read from AESADOUT" ]
            # [ inline ( always ) ]
            pub fn aesdoutrd(&self) -> AesdoutrdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AesdoutrdR { bits }
            }
            # [ doc = "Bit 4 - AES Bytes written via AESAKEY Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt0(&self) -> Aeskeycnt0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aeskeycnt0R { bits }
            }
            # [ doc = "Bit 5 - AES Bytes written via AESAKEY Bit: 1" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt1(&self) -> Aeskeycnt1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aeskeycnt1R { bits }
            }
            # [ doc = "Bit 6 - AES Bytes written via AESAKEY Bit: 2" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt2(&self) -> Aeskeycnt2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aeskeycnt2R { bits }
            }
            # [ doc = "Bit 7 - AES Bytes written via AESAKEY Bit: 3" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt3(&self) -> Aeskeycnt3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aeskeycnt3R { bits }
            }
            # [ doc = "Bit 8 - AES Bytes written via AESADIN Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aesdincnt0(&self) -> Aesdincnt0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdincnt0R { bits }
            }
            # [ doc = "Bit 9 - AES Bytes written via AESADIN Bit: 1" ]
            # [ inline ( always ) ]
            pub fn aesdincnt1(&self) -> Aesdincnt1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdincnt1R { bits }
            }
            # [ doc = "Bit 10 - AES Bytes written via AESADIN Bit: 2" ]
            # [ inline ( always ) ]
            pub fn aesdincnt2(&self) -> Aesdincnt2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdincnt2R { bits }
            }
            # [ doc = "Bit 11 - AES Bytes written via AESADIN Bit: 3" ]
            # [ inline ( always ) ]
            pub fn aesdincnt3(&self) -> Aesdincnt3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdincnt3R { bits }
            }
            # [ doc = "Bit 12 - AES Bytes read via AESADOUT Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt0(&self) -> Aesdoutcnt0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdoutcnt0R { bits }
            }
            # [ doc = "Bit 13 - AES Bytes read via AESADOUT Bit: 1" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt1(&self) -> Aesdoutcnt1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdoutcnt1R { bits }
            }
            # [ doc = "Bit 14 - AES Bytes read via AESADOUT Bit: 2" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt2(&self) -> Aesdoutcnt2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdoutcnt2R { bits }
            }
            # [ doc = "Bit 15 - AES Bytes read via AESADOUT Bit: 3" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt3(&self) -> Aesdoutcnt3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Aesdoutcnt3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - AES Busy" ]
            # [ inline ( always ) ]
            pub fn aesbusy(&mut self) -> _AesbusyW {
                _AesbusyW { w: self }
            }
            # [ doc = "Bit 1 - AES All 16 bytes written to AESAKEY" ]
            # [ inline ( always ) ]
            pub fn aeskeywr(&mut self) -> _AeskeywrW {
                _AeskeywrW { w: self }
            }
            # [ doc = "Bit 2 - AES All 16 bytes written to AESADIN" ]
            # [ inline ( always ) ]
            pub fn aesdinwr(&mut self) -> _AesdinwrW {
                _AesdinwrW { w: self }
            }
            # [ doc = "Bit 3 - AES All 16 bytes read from AESADOUT" ]
            # [ inline ( always ) ]
            pub fn aesdoutrd(&mut self) -> _AesdoutrdW {
                _AesdoutrdW { w: self }
            }
            # [ doc = "Bit 4 - AES Bytes written via AESAKEY Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt0(&mut self) -> _Aeskeycnt0W {
                _Aeskeycnt0W { w: self }
            }
            # [ doc = "Bit 5 - AES Bytes written via AESAKEY Bit: 1" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt1(&mut self) -> _Aeskeycnt1W {
                _Aeskeycnt1W { w: self }
            }
            # [ doc = "Bit 6 - AES Bytes written via AESAKEY Bit: 2" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt2(&mut self) -> _Aeskeycnt2W {
                _Aeskeycnt2W { w: self }
            }
            # [ doc = "Bit 7 - AES Bytes written via AESAKEY Bit: 3" ]
            # [ inline ( always ) ]
            pub fn aeskeycnt3(&mut self) -> _Aeskeycnt3W {
                _Aeskeycnt3W { w: self }
            }
            # [ doc = "Bit 8 - AES Bytes written via AESADIN Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aesdincnt0(&mut self) -> _Aesdincnt0W {
                _Aesdincnt0W { w: self }
            }
            # [ doc = "Bit 9 - AES Bytes written via AESADIN Bit: 1" ]
            # [ inline ( always ) ]
            pub fn aesdincnt1(&mut self) -> _Aesdincnt1W {
                _Aesdincnt1W { w: self }
            }
            # [ doc = "Bit 10 - AES Bytes written via AESADIN Bit: 2" ]
            # [ inline ( always ) ]
            pub fn aesdincnt2(&mut self) -> _Aesdincnt2W {
                _Aesdincnt2W { w: self }
            }
            # [ doc = "Bit 11 - AES Bytes written via AESADIN Bit: 3" ]
            # [ inline ( always ) ]
            pub fn aesdincnt3(&mut self) -> _Aesdincnt3W {
                _Aesdincnt3W { w: self }
            }
            # [ doc = "Bit 12 - AES Bytes read via AESADOUT Bit: 0" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt0(&mut self) -> _Aesdoutcnt0W {
                _Aesdoutcnt0W { w: self }
            }
            # [ doc = "Bit 13 - AES Bytes read via AESADOUT Bit: 1" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt1(&mut self) -> _Aesdoutcnt1W {
                _Aesdoutcnt1W { w: self }
            }
            # [ doc = "Bit 14 - AES Bytes read via AESADOUT Bit: 2" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt2(&mut self) -> _Aesdoutcnt2W {
                _Aesdoutcnt2W { w: self }
            }
            # [ doc = "Bit 15 - AES Bytes read via AESADOUT Bit: 3" ]
            # [ inline ( always ) ]
            pub fn aesdoutcnt3(&mut self) -> _Aesdoutcnt3W {
                _Aesdoutcnt3W { w: self }
            }
        }
    }
    # [ doc = "AES accelerator key register" ]
    pub struct Aesakey {
        register: VolatileCell<u16>,
    }
    # [ doc = "AES accelerator key register" ]
    pub mod aesakey {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Aesakey {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "AES accelerator data in register" ]
    pub struct Aesadin {
        register: VolatileCell<u16>,
    }
    # [ doc = "AES accelerator data in register" ]
    pub mod aesadin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Aesadin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "AES accelerator data out register" ]
    pub struct Aesadout {
        register: VolatileCell<u16>,
    }
    # [ doc = "AES accelerator data out register" ]
    pub mod aesadout {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Aesadout {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "AES Accelerator" ]
pub struct AesAccelerator {
    register_block: aes_accelerator::RegisterBlock,
}
impl Deref for AesAccelerator {
    type Target = aes_accelerator::RegisterBlock;
    fn deref(&self) -> &aes_accelerator::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Comparator B" ]
pub const COMPARATOR_B: Peripheral<ComparatorB> = unsafe { Peripheral::new(0) };
# [ doc = "Comparator B" ]
pub mod comparator_b {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 2240usize],
        # [ doc = "0x8c0 - Comparator B Control Register 0" ]
        pub cbctl0: Cbctl0,
        # [ doc = "0x8c2 - Comparator B Control Register 1" ]
        pub cbctl1: Cbctl1,
        # [ doc = "0x8c4 - Comparator B Control Register 2" ]
        pub cbctl2: Cbctl2,
        # [ doc = "0x8c6 - Comparator B Control Register 3" ]
        pub cbctl3: Cbctl3,
        _reserved1: [u8; 4usize],
        # [ doc = "0x8cc - Comparator B Interrupt Register" ]
        pub cbint: Cbint,
        # [ doc = "0x8ce - Comparator B Interrupt Vector Word" ]
        pub cbiv: Cbiv,
    }
    # [ doc = "Comparator B Control Register 0" ]
    pub struct Cbctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Comparator B Control Register 0" ]
    pub mod cbctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Cbctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CBIPSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CbipselR {
            # [ doc = "Comp. B V+ terminal Input Select: Channel 0" ]
            Cbipsel0,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 1" ]
            Cbipsel1,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 2" ]
            Cbipsel2,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 3" ]
            Cbipsel3,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 4" ]
            Cbipsel4,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 5" ]
            Cbipsel5,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 6" ]
            Cbipsel6,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 7" ]
            Cbipsel7,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 8" ]
            Cbipsel8,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 9" ]
            Cbipsel9,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 10" ]
            Cbipsel10,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 11" ]
            Cbipsel11,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 12" ]
            Cbipsel12,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 13" ]
            Cbipsel13,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 14" ]
            Cbipsel14,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 15" ]
            Cbipsel15,
        }
        impl CbipselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CbipselR::Cbipsel0 => 0,
                    CbipselR::Cbipsel1 => 1,
                    CbipselR::Cbipsel2 => 2,
                    CbipselR::Cbipsel3 => 3,
                    CbipselR::Cbipsel4 => 4,
                    CbipselR::Cbipsel5 => 5,
                    CbipselR::Cbipsel6 => 6,
                    CbipselR::Cbipsel7 => 7,
                    CbipselR::Cbipsel8 => 8,
                    CbipselR::Cbipsel9 => 9,
                    CbipselR::Cbipsel10 => 10,
                    CbipselR::Cbipsel11 => 11,
                    CbipselR::Cbipsel12 => 12,
                    CbipselR::Cbipsel13 => 13,
                    CbipselR::Cbipsel14 => 14,
                    CbipselR::Cbipsel15 => 15,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CbipselR {
                match bits {
                    0 => CbipselR::Cbipsel0,
                    1 => CbipselR::Cbipsel1,
                    2 => CbipselR::Cbipsel2,
                    3 => CbipselR::Cbipsel3,
                    4 => CbipselR::Cbipsel4,
                    5 => CbipselR::Cbipsel5,
                    6 => CbipselR::Cbipsel6,
                    7 => CbipselR::Cbipsel7,
                    8 => CbipselR::Cbipsel8,
                    9 => CbipselR::Cbipsel9,
                    10 => CbipselR::Cbipsel10,
                    11 => CbipselR::Cbipsel11,
                    12 => CbipselR::Cbipsel12,
                    13 => CbipselR::Cbipsel13,
                    14 => CbipselR::Cbipsel14,
                    15 => CbipselR::Cbipsel15,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbipsel0`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_0(&self) -> bool {
                *self == CbipselR::Cbipsel0
            }
            # [ doc = "Checks if the value of the field is `Cbipsel1`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_1(&self) -> bool {
                *self == CbipselR::Cbipsel1
            }
            # [ doc = "Checks if the value of the field is `Cbipsel2`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_2(&self) -> bool {
                *self == CbipselR::Cbipsel2
            }
            # [ doc = "Checks if the value of the field is `Cbipsel3`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_3(&self) -> bool {
                *self == CbipselR::Cbipsel3
            }
            # [ doc = "Checks if the value of the field is `Cbipsel4`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_4(&self) -> bool {
                *self == CbipselR::Cbipsel4
            }
            # [ doc = "Checks if the value of the field is `Cbipsel5`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_5(&self) -> bool {
                *self == CbipselR::Cbipsel5
            }
            # [ doc = "Checks if the value of the field is `Cbipsel6`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_6(&self) -> bool {
                *self == CbipselR::Cbipsel6
            }
            # [ doc = "Checks if the value of the field is `Cbipsel7`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_7(&self) -> bool {
                *self == CbipselR::Cbipsel7
            }
            # [ doc = "Checks if the value of the field is `Cbipsel8`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_8(&self) -> bool {
                *self == CbipselR::Cbipsel8
            }
            # [ doc = "Checks if the value of the field is `Cbipsel9`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_9(&self) -> bool {
                *self == CbipselR::Cbipsel9
            }
            # [ doc = "Checks if the value of the field is `Cbipsel10`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_10(&self) -> bool {
                *self == CbipselR::Cbipsel10
            }
            # [ doc = "Checks if the value of the field is `Cbipsel11`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_11(&self) -> bool {
                *self == CbipselR::Cbipsel11
            }
            # [ doc = "Checks if the value of the field is `Cbipsel12`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_12(&self) -> bool {
                *self == CbipselR::Cbipsel12
            }
            # [ doc = "Checks if the value of the field is `Cbipsel13`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_13(&self) -> bool {
                *self == CbipselR::Cbipsel13
            }
            # [ doc = "Checks if the value of the field is `Cbipsel14`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_14(&self) -> bool {
                *self == CbipselR::Cbipsel14
            }
            # [ doc = "Checks if the value of the field is `Cbipsel15`" ]
            # [ inline ( always ) ]
            pub fn is_cbipsel_15(&self) -> bool {
                *self == CbipselR::Cbipsel15
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbipenR {
            bits: u8,
        }
        impl CbipenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CBIMSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CbimselR {
            # [ doc = "Comp. B V- Terminal Input Select: Channel 0" ]
            Cbimsel0,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 1" ]
            Cbimsel1,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 2" ]
            Cbimsel2,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 3" ]
            Cbimsel3,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 4" ]
            Cbimsel4,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 5" ]
            Cbimsel5,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 6" ]
            Cbimsel6,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 7" ]
            Cbimsel7,
            # [ doc = "Comp. B V- terminal Input Select: Channel 8" ]
            Cbimsel8,
            # [ doc = "Comp. B V- terminal Input Select: Channel 9" ]
            Cbimsel9,
            # [ doc = "Comp. B V- terminal Input Select: Channel 10" ]
            Cbimsel10,
            # [ doc = "Comp. B V- terminal Input Select: Channel 11" ]
            Cbimsel11,
            # [ doc = "Comp. B V- terminal Input Select: Channel 12" ]
            Cbimsel12,
            # [ doc = "Comp. B V- terminal Input Select: Channel 13" ]
            Cbimsel13,
            # [ doc = "Comp. B V- terminal Input Select: Channel 14" ]
            Cbimsel14,
            # [ doc = "Comp. B V- terminal Input Select: Channel 15" ]
            Cbimsel15,
        }
        impl CbimselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CbimselR::Cbimsel0 => 0,
                    CbimselR::Cbimsel1 => 1,
                    CbimselR::Cbimsel2 => 2,
                    CbimselR::Cbimsel3 => 3,
                    CbimselR::Cbimsel4 => 4,
                    CbimselR::Cbimsel5 => 5,
                    CbimselR::Cbimsel6 => 6,
                    CbimselR::Cbimsel7 => 7,
                    CbimselR::Cbimsel8 => 8,
                    CbimselR::Cbimsel9 => 9,
                    CbimselR::Cbimsel10 => 10,
                    CbimselR::Cbimsel11 => 11,
                    CbimselR::Cbimsel12 => 12,
                    CbimselR::Cbimsel13 => 13,
                    CbimselR::Cbimsel14 => 14,
                    CbimselR::Cbimsel15 => 15,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CbimselR {
                match bits {
                    0 => CbimselR::Cbimsel0,
                    1 => CbimselR::Cbimsel1,
                    2 => CbimselR::Cbimsel2,
                    3 => CbimselR::Cbimsel3,
                    4 => CbimselR::Cbimsel4,
                    5 => CbimselR::Cbimsel5,
                    6 => CbimselR::Cbimsel6,
                    7 => CbimselR::Cbimsel7,
                    8 => CbimselR::Cbimsel8,
                    9 => CbimselR::Cbimsel9,
                    10 => CbimselR::Cbimsel10,
                    11 => CbimselR::Cbimsel11,
                    12 => CbimselR::Cbimsel12,
                    13 => CbimselR::Cbimsel13,
                    14 => CbimselR::Cbimsel14,
                    15 => CbimselR::Cbimsel15,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbimsel0`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_0(&self) -> bool {
                *self == CbimselR::Cbimsel0
            }
            # [ doc = "Checks if the value of the field is `Cbimsel1`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_1(&self) -> bool {
                *self == CbimselR::Cbimsel1
            }
            # [ doc = "Checks if the value of the field is `Cbimsel2`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_2(&self) -> bool {
                *self == CbimselR::Cbimsel2
            }
            # [ doc = "Checks if the value of the field is `Cbimsel3`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_3(&self) -> bool {
                *self == CbimselR::Cbimsel3
            }
            # [ doc = "Checks if the value of the field is `Cbimsel4`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_4(&self) -> bool {
                *self == CbimselR::Cbimsel4
            }
            # [ doc = "Checks if the value of the field is `Cbimsel5`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_5(&self) -> bool {
                *self == CbimselR::Cbimsel5
            }
            # [ doc = "Checks if the value of the field is `Cbimsel6`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_6(&self) -> bool {
                *self == CbimselR::Cbimsel6
            }
            # [ doc = "Checks if the value of the field is `Cbimsel7`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_7(&self) -> bool {
                *self == CbimselR::Cbimsel7
            }
            # [ doc = "Checks if the value of the field is `Cbimsel8`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_8(&self) -> bool {
                *self == CbimselR::Cbimsel8
            }
            # [ doc = "Checks if the value of the field is `Cbimsel9`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_9(&self) -> bool {
                *self == CbimselR::Cbimsel9
            }
            # [ doc = "Checks if the value of the field is `Cbimsel10`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_10(&self) -> bool {
                *self == CbimselR::Cbimsel10
            }
            # [ doc = "Checks if the value of the field is `Cbimsel11`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_11(&self) -> bool {
                *self == CbimselR::Cbimsel11
            }
            # [ doc = "Checks if the value of the field is `Cbimsel12`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_12(&self) -> bool {
                *self == CbimselR::Cbimsel12
            }
            # [ doc = "Checks if the value of the field is `Cbimsel13`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_13(&self) -> bool {
                *self == CbimselR::Cbimsel13
            }
            # [ doc = "Checks if the value of the field is `Cbimsel14`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_14(&self) -> bool {
                *self == CbimselR::Cbimsel14
            }
            # [ doc = "Checks if the value of the field is `Cbimsel15`" ]
            # [ inline ( always ) ]
            pub fn is_cbimsel_15(&self) -> bool {
                *self == CbimselR::Cbimsel15
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbimenR {
            bits: u8,
        }
        impl CbimenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `CBIPSEL`" ]
        pub enum CbipselW {
            # [ doc = "Comp. B V+ terminal Input Select: Channel 0" ]
            Cbipsel0,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 1" ]
            Cbipsel1,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 2" ]
            Cbipsel2,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 3" ]
            Cbipsel3,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 4" ]
            Cbipsel4,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 5" ]
            Cbipsel5,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 6" ]
            Cbipsel6,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 7" ]
            Cbipsel7,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 8" ]
            Cbipsel8,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 9" ]
            Cbipsel9,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 10" ]
            Cbipsel10,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 11" ]
            Cbipsel11,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 12" ]
            Cbipsel12,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 13" ]
            Cbipsel13,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 14" ]
            Cbipsel14,
            # [ doc = "Comp. B V+ terminal Input Select: Channel 15" ]
            Cbipsel15,
        }
        impl CbipselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CbipselW::Cbipsel0 => 0,
                    CbipselW::Cbipsel1 => 1,
                    CbipselW::Cbipsel2 => 2,
                    CbipselW::Cbipsel3 => 3,
                    CbipselW::Cbipsel4 => 4,
                    CbipselW::Cbipsel5 => 5,
                    CbipselW::Cbipsel6 => 6,
                    CbipselW::Cbipsel7 => 7,
                    CbipselW::Cbipsel8 => 8,
                    CbipselW::Cbipsel9 => 9,
                    CbipselW::Cbipsel10 => 10,
                    CbipselW::Cbipsel11 => 11,
                    CbipselW::Cbipsel12 => 12,
                    CbipselW::Cbipsel13 => 13,
                    CbipselW::Cbipsel14 => 14,
                    CbipselW::Cbipsel15 => 15,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbipselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbipselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CbipselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 0" ]
            # [ inline ( always ) ]
            pub fn cbipsel_0(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel0)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 1" ]
            # [ inline ( always ) ]
            pub fn cbipsel_1(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel1)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 2" ]
            # [ inline ( always ) ]
            pub fn cbipsel_2(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel2)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 3" ]
            # [ inline ( always ) ]
            pub fn cbipsel_3(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel3)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 4" ]
            # [ inline ( always ) ]
            pub fn cbipsel_4(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel4)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 5" ]
            # [ inline ( always ) ]
            pub fn cbipsel_5(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel5)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 6" ]
            # [ inline ( always ) ]
            pub fn cbipsel_6(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel6)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 7" ]
            # [ inline ( always ) ]
            pub fn cbipsel_7(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel7)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 8" ]
            # [ inline ( always ) ]
            pub fn cbipsel_8(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel8)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 9" ]
            # [ inline ( always ) ]
            pub fn cbipsel_9(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel9)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 10" ]
            # [ inline ( always ) ]
            pub fn cbipsel_10(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel10)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 11" ]
            # [ inline ( always ) ]
            pub fn cbipsel_11(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel11)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 12" ]
            # [ inline ( always ) ]
            pub fn cbipsel_12(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel12)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 13" ]
            # [ inline ( always ) ]
            pub fn cbipsel_13(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel13)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 14" ]
            # [ inline ( always ) ]
            pub fn cbipsel_14(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel14)
            }
            # [ doc = "Comp. B V+ terminal Input Select: Channel 15" ]
            # [ inline ( always ) ]
            pub fn cbipsel_15(self) -> &'a mut W {
                self.variant(CbipselW::Cbipsel15)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbipenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbipenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CBIMSEL`" ]
        pub enum CbimselW {
            # [ doc = "Comp. B V- Terminal Input Select: Channel 0" ]
            Cbimsel0,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 1" ]
            Cbimsel1,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 2" ]
            Cbimsel2,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 3" ]
            Cbimsel3,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 4" ]
            Cbimsel4,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 5" ]
            Cbimsel5,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 6" ]
            Cbimsel6,
            # [ doc = "Comp. B V- Terminal Input Select: Channel 7" ]
            Cbimsel7,
            # [ doc = "Comp. B V- terminal Input Select: Channel 8" ]
            Cbimsel8,
            # [ doc = "Comp. B V- terminal Input Select: Channel 9" ]
            Cbimsel9,
            # [ doc = "Comp. B V- terminal Input Select: Channel 10" ]
            Cbimsel10,
            # [ doc = "Comp. B V- terminal Input Select: Channel 11" ]
            Cbimsel11,
            # [ doc = "Comp. B V- terminal Input Select: Channel 12" ]
            Cbimsel12,
            # [ doc = "Comp. B V- terminal Input Select: Channel 13" ]
            Cbimsel13,
            # [ doc = "Comp. B V- terminal Input Select: Channel 14" ]
            Cbimsel14,
            # [ doc = "Comp. B V- terminal Input Select: Channel 15" ]
            Cbimsel15,
        }
        impl CbimselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CbimselW::Cbimsel0 => 0,
                    CbimselW::Cbimsel1 => 1,
                    CbimselW::Cbimsel2 => 2,
                    CbimselW::Cbimsel3 => 3,
                    CbimselW::Cbimsel4 => 4,
                    CbimselW::Cbimsel5 => 5,
                    CbimselW::Cbimsel6 => 6,
                    CbimselW::Cbimsel7 => 7,
                    CbimselW::Cbimsel8 => 8,
                    CbimselW::Cbimsel9 => 9,
                    CbimselW::Cbimsel10 => 10,
                    CbimselW::Cbimsel11 => 11,
                    CbimselW::Cbimsel12 => 12,
                    CbimselW::Cbimsel13 => 13,
                    CbimselW::Cbimsel14 => 14,
                    CbimselW::Cbimsel15 => 15,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbimselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbimselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CbimselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 0" ]
            # [ inline ( always ) ]
            pub fn cbimsel_0(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel0)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 1" ]
            # [ inline ( always ) ]
            pub fn cbimsel_1(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel1)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 2" ]
            # [ inline ( always ) ]
            pub fn cbimsel_2(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel2)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 3" ]
            # [ inline ( always ) ]
            pub fn cbimsel_3(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel3)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 4" ]
            # [ inline ( always ) ]
            pub fn cbimsel_4(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel4)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 5" ]
            # [ inline ( always ) ]
            pub fn cbimsel_5(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel5)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 6" ]
            # [ inline ( always ) ]
            pub fn cbimsel_6(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel6)
            }
            # [ doc = "Comp. B V- Terminal Input Select: Channel 7" ]
            # [ inline ( always ) ]
            pub fn cbimsel_7(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel7)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 8" ]
            # [ inline ( always ) ]
            pub fn cbimsel_8(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel8)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 9" ]
            # [ inline ( always ) ]
            pub fn cbimsel_9(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel9)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 10" ]
            # [ inline ( always ) ]
            pub fn cbimsel_10(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel10)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 11" ]
            # [ inline ( always ) ]
            pub fn cbimsel_11(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel11)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 12" ]
            # [ inline ( always ) ]
            pub fn cbimsel_12(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel12)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 13" ]
            # [ inline ( always ) ]
            pub fn cbimsel_13(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel13)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 14" ]
            # [ inline ( always ) ]
            pub fn cbimsel_14(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel14)
            }
            # [ doc = "Comp. B V- terminal Input Select: Channel 15" ]
            # [ inline ( always ) ]
            pub fn cbimsel_15(self) -> &'a mut W {
                self.variant(CbimselW::Cbimsel15)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbimenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbimenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 3:6 - Comp. B Pos. Channel Input Select 0" ]
            # [ inline ( always ) ]
            pub fn cbipsel(&self) -> CbipselR {
                CbipselR::_from({
                                    const MASK: u8 = 15;
                                    const OFFSET: u8 = 3;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 7 - Comp. B Pos. Channel Input Enable" ]
            # [ inline ( always ) ]
            pub fn cbipen(&self) -> CbipenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbipenR { bits }
            }
            # [ doc = "Bits 11:14 - Comp. B Neg. Channel Input Select 0" ]
            # [ inline ( always ) ]
            pub fn cbimsel(&self) -> CbimselR {
                CbimselR::_from({
                                    const MASK: u8 = 15;
                                    const OFFSET: u8 = 11;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 15 - Comp. B Neg. Channel Input Enable" ]
            # [ inline ( always ) ]
            pub fn cbimen(&self) -> CbimenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbimenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 3:6 - Comp. B Pos. Channel Input Select 0" ]
            # [ inline ( always ) ]
            pub fn cbipsel(&mut self) -> _CbipselW {
                _CbipselW { w: self }
            }
            # [ doc = "Bit 7 - Comp. B Pos. Channel Input Enable" ]
            # [ inline ( always ) ]
            pub fn cbipen(&mut self) -> _CbipenW {
                _CbipenW { w: self }
            }
            # [ doc = "Bits 11:14 - Comp. B Neg. Channel Input Select 0" ]
            # [ inline ( always ) ]
            pub fn cbimsel(&mut self) -> _CbimselW {
                _CbimselW { w: self }
            }
            # [ doc = "Bit 15 - Comp. B Neg. Channel Input Enable" ]
            # [ inline ( always ) ]
            pub fn cbimen(&mut self) -> _CbimenW {
                _CbimenW { w: self }
            }
        }
    }
    # [ doc = "Comparator B Control Register 1" ]
    pub struct Cbctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Comparator B Control Register 1" ]
    pub mod cbctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Cbctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CboutR {
            bits: u8,
        }
        impl CboutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CboutpolR {
            bits: u8,
        }
        impl CboutpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbfR {
            bits: u8,
        }
        impl CbfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbiesR {
            bits: u8,
        }
        impl CbiesR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbshortR {
            bits: u8,
        }
        impl CbshortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbexR {
            bits: u8,
        }
        impl CbexR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CBFDLY`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CbfdlyR {
            # [ doc = "Comp. B Filter delay 0 : 450ns" ]
            Cbfdly0,
            # [ doc = "Comp. B Filter delay 1 : 900ns" ]
            Cbfdly1,
            # [ doc = "Comp. B Filter delay 2 : 1800ns" ]
            Cbfdly2,
            # [ doc = "Comp. B Filter delay 3 : 3600ns" ]
            Cbfdly3,
        }
        impl CbfdlyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CbfdlyR::Cbfdly0 => 0,
                    CbfdlyR::Cbfdly1 => 1,
                    CbfdlyR::Cbfdly2 => 2,
                    CbfdlyR::Cbfdly3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CbfdlyR {
                match bits {
                    0 => CbfdlyR::Cbfdly0,
                    1 => CbfdlyR::Cbfdly1,
                    2 => CbfdlyR::Cbfdly2,
                    3 => CbfdlyR::Cbfdly3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbfdly0`" ]
            # [ inline ( always ) ]
            pub fn is_cbfdly_0(&self) -> bool {
                *self == CbfdlyR::Cbfdly0
            }
            # [ doc = "Checks if the value of the field is `Cbfdly1`" ]
            # [ inline ( always ) ]
            pub fn is_cbfdly_1(&self) -> bool {
                *self == CbfdlyR::Cbfdly1
            }
            # [ doc = "Checks if the value of the field is `Cbfdly2`" ]
            # [ inline ( always ) ]
            pub fn is_cbfdly_2(&self) -> bool {
                *self == CbfdlyR::Cbfdly2
            }
            # [ doc = "Checks if the value of the field is `Cbfdly3`" ]
            # [ inline ( always ) ]
            pub fn is_cbfdly_3(&self) -> bool {
                *self == CbfdlyR::Cbfdly3
            }
        }
        # [ doc = "Possible values of the field `CBPWRMD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CbpwrmdR {
            # [ doc = "Comp. B Power Mode 0 : High speed" ]
            Cbpwrmd0,
            # [ doc = "Comp. B Power Mode 1 : Normal" ]
            Cbpwrmd1,
            # [ doc = "Comp. B Power Mode 2 : Ultra-Low" ]
            Cbpwrmd2,
            # [ doc = "Comp. B Power Mode 3 : Reserved" ]
            Cbpwrmd3,
        }
        impl CbpwrmdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CbpwrmdR::Cbpwrmd0 => 0,
                    CbpwrmdR::Cbpwrmd1 => 1,
                    CbpwrmdR::Cbpwrmd2 => 2,
                    CbpwrmdR::Cbpwrmd3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CbpwrmdR {
                match bits {
                    0 => CbpwrmdR::Cbpwrmd0,
                    1 => CbpwrmdR::Cbpwrmd1,
                    2 => CbpwrmdR::Cbpwrmd2,
                    3 => CbpwrmdR::Cbpwrmd3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbpwrmd0`" ]
            # [ inline ( always ) ]
            pub fn is_cbpwrmd_0(&self) -> bool {
                *self == CbpwrmdR::Cbpwrmd0
            }
            # [ doc = "Checks if the value of the field is `Cbpwrmd1`" ]
            # [ inline ( always ) ]
            pub fn is_cbpwrmd_1(&self) -> bool {
                *self == CbpwrmdR::Cbpwrmd1
            }
            # [ doc = "Checks if the value of the field is `Cbpwrmd2`" ]
            # [ inline ( always ) ]
            pub fn is_cbpwrmd_2(&self) -> bool {
                *self == CbpwrmdR::Cbpwrmd2
            }
            # [ doc = "Checks if the value of the field is `Cbpwrmd3`" ]
            # [ inline ( always ) ]
            pub fn is_cbpwrmd_3(&self) -> bool {
                *self == CbpwrmdR::Cbpwrmd3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbonR {
            bits: u8,
        }
        impl CbonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbmrvlR {
            bits: u8,
        }
        impl CbmrvlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbmrvsR {
            bits: u8,
        }
        impl CbmrvsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CboutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CboutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CboutpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CboutpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbfW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbiesW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbiesW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbshortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbshortW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbexW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbexW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CBFDLY`" ]
        pub enum CbfdlyW {
            # [ doc = "Comp. B Filter delay 0 : 450ns" ]
            Cbfdly0,
            # [ doc = "Comp. B Filter delay 1 : 900ns" ]
            Cbfdly1,
            # [ doc = "Comp. B Filter delay 2 : 1800ns" ]
            Cbfdly2,
            # [ doc = "Comp. B Filter delay 3 : 3600ns" ]
            Cbfdly3,
        }
        impl CbfdlyW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CbfdlyW::Cbfdly0 => 0,
                    CbfdlyW::Cbfdly1 => 1,
                    CbfdlyW::Cbfdly2 => 2,
                    CbfdlyW::Cbfdly3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbfdlyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbfdlyW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CbfdlyW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B Filter delay 0 : 450ns" ]
            # [ inline ( always ) ]
            pub fn cbfdly_0(self) -> &'a mut W {
                self.variant(CbfdlyW::Cbfdly0)
            }
            # [ doc = "Comp. B Filter delay 1 : 900ns" ]
            # [ inline ( always ) ]
            pub fn cbfdly_1(self) -> &'a mut W {
                self.variant(CbfdlyW::Cbfdly1)
            }
            # [ doc = "Comp. B Filter delay 2 : 1800ns" ]
            # [ inline ( always ) ]
            pub fn cbfdly_2(self) -> &'a mut W {
                self.variant(CbfdlyW::Cbfdly2)
            }
            # [ doc = "Comp. B Filter delay 3 : 3600ns" ]
            # [ inline ( always ) ]
            pub fn cbfdly_3(self) -> &'a mut W {
                self.variant(CbfdlyW::Cbfdly3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CBPWRMD`" ]
        pub enum CbpwrmdW {
            # [ doc = "Comp. B Power Mode 0 : High speed" ]
            Cbpwrmd0,
            # [ doc = "Comp. B Power Mode 1 : Normal" ]
            Cbpwrmd1,
            # [ doc = "Comp. B Power Mode 2 : Ultra-Low" ]
            Cbpwrmd2,
            # [ doc = "Comp. B Power Mode 3 : Reserved" ]
            Cbpwrmd3,
        }
        impl CbpwrmdW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CbpwrmdW::Cbpwrmd0 => 0,
                    CbpwrmdW::Cbpwrmd1 => 1,
                    CbpwrmdW::Cbpwrmd2 => 2,
                    CbpwrmdW::Cbpwrmd3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbpwrmdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbpwrmdW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CbpwrmdW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B Power Mode 0 : High speed" ]
            # [ inline ( always ) ]
            pub fn cbpwrmd_0(self) -> &'a mut W {
                self.variant(CbpwrmdW::Cbpwrmd0)
            }
            # [ doc = "Comp. B Power Mode 1 : Normal" ]
            # [ inline ( always ) ]
            pub fn cbpwrmd_1(self) -> &'a mut W {
                self.variant(CbpwrmdW::Cbpwrmd1)
            }
            # [ doc = "Comp. B Power Mode 2 : Ultra-Low" ]
            # [ inline ( always ) ]
            pub fn cbpwrmd_2(self) -> &'a mut W {
                self.variant(CbpwrmdW::Cbpwrmd2)
            }
            # [ doc = "Comp. B Power Mode 3 : Reserved" ]
            # [ inline ( always ) ]
            pub fn cbpwrmd_3(self) -> &'a mut W {
                self.variant(CbpwrmdW::Cbpwrmd3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbmrvlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbmrvlW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbmrvsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbmrvsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Comp. B Output" ]
            # [ inline ( always ) ]
            pub fn cbout(&self) -> CboutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CboutR { bits }
            }
            # [ doc = "Bit 1 - Comp. B Output Polarity" ]
            # [ inline ( always ) ]
            pub fn cboutpol(&self) -> CboutpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CboutpolR { bits }
            }
            # [ doc = "Bit 2 - Comp. B Enable Output Filter" ]
            # [ inline ( always ) ]
            pub fn cbf(&self) -> CbfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbfR { bits }
            }
            # [ doc = "Bit 3 - Comp. B Interrupt Edge Select" ]
            # [ inline ( always ) ]
            pub fn cbies(&self) -> CbiesR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbiesR { bits }
            }
            # [ doc = "Bit 4 - Comp. B Input Short" ]
            # [ inline ( always ) ]
            pub fn cbshort(&self) -> CbshortR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbshortR { bits }
            }
            # [ doc = "Bit 5 - Comp. B Exchange Inputs" ]
            # [ inline ( always ) ]
            pub fn cbex(&self) -> CbexR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbexR { bits }
            }
            # [ doc = "Bits 7:8 - Comp. B Filter delay Bit 0" ]
            # [ inline ( always ) ]
            pub fn cbfdly(&self) -> CbfdlyR {
                CbfdlyR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bits 9:10 - Comp. B Power Mode Bit 0" ]
            # [ inline ( always ) ]
            pub fn cbpwrmd(&self) -> CbpwrmdR {
                CbpwrmdR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 9;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 10 - Comp. B enable" ]
            # [ inline ( always ) ]
            pub fn cbon(&self) -> CbonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbonR { bits }
            }
            # [ doc = "Bit 11 - Comp. B CBMRV Level" ]
            # [ inline ( always ) ]
            pub fn cbmrvl(&self) -> CbmrvlR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbmrvlR { bits }
            }
            # [ doc = "Bit 12 - Comp. B Output selects between VREF0 or VREF1" ]
            # [ inline ( always ) ]
            pub fn cbmrvs(&self) -> CbmrvsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbmrvsR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Comp. B Output" ]
            # [ inline ( always ) ]
            pub fn cbout(&mut self) -> _CboutW {
                _CboutW { w: self }
            }
            # [ doc = "Bit 1 - Comp. B Output Polarity" ]
            # [ inline ( always ) ]
            pub fn cboutpol(&mut self) -> _CboutpolW {
                _CboutpolW { w: self }
            }
            # [ doc = "Bit 2 - Comp. B Enable Output Filter" ]
            # [ inline ( always ) ]
            pub fn cbf(&mut self) -> _CbfW {
                _CbfW { w: self }
            }
            # [ doc = "Bit 3 - Comp. B Interrupt Edge Select" ]
            # [ inline ( always ) ]
            pub fn cbies(&mut self) -> _CbiesW {
                _CbiesW { w: self }
            }
            # [ doc = "Bit 4 - Comp. B Input Short" ]
            # [ inline ( always ) ]
            pub fn cbshort(&mut self) -> _CbshortW {
                _CbshortW { w: self }
            }
            # [ doc = "Bit 5 - Comp. B Exchange Inputs" ]
            # [ inline ( always ) ]
            pub fn cbex(&mut self) -> _CbexW {
                _CbexW { w: self }
            }
            # [ doc = "Bits 7:8 - Comp. B Filter delay Bit 0" ]
            # [ inline ( always ) ]
            pub fn cbfdly(&mut self) -> _CbfdlyW {
                _CbfdlyW { w: self }
            }
            # [ doc = "Bits 9:10 - Comp. B Power Mode Bit 0" ]
            # [ inline ( always ) ]
            pub fn cbpwrmd(&mut self) -> _CbpwrmdW {
                _CbpwrmdW { w: self }
            }
            # [ doc = "Bit 10 - Comp. B enable" ]
            # [ inline ( always ) ]
            pub fn cbon(&mut self) -> _CbonW {
                _CbonW { w: self }
            }
            # [ doc = "Bit 11 - Comp. B CBMRV Level" ]
            # [ inline ( always ) ]
            pub fn cbmrvl(&mut self) -> _CbmrvlW {
                _CbmrvlW { w: self }
            }
            # [ doc = "Bit 12 - Comp. B Output selects between VREF0 or VREF1" ]
            # [ inline ( always ) ]
            pub fn cbmrvs(&mut self) -> _CbmrvsW {
                _CbmrvsW { w: self }
            }
        }
    }
    # [ doc = "Comparator B Control Register 2" ]
    pub struct Cbctl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Comparator B Control Register 2" ]
    pub mod cbctl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Cbctl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `CBREF0`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Cbref0R {
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 1/32" ]
            Cbref00,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 2/32" ]
            Cbref01,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 3/32" ]
            Cbref02,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 4/32" ]
            Cbref03,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 5/32" ]
            Cbref04,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 6/32" ]
            Cbref05,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 7/32" ]
            Cbref06,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 8/32" ]
            Cbref07,
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 9/32" ]
            Cbref08,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 10/32" ]
            Cbref09,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 11/32" ]
            Cbref010,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 12/32" ]
            Cbref011,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 13/32" ]
            Cbref012,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 14/32" ]
            Cbref013,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 15/32" ]
            Cbref014,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 16/32" ]
            Cbref015,
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 17/32" ]
            Cbref016,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 18/32" ]
            Cbref017,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 19/32" ]
            Cbref018,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 20/32" ]
            Cbref019,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 21/32" ]
            Cbref020,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 22/32" ]
            Cbref021,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 23/32" ]
            Cbref022,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 24/32" ]
            Cbref023,
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 25/32" ]
            Cbref024,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 26/32" ]
            Cbref025,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 27/32" ]
            Cbref026,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 28/32" ]
            Cbref027,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 29/32" ]
            Cbref028,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 30/32" ]
            Cbref029,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 31/32" ]
            Cbref030,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 32/32" ]
            Cbref031,
        }
        impl Cbref0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Cbref0R::Cbref00 => 0,
                    Cbref0R::Cbref01 => 1,
                    Cbref0R::Cbref02 => 2,
                    Cbref0R::Cbref03 => 3,
                    Cbref0R::Cbref04 => 4,
                    Cbref0R::Cbref05 => 5,
                    Cbref0R::Cbref06 => 6,
                    Cbref0R::Cbref07 => 7,
                    Cbref0R::Cbref08 => 8,
                    Cbref0R::Cbref09 => 9,
                    Cbref0R::Cbref010 => 10,
                    Cbref0R::Cbref011 => 11,
                    Cbref0R::Cbref012 => 12,
                    Cbref0R::Cbref013 => 13,
                    Cbref0R::Cbref014 => 14,
                    Cbref0R::Cbref015 => 15,
                    Cbref0R::Cbref016 => 16,
                    Cbref0R::Cbref017 => 17,
                    Cbref0R::Cbref018 => 18,
                    Cbref0R::Cbref019 => 19,
                    Cbref0R::Cbref020 => 20,
                    Cbref0R::Cbref021 => 21,
                    Cbref0R::Cbref022 => 22,
                    Cbref0R::Cbref023 => 23,
                    Cbref0R::Cbref024 => 24,
                    Cbref0R::Cbref025 => 25,
                    Cbref0R::Cbref026 => 26,
                    Cbref0R::Cbref027 => 27,
                    Cbref0R::Cbref028 => 28,
                    Cbref0R::Cbref029 => 29,
                    Cbref0R::Cbref030 => 30,
                    Cbref0R::Cbref031 => 31,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Cbref0R {
                match bits {
                    0 => Cbref0R::Cbref00,
                    1 => Cbref0R::Cbref01,
                    2 => Cbref0R::Cbref02,
                    3 => Cbref0R::Cbref03,
                    4 => Cbref0R::Cbref04,
                    5 => Cbref0R::Cbref05,
                    6 => Cbref0R::Cbref06,
                    7 => Cbref0R::Cbref07,
                    8 => Cbref0R::Cbref08,
                    9 => Cbref0R::Cbref09,
                    10 => Cbref0R::Cbref010,
                    11 => Cbref0R::Cbref011,
                    12 => Cbref0R::Cbref012,
                    13 => Cbref0R::Cbref013,
                    14 => Cbref0R::Cbref014,
                    15 => Cbref0R::Cbref015,
                    16 => Cbref0R::Cbref016,
                    17 => Cbref0R::Cbref017,
                    18 => Cbref0R::Cbref018,
                    19 => Cbref0R::Cbref019,
                    20 => Cbref0R::Cbref020,
                    21 => Cbref0R::Cbref021,
                    22 => Cbref0R::Cbref022,
                    23 => Cbref0R::Cbref023,
                    24 => Cbref0R::Cbref024,
                    25 => Cbref0R::Cbref025,
                    26 => Cbref0R::Cbref026,
                    27 => Cbref0R::Cbref027,
                    28 => Cbref0R::Cbref028,
                    29 => Cbref0R::Cbref029,
                    30 => Cbref0R::Cbref030,
                    31 => Cbref0R::Cbref031,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbref00`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_0(&self) -> bool {
                *self == Cbref0R::Cbref00
            }
            # [ doc = "Checks if the value of the field is `Cbref01`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_1(&self) -> bool {
                *self == Cbref0R::Cbref01
            }
            # [ doc = "Checks if the value of the field is `Cbref02`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_2(&self) -> bool {
                *self == Cbref0R::Cbref02
            }
            # [ doc = "Checks if the value of the field is `Cbref03`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_3(&self) -> bool {
                *self == Cbref0R::Cbref03
            }
            # [ doc = "Checks if the value of the field is `Cbref04`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_4(&self) -> bool {
                *self == Cbref0R::Cbref04
            }
            # [ doc = "Checks if the value of the field is `Cbref05`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_5(&self) -> bool {
                *self == Cbref0R::Cbref05
            }
            # [ doc = "Checks if the value of the field is `Cbref06`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_6(&self) -> bool {
                *self == Cbref0R::Cbref06
            }
            # [ doc = "Checks if the value of the field is `Cbref07`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_7(&self) -> bool {
                *self == Cbref0R::Cbref07
            }
            # [ doc = "Checks if the value of the field is `Cbref08`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_8(&self) -> bool {
                *self == Cbref0R::Cbref08
            }
            # [ doc = "Checks if the value of the field is `Cbref09`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_9(&self) -> bool {
                *self == Cbref0R::Cbref09
            }
            # [ doc = "Checks if the value of the field is `Cbref010`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_10(&self) -> bool {
                *self == Cbref0R::Cbref010
            }
            # [ doc = "Checks if the value of the field is `Cbref011`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_11(&self) -> bool {
                *self == Cbref0R::Cbref011
            }
            # [ doc = "Checks if the value of the field is `Cbref012`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_12(&self) -> bool {
                *self == Cbref0R::Cbref012
            }
            # [ doc = "Checks if the value of the field is `Cbref013`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_13(&self) -> bool {
                *self == Cbref0R::Cbref013
            }
            # [ doc = "Checks if the value of the field is `Cbref014`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_14(&self) -> bool {
                *self == Cbref0R::Cbref014
            }
            # [ doc = "Checks if the value of the field is `Cbref015`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_15(&self) -> bool {
                *self == Cbref0R::Cbref015
            }
            # [ doc = "Checks if the value of the field is `Cbref016`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_16(&self) -> bool {
                *self == Cbref0R::Cbref016
            }
            # [ doc = "Checks if the value of the field is `Cbref017`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_17(&self) -> bool {
                *self == Cbref0R::Cbref017
            }
            # [ doc = "Checks if the value of the field is `Cbref018`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_18(&self) -> bool {
                *self == Cbref0R::Cbref018
            }
            # [ doc = "Checks if the value of the field is `Cbref019`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_19(&self) -> bool {
                *self == Cbref0R::Cbref019
            }
            # [ doc = "Checks if the value of the field is `Cbref020`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_20(&self) -> bool {
                *self == Cbref0R::Cbref020
            }
            # [ doc = "Checks if the value of the field is `Cbref021`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_21(&self) -> bool {
                *self == Cbref0R::Cbref021
            }
            # [ doc = "Checks if the value of the field is `Cbref022`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_22(&self) -> bool {
                *self == Cbref0R::Cbref022
            }
            # [ doc = "Checks if the value of the field is `Cbref023`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_23(&self) -> bool {
                *self == Cbref0R::Cbref023
            }
            # [ doc = "Checks if the value of the field is `Cbref024`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_24(&self) -> bool {
                *self == Cbref0R::Cbref024
            }
            # [ doc = "Checks if the value of the field is `Cbref025`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_25(&self) -> bool {
                *self == Cbref0R::Cbref025
            }
            # [ doc = "Checks if the value of the field is `Cbref026`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_26(&self) -> bool {
                *self == Cbref0R::Cbref026
            }
            # [ doc = "Checks if the value of the field is `Cbref027`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_27(&self) -> bool {
                *self == Cbref0R::Cbref027
            }
            # [ doc = "Checks if the value of the field is `Cbref028`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_28(&self) -> bool {
                *self == Cbref0R::Cbref028
            }
            # [ doc = "Checks if the value of the field is `Cbref029`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_29(&self) -> bool {
                *self == Cbref0R::Cbref029
            }
            # [ doc = "Checks if the value of the field is `Cbref030`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_30(&self) -> bool {
                *self == Cbref0R::Cbref030
            }
            # [ doc = "Checks if the value of the field is `Cbref031`" ]
            # [ inline ( always ) ]
            pub fn is_cbref0_31(&self) -> bool {
                *self == Cbref0R::Cbref031
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbrselR {
            bits: u8,
        }
        impl CbrselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CBRS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CbrsR {
            # [ doc = "Comp. B Reference Source 0 : Off" ]
            Cbrs0,
            # [ doc = "Comp. B Reference Source 1 : Vcc" ]
            Cbrs1,
            # [ doc = "Comp. B Reference Source 2 : Shared Ref." ]
            Cbrs2,
            # [ doc = "Comp. B Reference Source 3 : Shared Ref. / Off" ]
            Cbrs3,
        }
        impl CbrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CbrsR::Cbrs0 => 0,
                    CbrsR::Cbrs1 => 1,
                    CbrsR::Cbrs2 => 2,
                    CbrsR::Cbrs3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CbrsR {
                match bits {
                    0 => CbrsR::Cbrs0,
                    1 => CbrsR::Cbrs1,
                    2 => CbrsR::Cbrs2,
                    3 => CbrsR::Cbrs3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbrs0`" ]
            # [ inline ( always ) ]
            pub fn is_cbrs_0(&self) -> bool {
                *self == CbrsR::Cbrs0
            }
            # [ doc = "Checks if the value of the field is `Cbrs1`" ]
            # [ inline ( always ) ]
            pub fn is_cbrs_1(&self) -> bool {
                *self == CbrsR::Cbrs1
            }
            # [ doc = "Checks if the value of the field is `Cbrs2`" ]
            # [ inline ( always ) ]
            pub fn is_cbrs_2(&self) -> bool {
                *self == CbrsR::Cbrs2
            }
            # [ doc = "Checks if the value of the field is `Cbrs3`" ]
            # [ inline ( always ) ]
            pub fn is_cbrs_3(&self) -> bool {
                *self == CbrsR::Cbrs3
            }
        }
        # [ doc = "Possible values of the field `CBREF1`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Cbref1R {
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 1/32" ]
            Cbref10,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 2/32" ]
            Cbref11,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 3/32" ]
            Cbref12,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 4/32" ]
            Cbref13,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 5/32" ]
            Cbref14,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 6/32" ]
            Cbref15,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 7/32" ]
            Cbref16,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 8/32" ]
            Cbref17,
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 9/32" ]
            Cbref18,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 10/32" ]
            Cbref19,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 11/32" ]
            Cbref110,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 12/32" ]
            Cbref111,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 13/32" ]
            Cbref112,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 14/32" ]
            Cbref113,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 15/32" ]
            Cbref114,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 16/32" ]
            Cbref115,
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 17/32" ]
            Cbref116,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 18/32" ]
            Cbref117,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 19/32" ]
            Cbref118,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 20/32" ]
            Cbref119,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 21/32" ]
            Cbref120,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 22/32" ]
            Cbref121,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 23/32" ]
            Cbref122,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 24/32" ]
            Cbref123,
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 25/32" ]
            Cbref124,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 26/32" ]
            Cbref125,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 27/32" ]
            Cbref126,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 28/32" ]
            Cbref127,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 29/32" ]
            Cbref128,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 30/32" ]
            Cbref129,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 31/32" ]
            Cbref130,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 32/32" ]
            Cbref131,
        }
        impl Cbref1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Cbref1R::Cbref10 => 0,
                    Cbref1R::Cbref11 => 1,
                    Cbref1R::Cbref12 => 2,
                    Cbref1R::Cbref13 => 3,
                    Cbref1R::Cbref14 => 4,
                    Cbref1R::Cbref15 => 5,
                    Cbref1R::Cbref16 => 6,
                    Cbref1R::Cbref17 => 7,
                    Cbref1R::Cbref18 => 8,
                    Cbref1R::Cbref19 => 9,
                    Cbref1R::Cbref110 => 10,
                    Cbref1R::Cbref111 => 11,
                    Cbref1R::Cbref112 => 12,
                    Cbref1R::Cbref113 => 13,
                    Cbref1R::Cbref114 => 14,
                    Cbref1R::Cbref115 => 15,
                    Cbref1R::Cbref116 => 16,
                    Cbref1R::Cbref117 => 17,
                    Cbref1R::Cbref118 => 18,
                    Cbref1R::Cbref119 => 19,
                    Cbref1R::Cbref120 => 20,
                    Cbref1R::Cbref121 => 21,
                    Cbref1R::Cbref122 => 22,
                    Cbref1R::Cbref123 => 23,
                    Cbref1R::Cbref124 => 24,
                    Cbref1R::Cbref125 => 25,
                    Cbref1R::Cbref126 => 26,
                    Cbref1R::Cbref127 => 27,
                    Cbref1R::Cbref128 => 28,
                    Cbref1R::Cbref129 => 29,
                    Cbref1R::Cbref130 => 30,
                    Cbref1R::Cbref131 => 31,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Cbref1R {
                match bits {
                    0 => Cbref1R::Cbref10,
                    1 => Cbref1R::Cbref11,
                    2 => Cbref1R::Cbref12,
                    3 => Cbref1R::Cbref13,
                    4 => Cbref1R::Cbref14,
                    5 => Cbref1R::Cbref15,
                    6 => Cbref1R::Cbref16,
                    7 => Cbref1R::Cbref17,
                    8 => Cbref1R::Cbref18,
                    9 => Cbref1R::Cbref19,
                    10 => Cbref1R::Cbref110,
                    11 => Cbref1R::Cbref111,
                    12 => Cbref1R::Cbref112,
                    13 => Cbref1R::Cbref113,
                    14 => Cbref1R::Cbref114,
                    15 => Cbref1R::Cbref115,
                    16 => Cbref1R::Cbref116,
                    17 => Cbref1R::Cbref117,
                    18 => Cbref1R::Cbref118,
                    19 => Cbref1R::Cbref119,
                    20 => Cbref1R::Cbref120,
                    21 => Cbref1R::Cbref121,
                    22 => Cbref1R::Cbref122,
                    23 => Cbref1R::Cbref123,
                    24 => Cbref1R::Cbref124,
                    25 => Cbref1R::Cbref125,
                    26 => Cbref1R::Cbref126,
                    27 => Cbref1R::Cbref127,
                    28 => Cbref1R::Cbref128,
                    29 => Cbref1R::Cbref129,
                    30 => Cbref1R::Cbref130,
                    31 => Cbref1R::Cbref131,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbref10`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_0(&self) -> bool {
                *self == Cbref1R::Cbref10
            }
            # [ doc = "Checks if the value of the field is `Cbref11`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_1(&self) -> bool {
                *self == Cbref1R::Cbref11
            }
            # [ doc = "Checks if the value of the field is `Cbref12`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_2(&self) -> bool {
                *self == Cbref1R::Cbref12
            }
            # [ doc = "Checks if the value of the field is `Cbref13`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_3(&self) -> bool {
                *self == Cbref1R::Cbref13
            }
            # [ doc = "Checks if the value of the field is `Cbref14`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_4(&self) -> bool {
                *self == Cbref1R::Cbref14
            }
            # [ doc = "Checks if the value of the field is `Cbref15`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_5(&self) -> bool {
                *self == Cbref1R::Cbref15
            }
            # [ doc = "Checks if the value of the field is `Cbref16`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_6(&self) -> bool {
                *self == Cbref1R::Cbref16
            }
            # [ doc = "Checks if the value of the field is `Cbref17`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_7(&self) -> bool {
                *self == Cbref1R::Cbref17
            }
            # [ doc = "Checks if the value of the field is `Cbref18`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_8(&self) -> bool {
                *self == Cbref1R::Cbref18
            }
            # [ doc = "Checks if the value of the field is `Cbref19`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_9(&self) -> bool {
                *self == Cbref1R::Cbref19
            }
            # [ doc = "Checks if the value of the field is `Cbref110`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_10(&self) -> bool {
                *self == Cbref1R::Cbref110
            }
            # [ doc = "Checks if the value of the field is `Cbref111`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_11(&self) -> bool {
                *self == Cbref1R::Cbref111
            }
            # [ doc = "Checks if the value of the field is `Cbref112`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_12(&self) -> bool {
                *self == Cbref1R::Cbref112
            }
            # [ doc = "Checks if the value of the field is `Cbref113`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_13(&self) -> bool {
                *self == Cbref1R::Cbref113
            }
            # [ doc = "Checks if the value of the field is `Cbref114`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_14(&self) -> bool {
                *self == Cbref1R::Cbref114
            }
            # [ doc = "Checks if the value of the field is `Cbref115`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_15(&self) -> bool {
                *self == Cbref1R::Cbref115
            }
            # [ doc = "Checks if the value of the field is `Cbref116`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_16(&self) -> bool {
                *self == Cbref1R::Cbref116
            }
            # [ doc = "Checks if the value of the field is `Cbref117`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_17(&self) -> bool {
                *self == Cbref1R::Cbref117
            }
            # [ doc = "Checks if the value of the field is `Cbref118`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_18(&self) -> bool {
                *self == Cbref1R::Cbref118
            }
            # [ doc = "Checks if the value of the field is `Cbref119`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_19(&self) -> bool {
                *self == Cbref1R::Cbref119
            }
            # [ doc = "Checks if the value of the field is `Cbref120`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_20(&self) -> bool {
                *self == Cbref1R::Cbref120
            }
            # [ doc = "Checks if the value of the field is `Cbref121`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_21(&self) -> bool {
                *self == Cbref1R::Cbref121
            }
            # [ doc = "Checks if the value of the field is `Cbref122`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_22(&self) -> bool {
                *self == Cbref1R::Cbref122
            }
            # [ doc = "Checks if the value of the field is `Cbref123`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_23(&self) -> bool {
                *self == Cbref1R::Cbref123
            }
            # [ doc = "Checks if the value of the field is `Cbref124`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_24(&self) -> bool {
                *self == Cbref1R::Cbref124
            }
            # [ doc = "Checks if the value of the field is `Cbref125`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_25(&self) -> bool {
                *self == Cbref1R::Cbref125
            }
            # [ doc = "Checks if the value of the field is `Cbref126`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_26(&self) -> bool {
                *self == Cbref1R::Cbref126
            }
            # [ doc = "Checks if the value of the field is `Cbref127`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_27(&self) -> bool {
                *self == Cbref1R::Cbref127
            }
            # [ doc = "Checks if the value of the field is `Cbref128`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_28(&self) -> bool {
                *self == Cbref1R::Cbref128
            }
            # [ doc = "Checks if the value of the field is `Cbref129`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_29(&self) -> bool {
                *self == Cbref1R::Cbref129
            }
            # [ doc = "Checks if the value of the field is `Cbref130`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_30(&self) -> bool {
                *self == Cbref1R::Cbref130
            }
            # [ doc = "Checks if the value of the field is `Cbref131`" ]
            # [ inline ( always ) ]
            pub fn is_cbref1_31(&self) -> bool {
                *self == Cbref1R::Cbref131
            }
        }
        # [ doc = "Possible values of the field `CBREFL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CbreflR {
            # [ doc = "Comp. B Reference voltage level 0 : None" ]
            Cbrefl0,
            # [ doc = "Comp. B Reference voltage level 1 : 1.5V" ]
            Cbrefl1,
            # [ doc = "Comp. B Reference voltage level 2 : 2.0V" ]
            Cbrefl2,
            # [ doc = "Comp. B Reference voltage level 3 : 2.5V" ]
            Cbrefl3,
        }
        impl CbreflR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CbreflR::Cbrefl0 => 0,
                    CbreflR::Cbrefl1 => 1,
                    CbreflR::Cbrefl2 => 2,
                    CbreflR::Cbrefl3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CbreflR {
                match bits {
                    0 => CbreflR::Cbrefl0,
                    1 => CbreflR::Cbrefl1,
                    2 => CbreflR::Cbrefl2,
                    3 => CbreflR::Cbrefl3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cbrefl0`" ]
            # [ inline ( always ) ]
            pub fn is_cbrefl_0(&self) -> bool {
                *self == CbreflR::Cbrefl0
            }
            # [ doc = "Checks if the value of the field is `Cbrefl1`" ]
            # [ inline ( always ) ]
            pub fn is_cbrefl_1(&self) -> bool {
                *self == CbreflR::Cbrefl1
            }
            # [ doc = "Checks if the value of the field is `Cbrefl2`" ]
            # [ inline ( always ) ]
            pub fn is_cbrefl_2(&self) -> bool {
                *self == CbreflR::Cbrefl2
            }
            # [ doc = "Checks if the value of the field is `Cbrefl3`" ]
            # [ inline ( always ) ]
            pub fn is_cbrefl_3(&self) -> bool {
                *self == CbreflR::Cbrefl3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbrefaccR {
            bits: u8,
        }
        impl CbrefaccR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `CBREF0`" ]
        pub enum Cbref0W {
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 1/32" ]
            Cbref00,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 2/32" ]
            Cbref01,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 3/32" ]
            Cbref02,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 4/32" ]
            Cbref03,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 5/32" ]
            Cbref04,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 6/32" ]
            Cbref05,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 7/32" ]
            Cbref06,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 8/32" ]
            Cbref07,
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 9/32" ]
            Cbref08,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 10/32" ]
            Cbref09,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 11/32" ]
            Cbref010,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 12/32" ]
            Cbref011,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 13/32" ]
            Cbref012,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 14/32" ]
            Cbref013,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 15/32" ]
            Cbref014,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 16/32" ]
            Cbref015,
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 17/32" ]
            Cbref016,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 18/32" ]
            Cbref017,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 19/32" ]
            Cbref018,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 20/32" ]
            Cbref019,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 21/32" ]
            Cbref020,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 22/32" ]
            Cbref021,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 23/32" ]
            Cbref022,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 24/32" ]
            Cbref023,
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 25/32" ]
            Cbref024,
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 26/32" ]
            Cbref025,
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 27/32" ]
            Cbref026,
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 28/32" ]
            Cbref027,
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 29/32" ]
            Cbref028,
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 30/32" ]
            Cbref029,
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 31/32" ]
            Cbref030,
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 32/32" ]
            Cbref031,
        }
        impl Cbref0W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Cbref0W::Cbref00 => 0,
                    Cbref0W::Cbref01 => 1,
                    Cbref0W::Cbref02 => 2,
                    Cbref0W::Cbref03 => 3,
                    Cbref0W::Cbref04 => 4,
                    Cbref0W::Cbref05 => 5,
                    Cbref0W::Cbref06 => 6,
                    Cbref0W::Cbref07 => 7,
                    Cbref0W::Cbref08 => 8,
                    Cbref0W::Cbref09 => 9,
                    Cbref0W::Cbref010 => 10,
                    Cbref0W::Cbref011 => 11,
                    Cbref0W::Cbref012 => 12,
                    Cbref0W::Cbref013 => 13,
                    Cbref0W::Cbref014 => 14,
                    Cbref0W::Cbref015 => 15,
                    Cbref0W::Cbref016 => 16,
                    Cbref0W::Cbref017 => 17,
                    Cbref0W::Cbref018 => 18,
                    Cbref0W::Cbref019 => 19,
                    Cbref0W::Cbref020 => 20,
                    Cbref0W::Cbref021 => 21,
                    Cbref0W::Cbref022 => 22,
                    Cbref0W::Cbref023 => 23,
                    Cbref0W::Cbref024 => 24,
                    Cbref0W::Cbref025 => 25,
                    Cbref0W::Cbref026 => 26,
                    Cbref0W::Cbref027 => 27,
                    Cbref0W::Cbref028 => 28,
                    Cbref0W::Cbref029 => 29,
                    Cbref0W::Cbref030 => 30,
                    Cbref0W::Cbref031 => 31,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbref0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbref0W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cbref0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 1/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_0(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref00)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 2/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_1(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref01)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 3/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_2(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref02)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 4/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_3(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref03)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 5/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_4(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref04)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 6/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_5(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref05)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 7/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_6(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref06)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 8/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_7(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref07)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 9/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_8(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref08)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 10/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_9(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref09)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 11/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_10(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref010)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 12/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_11(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref011)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 13/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_12(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref012)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 14/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_13(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref013)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 15/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_14(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref014)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 16/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_15(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref015)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 17/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_16(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref016)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 18/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_17(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref017)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 19/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_18(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref018)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 20/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_19(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref019)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 21/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_20(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref020)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 22/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_21(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref021)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 23/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_22(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref022)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 24/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_23(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref023)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 0 : 25/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_24(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref024)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 1 : 26/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_25(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref025)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 2 : 27/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_26(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref026)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 3 : 28/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_27(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref027)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 4 : 29/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_28(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref028)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 5 : 30/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_29(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref029)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 6 : 31/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_30(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref030)
            }
            # [ doc = "Comp. B Int. Ref.0 Select 7 : 32/32" ]
            # [ inline ( always ) ]
            pub fn cbref0_31(self) -> &'a mut W {
                self.variant(Cbref0W::Cbref031)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbrselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbrselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CBRS`" ]
        pub enum CbrsW {
            # [ doc = "Comp. B Reference Source 0 : Off" ]
            Cbrs0,
            # [ doc = "Comp. B Reference Source 1 : Vcc" ]
            Cbrs1,
            # [ doc = "Comp. B Reference Source 2 : Shared Ref." ]
            Cbrs2,
            # [ doc = "Comp. B Reference Source 3 : Shared Ref. / Off" ]
            Cbrs3,
        }
        impl CbrsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CbrsW::Cbrs0 => 0,
                    CbrsW::Cbrs1 => 1,
                    CbrsW::Cbrs2 => 2,
                    CbrsW::Cbrs3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbrsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CbrsW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B Reference Source 0 : Off" ]
            # [ inline ( always ) ]
            pub fn cbrs_0(self) -> &'a mut W {
                self.variant(CbrsW::Cbrs0)
            }
            # [ doc = "Comp. B Reference Source 1 : Vcc" ]
            # [ inline ( always ) ]
            pub fn cbrs_1(self) -> &'a mut W {
                self.variant(CbrsW::Cbrs1)
            }
            # [ doc = "Comp. B Reference Source 2 : Shared Ref." ]
            # [ inline ( always ) ]
            pub fn cbrs_2(self) -> &'a mut W {
                self.variant(CbrsW::Cbrs2)
            }
            # [ doc = "Comp. B Reference Source 3 : Shared Ref. / Off" ]
            # [ inline ( always ) ]
            pub fn cbrs_3(self) -> &'a mut W {
                self.variant(CbrsW::Cbrs3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CBREF1`" ]
        pub enum Cbref1W {
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 1/32" ]
            Cbref10,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 2/32" ]
            Cbref11,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 3/32" ]
            Cbref12,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 4/32" ]
            Cbref13,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 5/32" ]
            Cbref14,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 6/32" ]
            Cbref15,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 7/32" ]
            Cbref16,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 8/32" ]
            Cbref17,
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 9/32" ]
            Cbref18,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 10/32" ]
            Cbref19,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 11/32" ]
            Cbref110,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 12/32" ]
            Cbref111,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 13/32" ]
            Cbref112,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 14/32" ]
            Cbref113,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 15/32" ]
            Cbref114,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 16/32" ]
            Cbref115,
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 17/32" ]
            Cbref116,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 18/32" ]
            Cbref117,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 19/32" ]
            Cbref118,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 20/32" ]
            Cbref119,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 21/32" ]
            Cbref120,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 22/32" ]
            Cbref121,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 23/32" ]
            Cbref122,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 24/32" ]
            Cbref123,
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 25/32" ]
            Cbref124,
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 26/32" ]
            Cbref125,
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 27/32" ]
            Cbref126,
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 28/32" ]
            Cbref127,
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 29/32" ]
            Cbref128,
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 30/32" ]
            Cbref129,
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 31/32" ]
            Cbref130,
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 32/32" ]
            Cbref131,
        }
        impl Cbref1W {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Cbref1W::Cbref10 => 0,
                    Cbref1W::Cbref11 => 1,
                    Cbref1W::Cbref12 => 2,
                    Cbref1W::Cbref13 => 3,
                    Cbref1W::Cbref14 => 4,
                    Cbref1W::Cbref15 => 5,
                    Cbref1W::Cbref16 => 6,
                    Cbref1W::Cbref17 => 7,
                    Cbref1W::Cbref18 => 8,
                    Cbref1W::Cbref19 => 9,
                    Cbref1W::Cbref110 => 10,
                    Cbref1W::Cbref111 => 11,
                    Cbref1W::Cbref112 => 12,
                    Cbref1W::Cbref113 => 13,
                    Cbref1W::Cbref114 => 14,
                    Cbref1W::Cbref115 => 15,
                    Cbref1W::Cbref116 => 16,
                    Cbref1W::Cbref117 => 17,
                    Cbref1W::Cbref118 => 18,
                    Cbref1W::Cbref119 => 19,
                    Cbref1W::Cbref120 => 20,
                    Cbref1W::Cbref121 => 21,
                    Cbref1W::Cbref122 => 22,
                    Cbref1W::Cbref123 => 23,
                    Cbref1W::Cbref124 => 24,
                    Cbref1W::Cbref125 => 25,
                    Cbref1W::Cbref126 => 26,
                    Cbref1W::Cbref127 => 27,
                    Cbref1W::Cbref128 => 28,
                    Cbref1W::Cbref129 => 29,
                    Cbref1W::Cbref130 => 30,
                    Cbref1W::Cbref131 => 31,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbref1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbref1W<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Cbref1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 1/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_0(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref10)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 2/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_1(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref11)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 3/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_2(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref12)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 4/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_3(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref13)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 5/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_4(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref14)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 6/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_5(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref15)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 7/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_6(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref16)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 8/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_7(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref17)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 9/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_8(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref18)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 10/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_9(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref19)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 11/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_10(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref110)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 12/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_11(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref111)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 13/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_12(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref112)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 14/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_13(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref113)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 15/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_14(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref114)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 16/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_15(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref115)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 17/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_16(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref116)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 18/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_17(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref117)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 19/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_18(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref118)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 20/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_19(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref119)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 21/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_20(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref120)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 22/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_21(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref121)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 23/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_22(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref122)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 24/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_23(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref123)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 0 : 25/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_24(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref124)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 1 : 26/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_25(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref125)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 2 : 27/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_26(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref126)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 3 : 28/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_27(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref127)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 4 : 29/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_28(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref128)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 5 : 30/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_29(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref129)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 6 : 31/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_30(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref130)
            }
            # [ doc = "Comp. B Int. Ref.1 Select 7 : 32/32" ]
            # [ inline ( always ) ]
            pub fn cbref1_31(self) -> &'a mut W {
                self.variant(Cbref1W::Cbref131)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CBREFL`" ]
        pub enum CbreflW {
            # [ doc = "Comp. B Reference voltage level 0 : None" ]
            Cbrefl0,
            # [ doc = "Comp. B Reference voltage level 1 : 1.5V" ]
            Cbrefl1,
            # [ doc = "Comp. B Reference voltage level 2 : 2.0V" ]
            Cbrefl2,
            # [ doc = "Comp. B Reference voltage level 3 : 2.5V" ]
            Cbrefl3,
        }
        impl CbreflW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CbreflW::Cbrefl0 => 0,
                    CbreflW::Cbrefl1 => 1,
                    CbreflW::Cbrefl2 => 2,
                    CbreflW::Cbrefl3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbreflW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbreflW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CbreflW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Comp. B Reference voltage level 0 : None" ]
            # [ inline ( always ) ]
            pub fn cbrefl_0(self) -> &'a mut W {
                self.variant(CbreflW::Cbrefl0)
            }
            # [ doc = "Comp. B Reference voltage level 1 : 1.5V" ]
            # [ inline ( always ) ]
            pub fn cbrefl_1(self) -> &'a mut W {
                self.variant(CbreflW::Cbrefl1)
            }
            # [ doc = "Comp. B Reference voltage level 2 : 2.0V" ]
            # [ inline ( always ) ]
            pub fn cbrefl_2(self) -> &'a mut W {
                self.variant(CbreflW::Cbrefl2)
            }
            # [ doc = "Comp. B Reference voltage level 3 : 2.5V" ]
            # [ inline ( always ) ]
            pub fn cbrefl_3(self) -> &'a mut W {
                self.variant(CbreflW::Cbrefl3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbrefaccW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbrefaccW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 4:8 - Comp. B Reference 0 Resistor Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbref0(&self) -> Cbref0R {
                Cbref0R::_from({
                                   const MASK: u8 = 31;
                                   const OFFSET: u8 = 4;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 5 - Comp. B Reference select" ]
            # [ inline ( always ) ]
            pub fn cbrsel(&self) -> CbrselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbrselR { bits }
            }
            # [ doc = "Bits 7:8 - Comp. B Reference Source Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbrs(&self) -> CbrsR {
                CbrsR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 7;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 12:16 - Comp. B Reference 1 Resistor Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbref1(&self) -> Cbref1R {
                Cbref1R::_from({
                                   const MASK: u8 = 31;
                                   const OFFSET: u8 = 12;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bits 14:15 - Comp. B Reference voltage level Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbrefl(&self) -> CbreflR {
                CbreflR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 14;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 15 - Comp. B Reference Accuracy" ]
            # [ inline ( always ) ]
            pub fn cbrefacc(&self) -> CbrefaccR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbrefaccR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:8 - Comp. B Reference 0 Resistor Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbref0(&mut self) -> _Cbref0W {
                _Cbref0W { w: self }
            }
            # [ doc = "Bit 5 - Comp. B Reference select" ]
            # [ inline ( always ) ]
            pub fn cbrsel(&mut self) -> _CbrselW {
                _CbrselW { w: self }
            }
            # [ doc = "Bits 7:8 - Comp. B Reference Source Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbrs(&mut self) -> _CbrsW {
                _CbrsW { w: self }
            }
            # [ doc = "Bits 12:16 - Comp. B Reference 1 Resistor Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbref1(&mut self) -> _Cbref1W {
                _Cbref1W { w: self }
            }
            # [ doc = "Bits 14:15 - Comp. B Reference voltage level Bit : 0" ]
            # [ inline ( always ) ]
            pub fn cbrefl(&mut self) -> _CbreflW {
                _CbreflW { w: self }
            }
            # [ doc = "Bit 15 - Comp. B Reference Accuracy" ]
            # [ inline ( always ) ]
            pub fn cbrefacc(&mut self) -> _CbrefaccW {
                _CbrefaccW { w: self }
            }
        }
    }
    # [ doc = "Comparator B Control Register 3" ]
    pub struct Cbctl3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Comparator B Control Register 3" ]
    pub mod cbctl3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Cbctl3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd0R {
            bits: u8,
        }
        impl Cbpd0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd1R {
            bits: u8,
        }
        impl Cbpd1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd2R {
            bits: u8,
        }
        impl Cbpd2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd3R {
            bits: u8,
        }
        impl Cbpd3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd4R {
            bits: u8,
        }
        impl Cbpd4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd5R {
            bits: u8,
        }
        impl Cbpd5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd6R {
            bits: u8,
        }
        impl Cbpd6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd7R {
            bits: u8,
        }
        impl Cbpd7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd8R {
            bits: u8,
        }
        impl Cbpd8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd9R {
            bits: u8,
        }
        impl Cbpd9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd10R {
            bits: u8,
        }
        impl Cbpd10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd11R {
            bits: u8,
        }
        impl Cbpd11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd12R {
            bits: u8,
        }
        impl Cbpd12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd13R {
            bits: u8,
        }
        impl Cbpd13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd14R {
            bits: u8,
        }
        impl Cbpd14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Cbpd15R {
            bits: u8,
        }
        impl Cbpd15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Cbpd15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cbpd15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Comp. B Disable Input Buffer of Port Register .0" ]
            # [ inline ( always ) ]
            pub fn cbpd0(&self) -> Cbpd0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd0R { bits }
            }
            # [ doc = "Bit 1 - Comp. B Disable Input Buffer of Port Register .1" ]
            # [ inline ( always ) ]
            pub fn cbpd1(&self) -> Cbpd1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd1R { bits }
            }
            # [ doc = "Bit 2 - Comp. B Disable Input Buffer of Port Register .2" ]
            # [ inline ( always ) ]
            pub fn cbpd2(&self) -> Cbpd2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd2R { bits }
            }
            # [ doc = "Bit 3 - Comp. B Disable Input Buffer of Port Register .3" ]
            # [ inline ( always ) ]
            pub fn cbpd3(&self) -> Cbpd3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd3R { bits }
            }
            # [ doc = "Bit 4 - Comp. B Disable Input Buffer of Port Register .4" ]
            # [ inline ( always ) ]
            pub fn cbpd4(&self) -> Cbpd4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd4R { bits }
            }
            # [ doc = "Bit 5 - Comp. B Disable Input Buffer of Port Register .5" ]
            # [ inline ( always ) ]
            pub fn cbpd5(&self) -> Cbpd5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd5R { bits }
            }
            # [ doc = "Bit 6 - Comp. B Disable Input Buffer of Port Register .6" ]
            # [ inline ( always ) ]
            pub fn cbpd6(&self) -> Cbpd6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd6R { bits }
            }
            # [ doc = "Bit 7 - Comp. B Disable Input Buffer of Port Register .7" ]
            # [ inline ( always ) ]
            pub fn cbpd7(&self) -> Cbpd7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd7R { bits }
            }
            # [ doc = "Bit 8 - Comp. B Disable Input Buffer of Port Register .8" ]
            # [ inline ( always ) ]
            pub fn cbpd8(&self) -> Cbpd8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd8R { bits }
            }
            # [ doc = "Bit 9 - Comp. B Disable Input Buffer of Port Register .9" ]
            # [ inline ( always ) ]
            pub fn cbpd9(&self) -> Cbpd9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd9R { bits }
            }
            # [ doc = "Bit 10 - Comp. B Disable Input Buffer of Port Register .10" ]
            # [ inline ( always ) ]
            pub fn cbpd10(&self) -> Cbpd10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd10R { bits }
            }
            # [ doc = "Bit 11 - Comp. B Disable Input Buffer of Port Register .11" ]
            # [ inline ( always ) ]
            pub fn cbpd11(&self) -> Cbpd11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd11R { bits }
            }
            # [ doc = "Bit 12 - Comp. B Disable Input Buffer of Port Register .12" ]
            # [ inline ( always ) ]
            pub fn cbpd12(&self) -> Cbpd12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd12R { bits }
            }
            # [ doc = "Bit 13 - Comp. B Disable Input Buffer of Port Register .13" ]
            # [ inline ( always ) ]
            pub fn cbpd13(&self) -> Cbpd13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd13R { bits }
            }
            # [ doc = "Bit 14 - Comp. B Disable Input Buffer of Port Register .14" ]
            # [ inline ( always ) ]
            pub fn cbpd14(&self) -> Cbpd14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd14R { bits }
            }
            # [ doc = "Bit 15 - Comp. B Disable Input Buffer of Port Register .15" ]
            # [ inline ( always ) ]
            pub fn cbpd15(&self) -> Cbpd15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Cbpd15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Comp. B Disable Input Buffer of Port Register .0" ]
            # [ inline ( always ) ]
            pub fn cbpd0(&mut self) -> _Cbpd0W {
                _Cbpd0W { w: self }
            }
            # [ doc = "Bit 1 - Comp. B Disable Input Buffer of Port Register .1" ]
            # [ inline ( always ) ]
            pub fn cbpd1(&mut self) -> _Cbpd1W {
                _Cbpd1W { w: self }
            }
            # [ doc = "Bit 2 - Comp. B Disable Input Buffer of Port Register .2" ]
            # [ inline ( always ) ]
            pub fn cbpd2(&mut self) -> _Cbpd2W {
                _Cbpd2W { w: self }
            }
            # [ doc = "Bit 3 - Comp. B Disable Input Buffer of Port Register .3" ]
            # [ inline ( always ) ]
            pub fn cbpd3(&mut self) -> _Cbpd3W {
                _Cbpd3W { w: self }
            }
            # [ doc = "Bit 4 - Comp. B Disable Input Buffer of Port Register .4" ]
            # [ inline ( always ) ]
            pub fn cbpd4(&mut self) -> _Cbpd4W {
                _Cbpd4W { w: self }
            }
            # [ doc = "Bit 5 - Comp. B Disable Input Buffer of Port Register .5" ]
            # [ inline ( always ) ]
            pub fn cbpd5(&mut self) -> _Cbpd5W {
                _Cbpd5W { w: self }
            }
            # [ doc = "Bit 6 - Comp. B Disable Input Buffer of Port Register .6" ]
            # [ inline ( always ) ]
            pub fn cbpd6(&mut self) -> _Cbpd6W {
                _Cbpd6W { w: self }
            }
            # [ doc = "Bit 7 - Comp. B Disable Input Buffer of Port Register .7" ]
            # [ inline ( always ) ]
            pub fn cbpd7(&mut self) -> _Cbpd7W {
                _Cbpd7W { w: self }
            }
            # [ doc = "Bit 8 - Comp. B Disable Input Buffer of Port Register .8" ]
            # [ inline ( always ) ]
            pub fn cbpd8(&mut self) -> _Cbpd8W {
                _Cbpd8W { w: self }
            }
            # [ doc = "Bit 9 - Comp. B Disable Input Buffer of Port Register .9" ]
            # [ inline ( always ) ]
            pub fn cbpd9(&mut self) -> _Cbpd9W {
                _Cbpd9W { w: self }
            }
            # [ doc = "Bit 10 - Comp. B Disable Input Buffer of Port Register .10" ]
            # [ inline ( always ) ]
            pub fn cbpd10(&mut self) -> _Cbpd10W {
                _Cbpd10W { w: self }
            }
            # [ doc = "Bit 11 - Comp. B Disable Input Buffer of Port Register .11" ]
            # [ inline ( always ) ]
            pub fn cbpd11(&mut self) -> _Cbpd11W {
                _Cbpd11W { w: self }
            }
            # [ doc = "Bit 12 - Comp. B Disable Input Buffer of Port Register .12" ]
            # [ inline ( always ) ]
            pub fn cbpd12(&mut self) -> _Cbpd12W {
                _Cbpd12W { w: self }
            }
            # [ doc = "Bit 13 - Comp. B Disable Input Buffer of Port Register .13" ]
            # [ inline ( always ) ]
            pub fn cbpd13(&mut self) -> _Cbpd13W {
                _Cbpd13W { w: self }
            }
            # [ doc = "Bit 14 - Comp. B Disable Input Buffer of Port Register .14" ]
            # [ inline ( always ) ]
            pub fn cbpd14(&mut self) -> _Cbpd14W {
                _Cbpd14W { w: self }
            }
            # [ doc = "Bit 15 - Comp. B Disable Input Buffer of Port Register .15" ]
            # [ inline ( always ) ]
            pub fn cbpd15(&mut self) -> _Cbpd15W {
                _Cbpd15W { w: self }
            }
        }
    }
    # [ doc = "Comparator B Interrupt Register" ]
    pub struct Cbint {
        register: VolatileCell<u16>,
    }
    # [ doc = "Comparator B Interrupt Register" ]
    pub mod cbint {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Cbint {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbifgR {
            bits: u8,
        }
        impl CbifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbiifgR {
            bits: u8,
        }
        impl CbiifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbieR {
            bits: u8,
        }
        impl CbieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CbiieR {
            bits: u8,
        }
        impl CbiieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbiifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbiifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CbiieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CbiieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Comp. B Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn cbifg(&self) -> CbifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbifgR { bits }
            }
            # [ doc = "Bit 1 - Comp. B Interrupt Flag Inverted Polarity" ]
            # [ inline ( always ) ]
            pub fn cbiifg(&self) -> CbiifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbiifgR { bits }
            }
            # [ doc = "Bit 8 - Comp. B Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn cbie(&self) -> CbieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbieR { bits }
            }
            # [ doc = "Bit 9 - Comp. B Interrupt Enable Inverted Polarity" ]
            # [ inline ( always ) ]
            pub fn cbiie(&self) -> CbiieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CbiieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Comp. B Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn cbifg(&mut self) -> _CbifgW {
                _CbifgW { w: self }
            }
            # [ doc = "Bit 1 - Comp. B Interrupt Flag Inverted Polarity" ]
            # [ inline ( always ) ]
            pub fn cbiifg(&mut self) -> _CbiifgW {
                _CbiifgW { w: self }
            }
            # [ doc = "Bit 8 - Comp. B Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn cbie(&mut self) -> _CbieW {
                _CbieW { w: self }
            }
            # [ doc = "Bit 9 - Comp. B Interrupt Enable Inverted Polarity" ]
            # [ inline ( always ) ]
            pub fn cbiie(&mut self) -> _CbiieW {
                _CbiieW { w: self }
            }
        }
    }
    # [ doc = "Comparator B Interrupt Vector Word" ]
    pub struct Cbiv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Comparator B Interrupt Vector Word" ]
    pub mod cbiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Cbiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "Comparator B" ]
pub struct ComparatorB {
    register_block: comparator_b::RegisterBlock,
}
impl Deref for ComparatorB {
    type Target = comparator_b::RegisterBlock;
    fn deref(&self) -> &comparator_b::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "CC1101 Radio Interface" ]
pub const CC1101_RADIO_INTERFACE: Peripheral<Cc1101RadioInterface> = unsafe { Peripheral::new(0) };
# [ doc = "CC1101 Radio Interface" ]
pub mod cc1101_radio_interface {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 3840usize],
        # [ doc = "0xf00 - Radio interface control register 0" ]
        pub rf1aifctl0: Rf1aifctl0,
        # [ doc = "0xf02 - Radio interface control register 1" ]
        pub rf1aifctl1: Rf1aifctl1,
        # [ doc = "0xf04 - (Radio interface control register 2)" ]
        pub rf1aifctl2: Rf1aifctl2,
        # [ doc = "0xf06 - Radio interface error flag register" ]
        pub rf1aiferr: Rf1aiferr,
        _reserved1: [u8; 4usize],
        # [ doc = "0xf0c - Radio interface error vector word register" ]
        pub rf1aiferrv: Rf1aiferrv,
        # [ doc = "0xf0e - Radio interface interrupt vector word register" ]
        pub rf1aifiv: Rf1aifiv,
        # [ doc = "0xf10 - Radio instruction word register" ]
        pub rf1ainstrw: Rf1ainstrw,
        # [ doc = "0xf12 - Radio instruction 1-byte register with autoread" ]
        pub rf1ainstr1w: Rf1ainstr1w,
        # [ doc = "0xf14 - Radio instruction 2-byte register with autoread" ]
        pub rf1ainstr2w: Rf1ainstr2w,
        # [ doc = "0xf16 - Radio word data in register" ]
        pub rf1adinw: Rf1adinw,
        _reserved2: [u8; 8usize],
        # [ doc = "0xf20 - Radio status word register without auto-read" ]
        pub rf1astat0w: Rf1astat0w,
        # [ doc = "0xf22 - Radio status word register with 1-byte auto-read" ]
        pub rf1astat1w: Rf1astat1w,
        # [ doc = "0xf24 - Radio status word register with 2-byte auto-read" ]
        pub rf1astat2w: Rf1astat2w,
        _reserved3: [u8; 2usize],
        # [ doc = "0xf28 - Radio core word data out register without auto-read" ]
        pub rf1adout0w: Rf1adout0w,
        # [ doc = "0xf2a - Radio core word data out register with 1-byte auto-read" ]
        pub rf1adout1w: Rf1adout1w,
        # [ doc = "0xf2c - Radio core word data out register with 2-byte auto-read" ]
        pub rf1adout2w: Rf1adout2w,
        _reserved4: [u8; 2usize],
        # [ doc = "0xf30 - Radio core signal input register" ]
        pub rf1ain: Rf1ain,
        # [ doc = "0xf32 - Radio core interrupt flag register" ]
        pub rf1aifg: Rf1aifg,
        # [ doc = "0xf34 - Radio core interrupt edge select register" ]
        pub rf1aies: Rf1aies,
        # [ doc = "0xf36 - Radio core interrupt enable register" ]
        pub rf1aie: Rf1aie,
        # [ doc = "0xf38 - Radio core interrupt vector word register" ]
        pub rf1aiv: Rf1aiv,
        _reserved5: [u8; 2usize],
        # [ doc = "0xf3c - Direct receive FIFO access register" ]
        pub rf1arxfifo: Rf1arxfifo,
        # [ doc = "0xf3e - Direct transmit FIFO access register" ]
        pub rf1atxfifo: Rf1atxfifo,
    }
    # [ doc = "Radio interface control register 0" ]
    pub struct Rf1aifctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio interface control register 0" ]
    pub mod rf1aifctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aifctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RffifoenR {
            bits: u8,
        }
        impl RffifoenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfendianR {
            bits: u8,
        }
        impl RfendianR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RffifoenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RffifoenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfendianW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfendianW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - CC1101 Direct FIFO access enable" ]
            # [ inline ( always ) ]
            pub fn rffifoen(&self) -> RffifoenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RffifoenR { bits }
            }
            # [ doc = "Bit 1 - CC1101 Disable endianness conversion" ]
            # [ inline ( always ) ]
            pub fn rfendian(&self) -> RfendianR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfendianR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - CC1101 Direct FIFO access enable" ]
            # [ inline ( always ) ]
            pub fn rffifoen(&mut self) -> _RffifoenW {
                _RffifoenW { w: self }
            }
            # [ doc = "Bit 1 - CC1101 Disable endianness conversion" ]
            # [ inline ( always ) ]
            pub fn rfendian(&mut self) -> _RfendianW {
                _RfendianW { w: self }
            }
        }
    }
    # [ doc = "Radio interface control register 1" ]
    pub struct Rf1aifctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio interface control register 1" ]
    pub mod rf1aifctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aifctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfrxifgR {
            bits: u8,
        }
        impl RfrxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RftxifgR {
            bits: u8,
        }
        impl RftxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RferrifgR {
            bits: u8,
        }
        impl RferrifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfinstrifgR {
            bits: u8,
        }
        impl RfinstrifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfdinifgR {
            bits: u8,
        }
        impl RfdinifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfstatifgR {
            bits: u8,
        }
        impl RfstatifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfdoutifgR {
            bits: u8,
        }
        impl RfdoutifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfrxieR {
            bits: u8,
        }
        impl RfrxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RftxieR {
            bits: u8,
        }
        impl RftxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RferrieR {
            bits: u8,
        }
        impl RferrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfinstrieR {
            bits: u8,
        }
        impl RfinstrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfdinieR {
            bits: u8,
        }
        impl RfdinieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfstatieR {
            bits: u8,
        }
        impl RfstatieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RfdoutieR {
            bits: u8,
        }
        impl RfdoutieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfrxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfrxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RftxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RftxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RferrifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RferrifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfinstrifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfinstrifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfdinifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfdinifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfstatifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfstatifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfdoutifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfdoutifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfrxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfrxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RftxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RftxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RferrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RferrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfinstrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfinstrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfdinieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfdinieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfstatieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfstatieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RfdoutieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RfdoutieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Radio interface direct FIFO access receive interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfrxifg(&self) -> RfrxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfrxifgR { bits }
            }
            # [ doc = "Bit 1 - Radio interface direct FIFO access transmit interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rftxifg(&self) -> RftxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RftxifgR { bits }
            }
            # [ doc = "Bit 2 - Radio interface error interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rferrifg(&self) -> RferrifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RferrifgR { bits }
            }
            # [ doc = "Bit 4 - Radio interface instruction interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfinstrifg(&self) -> RfinstrifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfinstrifgR { bits }
            }
            # [ doc = "Bit 5 - Radio interface data in interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfdinifg(&self) -> RfdinifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfdinifgR { bits }
            }
            # [ doc = "Bit 6 - Radio interface status interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfstatifg(&self) -> RfstatifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfstatifgR { bits }
            }
            # [ doc = "Bit 7 - Radio interface data out interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfdoutifg(&self) -> RfdoutifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfdoutifgR { bits }
            }
            # [ doc = "Bit 8 - Radio interface direct FIFO access receive interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfrxie(&self) -> RfrxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfrxieR { bits }
            }
            # [ doc = "Bit 9 - Radio interface direct FIFO access transmit interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rftxie(&self) -> RftxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RftxieR { bits }
            }
            # [ doc = "Bit 10 - Radio interface error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rferrie(&self) -> RferrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RferrieR { bits }
            }
            # [ doc = "Bit 12 - Radio interface instruction interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfinstrie(&self) -> RfinstrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfinstrieR { bits }
            }
            # [ doc = "Bit 13 - Radio interface data in interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfdinie(&self) -> RfdinieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfdinieR { bits }
            }
            # [ doc = "Bit 14 - Radio interface status interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfstatie(&self) -> RfstatieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfstatieR { bits }
            }
            # [ doc = "Bit 15 - Radio interface data out interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfdoutie(&self) -> RfdoutieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RfdoutieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Radio interface direct FIFO access receive interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfrxifg(&mut self) -> _RfrxifgW {
                _RfrxifgW { w: self }
            }
            # [ doc = "Bit 1 - Radio interface direct FIFO access transmit interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rftxifg(&mut self) -> _RftxifgW {
                _RftxifgW { w: self }
            }
            # [ doc = "Bit 2 - Radio interface error interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rferrifg(&mut self) -> _RferrifgW {
                _RferrifgW { w: self }
            }
            # [ doc = "Bit 4 - Radio interface instruction interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfinstrifg(&mut self) -> _RfinstrifgW {
                _RfinstrifgW { w: self }
            }
            # [ doc = "Bit 5 - Radio interface data in interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfdinifg(&mut self) -> _RfdinifgW {
                _RfdinifgW { w: self }
            }
            # [ doc = "Bit 6 - Radio interface status interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfstatifg(&mut self) -> _RfstatifgW {
                _RfstatifgW { w: self }
            }
            # [ doc = "Bit 7 - Radio interface data out interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rfdoutifg(&mut self) -> _RfdoutifgW {
                _RfdoutifgW { w: self }
            }
            # [ doc = "Bit 8 - Radio interface direct FIFO access receive interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfrxie(&mut self) -> _RfrxieW {
                _RfrxieW { w: self }
            }
            # [ doc = "Bit 9 - Radio interface direct FIFO access transmit interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rftxie(&mut self) -> _RftxieW {
                _RftxieW { w: self }
            }
            # [ doc = "Bit 10 - Radio interface error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rferrie(&mut self) -> _RferrieW {
                _RferrieW { w: self }
            }
            # [ doc = "Bit 12 - Radio interface instruction interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfinstrie(&mut self) -> _RfinstrieW {
                _RfinstrieW { w: self }
            }
            # [ doc = "Bit 13 - Radio interface data in interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfdinie(&mut self) -> _RfdinieW {
                _RfdinieW { w: self }
            }
            # [ doc = "Bit 14 - Radio interface status interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfstatie(&mut self) -> _RfstatieW {
                _RfstatieW { w: self }
            }
            # [ doc = "Bit 15 - Radio interface data out interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rfdoutie(&mut self) -> _RfdoutieW {
                _RfdoutieW { w: self }
            }
        }
    }
    # [ doc = "(Radio interface control register 2)" ]
    pub struct Rf1aifctl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "(Radio interface control register 2)" ]
    pub mod rf1aifctl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aifctl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio interface error flag register" ]
    pub struct Rf1aiferr {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio interface error flag register" ]
    pub mod rf1aiferr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aiferr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LverrR {
            bits: u8,
        }
        impl LverrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OperrR {
            bits: u8,
        }
        impl OperrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OuterrR {
            bits: u8,
        }
        impl OuterrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OpoverrR {
            bits: u8,
        }
        impl OpoverrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LverrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LverrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OperrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OperrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OuterrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OuterrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OpoverrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpoverrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Low Core Voltage Error Flag" ]
            # [ inline ( always ) ]
            pub fn lverr(&self) -> LverrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                LverrR { bits }
            }
            # [ doc = "Bit 1 - Operand Error Flag" ]
            # [ inline ( always ) ]
            pub fn operr(&self) -> OperrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OperrR { bits }
            }
            # [ doc = "Bit 2 - Output data not available Error Flag" ]
            # [ inline ( always ) ]
            pub fn outerr(&self) -> OuterrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OuterrR { bits }
            }
            # [ doc = "Bit 3 - Operand Overwrite Error Flag" ]
            # [ inline ( always ) ]
            pub fn opoverr(&self) -> OpoverrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OpoverrR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Low Core Voltage Error Flag" ]
            # [ inline ( always ) ]
            pub fn lverr(&mut self) -> _LverrW {
                _LverrW { w: self }
            }
            # [ doc = "Bit 1 - Operand Error Flag" ]
            # [ inline ( always ) ]
            pub fn operr(&mut self) -> _OperrW {
                _OperrW { w: self }
            }
            # [ doc = "Bit 2 - Output data not available Error Flag" ]
            # [ inline ( always ) ]
            pub fn outerr(&mut self) -> _OuterrW {
                _OuterrW { w: self }
            }
            # [ doc = "Bit 3 - Operand Overwrite Error Flag" ]
            # [ inline ( always ) ]
            pub fn opoverr(&mut self) -> _OpoverrW {
                _OpoverrW { w: self }
            }
        }
    }
    # [ doc = "Radio interface error vector word register" ]
    pub struct Rf1aiferrv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio interface error vector word register" ]
    pub mod rf1aiferrv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aiferrv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio interface interrupt vector word register" ]
    pub struct Rf1aifiv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio interface interrupt vector word register" ]
    pub mod rf1aifiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aifiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio instruction word register" ]
    pub struct Rf1ainstrw {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio instruction word register" ]
    pub mod rf1ainstrw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1ainstrw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio instruction 1-byte register with autoread" ]
    pub struct Rf1ainstr1w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio instruction 1-byte register with autoread" ]
    pub mod rf1ainstr1w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1ainstr1w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio instruction 2-byte register with autoread" ]
    pub struct Rf1ainstr2w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio instruction 2-byte register with autoread" ]
    pub mod rf1ainstr2w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1ainstr2w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio word data in register" ]
    pub struct Rf1adinw {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio word data in register" ]
    pub mod rf1adinw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1adinw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio status word register without auto-read" ]
    pub struct Rf1astat0w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio status word register without auto-read" ]
    pub mod rf1astat0w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1astat0w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio status word register with 1-byte auto-read" ]
    pub struct Rf1astat1w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio status word register with 1-byte auto-read" ]
    pub mod rf1astat1w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1astat1w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio status word register with 2-byte auto-read" ]
    pub struct Rf1astat2w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio status word register with 2-byte auto-read" ]
    pub mod rf1astat2w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1astat2w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core word data out register without auto-read" ]
    pub struct Rf1adout0w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core word data out register without auto-read" ]
    pub mod rf1adout0w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1adout0w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core word data out register with 1-byte auto-read" ]
    pub struct Rf1adout1w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core word data out register with 1-byte auto-read" ]
    pub mod rf1adout1w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1adout1w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core word data out register with 2-byte auto-read" ]
    pub struct Rf1adout2w {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core word data out register with 2-byte auto-read" ]
    pub mod rf1adout2w {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1adout2w {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core signal input register" ]
    pub struct Rf1ain {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core signal input register" ]
    pub mod rf1ain {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1ain {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core interrupt flag register" ]
    pub struct Rf1aifg {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core interrupt flag register" ]
    pub mod rf1aifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core interrupt edge select register" ]
    pub struct Rf1aies {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core interrupt edge select register" ]
    pub mod rf1aies {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aies {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core interrupt enable register" ]
    pub struct Rf1aie {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core interrupt enable register" ]
    pub mod rf1aie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Radio core interrupt vector word register" ]
    pub struct Rf1aiv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Radio core interrupt vector word register" ]
    pub mod rf1aiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1aiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Direct receive FIFO access register" ]
    pub struct Rf1arxfifo {
        register: VolatileCell<u16>,
    }
    # [ doc = "Direct receive FIFO access register" ]
    pub mod rf1arxfifo {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1arxfifo {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Direct transmit FIFO access register" ]
    pub struct Rf1atxfifo {
        register: VolatileCell<u16>,
    }
    # [ doc = "Direct transmit FIFO access register" ]
    pub mod rf1atxfifo {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rf1atxfifo {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "CC1101 Radio Interface" ]
pub struct Cc1101RadioInterface {
    register_block: cc1101_radio_interface::RegisterBlock,
}
impl Deref for Cc1101RadioInterface {
    type Target = cc1101_radio_interface::RegisterBlock;
    fn deref(&self) -> &cc1101_radio_interface::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "CRC16" ]
pub const CRC16: Peripheral<Crc16> = unsafe { Peripheral::new(0) };
# [ doc = "CRC16" ]
pub mod crc16 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 336usize],
        # [ doc = "0x150 - CRC Data In Register" ]
        pub crcdi: Crcdi,
        # [ doc = "0x152 - CRC data in reverse byte Register" ]
        pub crcdirb: Crcdirb,
        # [ doc = "0x154 - CRC Initialisation Register and Result Register" ]
        pub crcinires: Crcinires,
        # [ doc = "0x156 - CRC reverse result Register" ]
        pub crcresr: Crcresr,
    }
    # [ doc = "CRC Data In Register" ]
    pub struct Crcdi {
        register: VolatileCell<u16>,
    }
    # [ doc = "CRC Data In Register" ]
    pub mod crcdi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Crcdi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "CRC data in reverse byte Register" ]
    pub struct Crcdirb {
        register: VolatileCell<u16>,
    }
    # [ doc = "CRC data in reverse byte Register" ]
    pub mod crcdirb {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Crcdirb {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "CRC Initialisation Register and Result Register" ]
    pub struct Crcinires {
        register: VolatileCell<u16>,
    }
    # [ doc = "CRC Initialisation Register and Result Register" ]
    pub mod crcinires {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Crcinires {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "CRC reverse result Register" ]
    pub struct Crcresr {
        register: VolatileCell<u16>,
    }
    # [ doc = "CRC reverse result Register" ]
    pub mod crcresr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Crcresr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "CRC16" ]
pub struct Crc16 {
    register_block: crc16::RegisterBlock,
}
impl Deref for Crc16 {
    type Target = crc16::RegisterBlock;
    fn deref(&self) -> &crc16::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "DMA" ]
pub const DMA: Peripheral<Dma> = unsafe { Peripheral::new(0) };
# [ doc = "DMA" ]
pub mod dma {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1280usize],
        # [ doc = "0x500 - DMA Module Control 0" ]
        pub dmactl0: Dmactl0,
        # [ doc = "0x502 - DMA Module Control 1" ]
        pub dmactl1: Dmactl1,
        # [ doc = "0x504 - DMA Module Control 2" ]
        pub dmactl2: Dmactl2,
        # [ doc = "0x506 - DMA Module Control 3" ]
        pub dmactl3: Dmactl3,
        # [ doc = "0x508 - DMA Module Control 4" ]
        pub dmactl4: Dmactl4,
        _reserved1: [u8; 4usize],
        # [ doc = "0x50e - DMA Interrupt Vector Word" ]
        pub dmaiv: Dmaiv,
        # [ doc = "0x510 - DMA Channel 0 Control" ]
        pub dma0ctl: Dma0ctl,
        # [ doc = "0x512 - DMA Channel 0 Source Address" ]
        pub dma0sa: Dma0sa,
        # [ doc = "0x516 - DMA Channel 0 Destination Address" ]
        pub dma0da: Dma0da,
        # [ doc = "0x51a - DMA Channel 0 Transfer Size" ]
        pub dma0sz: Dma0sz,
        _reserved2: [u8; 4usize],
        # [ doc = "0x520 - DMA Channel 1 Control" ]
        pub dma1ctl: Dma1ctl,
        # [ doc = "0x522 - DMA Channel 1 Source Address" ]
        pub dma1sa: Dma1sa,
        # [ doc = "0x526 - DMA Channel 1 Destination Address" ]
        pub dma1da: Dma1da,
        # [ doc = "0x52a - DMA Channel 1 Transfer Size" ]
        pub dma1sz: Dma1sz,
        _reserved3: [u8; 4usize],
        # [ doc = "0x530 - DMA Channel 2 Control" ]
        pub dma2ctl: Dma2ctl,
        # [ doc = "0x532 - DMA Channel 2 Source Address" ]
        pub dma2sa: Dma2sa,
        # [ doc = "0x536 - DMA Channel 2 Destination Address" ]
        pub dma2da: Dma2da,
        # [ doc = "0x53a - DMA Channel 2 Transfer Size" ]
        pub dma2sz: Dma2sz,
    }
    # [ doc = "DMA Module Control 0" ]
    pub struct Dmactl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Module Control 0" ]
    pub mod dmactl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dmactl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DMA0TSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Dma0tselR {
            # [ doc = "DMA channel 0 transfer select 0:  DMA_REQ (sw)" ]
            Dma0tsel0,
            # [ doc = "DMA channel 0 transfer select 1:  Timer0_A (TA0CCR0.IFG)" ]
            Dma0tsel1,
            # [ doc = "DMA channel 0 transfer select 2:  Timer0_A (TA0CCR2.IFG)" ]
            Dma0tsel2,
            # [ doc = "DMA channel 0 transfer select 3:  Timer1_A (TA1CCR0.IFG)" ]
            Dma0tsel3,
            # [ doc = "DMA channel 0 transfer select 4:  Timer1_A (TA1CCR2.IFG)" ]
            Dma0tsel4,
            # [ doc = "DMA channel 0 transfer select 5:  TimerB (TB0CCR0.IFG)" ]
            Dma0tsel5,
            # [ doc = "DMA channel 0 transfer select 6:  TimerB (TB0CCR2.IFG)" ]
            Dma0tsel6,
            # [ doc = "DMA channel 0 transfer select 7:  Reserved" ]
            Dma0tsel7,
            # [ doc = "DMA channel 0 transfer select 8:  Reserved" ]
            Dma0tsel8,
            # [ doc = "DMA channel 0 transfer select 9:  Reserved" ]
            Dma0tsel9,
            # [ doc = "DMA channel 0 transfer select 10: Reserved" ]
            Dma0tsel10,
            # [ doc = "DMA channel 0 transfer select 11: Reserved" ]
            Dma0tsel11,
            # [ doc = "DMA channel 0 transfer select 12: Reserved" ]
            Dma0tsel12,
            # [ doc = "DMA channel 0 transfer select 13: Reserved" ]
            Dma0tsel13,
            # [ doc = "DMA channel 0 transfer select 14: RFRXIFG" ]
            Dma0tsel14,
            # [ doc = "DMA channel 0 transfer select 15: RFTXIFG" ]
            Dma0tsel15,
            # [ doc = "DMA channel 0 transfer select 16: USCIA0 receive" ]
            Dma0tsel16,
            # [ doc = "DMA channel 0 transfer select 17: USCIA0 transmit" ]
            Dma0tsel17,
            # [ doc = "DMA channel 0 transfer select 18: USCIB0 receive" ]
            Dma0tsel18,
            # [ doc = "DMA channel 0 transfer select 19: USCIB0 transmit" ]
            Dma0tsel19,
            # [ doc = "DMA channel 0 transfer select 20: Reserved" ]
            Dma0tsel20,
            # [ doc = "DMA channel 0 transfer select 21: Reserved" ]
            Dma0tsel21,
            # [ doc = "DMA channel 0 transfer select 22: Reserved" ]
            Dma0tsel22,
            # [ doc = "DMA channel 0 transfer select 23: Reserved" ]
            Dma0tsel23,
            # [ doc = "DMA channel 0 transfer select 24: ADC12IFGx" ]
            Dma0tsel24,
            # [ doc = "DMA channel 0 transfer select 25: Reserved" ]
            Dma0tsel25,
            # [ doc = "DMA channel 0 transfer select 26: Reserved" ]
            Dma0tsel26,
            # [ doc = "DMA channel 0 transfer select 27: Reserved" ]
            Dma0tsel27,
            # [ doc = "DMA channel 0 transfer select 28: Reserved" ]
            Dma0tsel28,
            # [ doc = "DMA channel 0 transfer select 29: Multiplier ready" ]
            Dma0tsel29,
            # [ doc = "DMA channel 0 transfer select 30: previous DMA channel DMA2IFG" ]
            Dma0tsel30,
            # [ doc = "DMA channel 0 transfer select 31: ext. Trigger (DMAE0)" ]
            Dma0tsel31,
        }
        impl Dma0tselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Dma0tselR::Dma0tsel0 => 0,
                    Dma0tselR::Dma0tsel1 => 1,
                    Dma0tselR::Dma0tsel2 => 2,
                    Dma0tselR::Dma0tsel3 => 3,
                    Dma0tselR::Dma0tsel4 => 4,
                    Dma0tselR::Dma0tsel5 => 5,
                    Dma0tselR::Dma0tsel6 => 6,
                    Dma0tselR::Dma0tsel7 => 7,
                    Dma0tselR::Dma0tsel8 => 8,
                    Dma0tselR::Dma0tsel9 => 9,
                    Dma0tselR::Dma0tsel10 => 10,
                    Dma0tselR::Dma0tsel11 => 11,
                    Dma0tselR::Dma0tsel12 => 12,
                    Dma0tselR::Dma0tsel13 => 13,
                    Dma0tselR::Dma0tsel14 => 14,
                    Dma0tselR::Dma0tsel15 => 15,
                    Dma0tselR::Dma0tsel16 => 16,
                    Dma0tselR::Dma0tsel17 => 17,
                    Dma0tselR::Dma0tsel18 => 18,
                    Dma0tselR::Dma0tsel19 => 19,
                    Dma0tselR::Dma0tsel20 => 20,
                    Dma0tselR::Dma0tsel21 => 21,
                    Dma0tselR::Dma0tsel22 => 22,
                    Dma0tselR::Dma0tsel23 => 23,
                    Dma0tselR::Dma0tsel24 => 24,
                    Dma0tselR::Dma0tsel25 => 25,
                    Dma0tselR::Dma0tsel26 => 26,
                    Dma0tselR::Dma0tsel27 => 27,
                    Dma0tselR::Dma0tsel28 => 28,
                    Dma0tselR::Dma0tsel29 => 29,
                    Dma0tselR::Dma0tsel30 => 30,
                    Dma0tselR::Dma0tsel31 => 31,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Dma0tselR {
                match bits {
                    0 => Dma0tselR::Dma0tsel0,
                    1 => Dma0tselR::Dma0tsel1,
                    2 => Dma0tselR::Dma0tsel2,
                    3 => Dma0tselR::Dma0tsel3,
                    4 => Dma0tselR::Dma0tsel4,
                    5 => Dma0tselR::Dma0tsel5,
                    6 => Dma0tselR::Dma0tsel6,
                    7 => Dma0tselR::Dma0tsel7,
                    8 => Dma0tselR::Dma0tsel8,
                    9 => Dma0tselR::Dma0tsel9,
                    10 => Dma0tselR::Dma0tsel10,
                    11 => Dma0tselR::Dma0tsel11,
                    12 => Dma0tselR::Dma0tsel12,
                    13 => Dma0tselR::Dma0tsel13,
                    14 => Dma0tselR::Dma0tsel14,
                    15 => Dma0tselR::Dma0tsel15,
                    16 => Dma0tselR::Dma0tsel16,
                    17 => Dma0tselR::Dma0tsel17,
                    18 => Dma0tselR::Dma0tsel18,
                    19 => Dma0tselR::Dma0tsel19,
                    20 => Dma0tselR::Dma0tsel20,
                    21 => Dma0tselR::Dma0tsel21,
                    22 => Dma0tselR::Dma0tsel22,
                    23 => Dma0tselR::Dma0tsel23,
                    24 => Dma0tselR::Dma0tsel24,
                    25 => Dma0tselR::Dma0tsel25,
                    26 => Dma0tselR::Dma0tsel26,
                    27 => Dma0tselR::Dma0tsel27,
                    28 => Dma0tselR::Dma0tsel28,
                    29 => Dma0tselR::Dma0tsel29,
                    30 => Dma0tselR::Dma0tsel30,
                    31 => Dma0tselR::Dma0tsel31,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel0`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_0(&self) -> bool {
                *self == Dma0tselR::Dma0tsel0
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel1`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_1(&self) -> bool {
                *self == Dma0tselR::Dma0tsel1
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel2`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_2(&self) -> bool {
                *self == Dma0tselR::Dma0tsel2
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel3`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_3(&self) -> bool {
                *self == Dma0tselR::Dma0tsel3
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel4`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_4(&self) -> bool {
                *self == Dma0tselR::Dma0tsel4
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel5`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_5(&self) -> bool {
                *self == Dma0tselR::Dma0tsel5
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel6`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_6(&self) -> bool {
                *self == Dma0tselR::Dma0tsel6
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel7`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_7(&self) -> bool {
                *self == Dma0tselR::Dma0tsel7
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel8`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_8(&self) -> bool {
                *self == Dma0tselR::Dma0tsel8
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel9`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_9(&self) -> bool {
                *self == Dma0tselR::Dma0tsel9
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel10`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_10(&self) -> bool {
                *self == Dma0tselR::Dma0tsel10
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel11`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_11(&self) -> bool {
                *self == Dma0tselR::Dma0tsel11
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel12`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_12(&self) -> bool {
                *self == Dma0tselR::Dma0tsel12
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel13`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_13(&self) -> bool {
                *self == Dma0tselR::Dma0tsel13
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel14`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_14(&self) -> bool {
                *self == Dma0tselR::Dma0tsel14
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel15`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_15(&self) -> bool {
                *self == Dma0tselR::Dma0tsel15
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel16`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_16(&self) -> bool {
                *self == Dma0tselR::Dma0tsel16
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel17`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_17(&self) -> bool {
                *self == Dma0tselR::Dma0tsel17
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel18`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_18(&self) -> bool {
                *self == Dma0tselR::Dma0tsel18
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel19`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_19(&self) -> bool {
                *self == Dma0tselR::Dma0tsel19
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel20`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_20(&self) -> bool {
                *self == Dma0tselR::Dma0tsel20
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel21`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_21(&self) -> bool {
                *self == Dma0tselR::Dma0tsel21
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel22`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_22(&self) -> bool {
                *self == Dma0tselR::Dma0tsel22
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel23`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_23(&self) -> bool {
                *self == Dma0tselR::Dma0tsel23
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel24`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_24(&self) -> bool {
                *self == Dma0tselR::Dma0tsel24
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel25`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_25(&self) -> bool {
                *self == Dma0tselR::Dma0tsel25
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel26`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_26(&self) -> bool {
                *self == Dma0tselR::Dma0tsel26
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel27`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_27(&self) -> bool {
                *self == Dma0tselR::Dma0tsel27
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel28`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_28(&self) -> bool {
                *self == Dma0tselR::Dma0tsel28
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel29`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_29(&self) -> bool {
                *self == Dma0tselR::Dma0tsel29
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel30`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_30(&self) -> bool {
                *self == Dma0tselR::Dma0tsel30
            }
            # [ doc = "Checks if the value of the field is `Dma0tsel31`" ]
            # [ inline ( always ) ]
            pub fn is_dma0tsel_31(&self) -> bool {
                *self == Dma0tselR::Dma0tsel31
            }
        }
        # [ doc = "Possible values of the field `DMA1TSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Dma1tselR {
            # [ doc = "DMA channel 1 transfer select 0:  DMA_REQ (sw)" ]
            Dma1tsel0,
            # [ doc = "DMA channel 1 transfer select 1:  Timer0_A (TA0CCR0.IFG)" ]
            Dma1tsel1,
            # [ doc = "DMA channel 1 transfer select 2:  Timer0_A (TA0CCR2.IFG)" ]
            Dma1tsel2,
            # [ doc = "DMA channel 1 transfer select 3:  Timer1_A (TA1CCR0.IFG)" ]
            Dma1tsel3,
            # [ doc = "DMA channel 1 transfer select 4:  Timer1_A (TA1CCR2.IFG)" ]
            Dma1tsel4,
            # [ doc = "DMA channel 1 transfer select 5:  TimerB (TB0CCR0.IFG)" ]
            Dma1tsel5,
            # [ doc = "DMA channel 1 transfer select 6:  TimerB (TB0CCR2.IFG)" ]
            Dma1tsel6,
            # [ doc = "DMA channel 1 transfer select 7:  Reserved" ]
            Dma1tsel7,
            # [ doc = "DMA channel 1 transfer select 8:  Reserved" ]
            Dma1tsel8,
            # [ doc = "DMA channel 1 transfer select 9:  Reserved" ]
            Dma1tsel9,
            # [ doc = "DMA channel 1 transfer select 10: Reserved" ]
            Dma1tsel10,
            # [ doc = "DMA channel 1 transfer select 11: Reserved" ]
            Dma1tsel11,
            # [ doc = "DMA channel 1 transfer select 12: Reserved" ]
            Dma1tsel12,
            # [ doc = "DMA channel 1 transfer select 13: Reserved" ]
            Dma1tsel13,
            # [ doc = "DMA channel 1 transfer select 14: RFRXIFG" ]
            Dma1tsel14,
            # [ doc = "DMA channel 1 transfer select 15: RFTXIFG" ]
            Dma1tsel15,
            # [ doc = "DMA channel 1 transfer select 16: USCIA0 receive" ]
            Dma1tsel16,
            # [ doc = "DMA channel 1 transfer select 17: USCIA0 transmit" ]
            Dma1tsel17,
            # [ doc = "DMA channel 1 transfer select 18: USCIB0 receive" ]
            Dma1tsel18,
            # [ doc = "DMA channel 1 transfer select 19: USCIB0 transmit" ]
            Dma1tsel19,
            # [ doc = "DMA channel 1 transfer select 20: Reserved" ]
            Dma1tsel20,
            # [ doc = "DMA channel 1 transfer select 21: Reserved" ]
            Dma1tsel21,
            # [ doc = "DMA channel 1 transfer select 22: Reserved" ]
            Dma1tsel22,
            # [ doc = "DMA channel 1 transfer select 23: Reserved" ]
            Dma1tsel23,
            # [ doc = "DMA channel 1 transfer select 24: ADC12IFGx" ]
            Dma1tsel24,
            # [ doc = "DMA channel 1 transfer select 25: Reserved" ]
            Dma1tsel25,
            # [ doc = "DMA channel 1 transfer select 26: Reserved" ]
            Dma1tsel26,
            # [ doc = "DMA channel 1 transfer select 27: Reserved" ]
            Dma1tsel27,
            # [ doc = "DMA channel 1 transfer select 28: Reserved" ]
            Dma1tsel28,
            # [ doc = "DMA channel 1 transfer select 29: Multiplier ready" ]
            Dma1tsel29,
            # [ doc = "DMA channel 1 transfer select 30: previous DMA channel DMA0IFG" ]
            Dma1tsel30,
            # [ doc = "DMA channel 1 transfer select 31: ext. Trigger (DMAE0)" ]
            Dma1tsel31,
        }
        impl Dma1tselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Dma1tselR::Dma1tsel0 => 0,
                    Dma1tselR::Dma1tsel1 => 1,
                    Dma1tselR::Dma1tsel2 => 2,
                    Dma1tselR::Dma1tsel3 => 3,
                    Dma1tselR::Dma1tsel4 => 4,
                    Dma1tselR::Dma1tsel5 => 5,
                    Dma1tselR::Dma1tsel6 => 6,
                    Dma1tselR::Dma1tsel7 => 7,
                    Dma1tselR::Dma1tsel8 => 8,
                    Dma1tselR::Dma1tsel9 => 9,
                    Dma1tselR::Dma1tsel10 => 10,
                    Dma1tselR::Dma1tsel11 => 11,
                    Dma1tselR::Dma1tsel12 => 12,
                    Dma1tselR::Dma1tsel13 => 13,
                    Dma1tselR::Dma1tsel14 => 14,
                    Dma1tselR::Dma1tsel15 => 15,
                    Dma1tselR::Dma1tsel16 => 16,
                    Dma1tselR::Dma1tsel17 => 17,
                    Dma1tselR::Dma1tsel18 => 18,
                    Dma1tselR::Dma1tsel19 => 19,
                    Dma1tselR::Dma1tsel20 => 20,
                    Dma1tselR::Dma1tsel21 => 21,
                    Dma1tselR::Dma1tsel22 => 22,
                    Dma1tselR::Dma1tsel23 => 23,
                    Dma1tselR::Dma1tsel24 => 24,
                    Dma1tselR::Dma1tsel25 => 25,
                    Dma1tselR::Dma1tsel26 => 26,
                    Dma1tselR::Dma1tsel27 => 27,
                    Dma1tselR::Dma1tsel28 => 28,
                    Dma1tselR::Dma1tsel29 => 29,
                    Dma1tselR::Dma1tsel30 => 30,
                    Dma1tselR::Dma1tsel31 => 31,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Dma1tselR {
                match bits {
                    0 => Dma1tselR::Dma1tsel0,
                    1 => Dma1tselR::Dma1tsel1,
                    2 => Dma1tselR::Dma1tsel2,
                    3 => Dma1tselR::Dma1tsel3,
                    4 => Dma1tselR::Dma1tsel4,
                    5 => Dma1tselR::Dma1tsel5,
                    6 => Dma1tselR::Dma1tsel6,
                    7 => Dma1tselR::Dma1tsel7,
                    8 => Dma1tselR::Dma1tsel8,
                    9 => Dma1tselR::Dma1tsel9,
                    10 => Dma1tselR::Dma1tsel10,
                    11 => Dma1tselR::Dma1tsel11,
                    12 => Dma1tselR::Dma1tsel12,
                    13 => Dma1tselR::Dma1tsel13,
                    14 => Dma1tselR::Dma1tsel14,
                    15 => Dma1tselR::Dma1tsel15,
                    16 => Dma1tselR::Dma1tsel16,
                    17 => Dma1tselR::Dma1tsel17,
                    18 => Dma1tselR::Dma1tsel18,
                    19 => Dma1tselR::Dma1tsel19,
                    20 => Dma1tselR::Dma1tsel20,
                    21 => Dma1tselR::Dma1tsel21,
                    22 => Dma1tselR::Dma1tsel22,
                    23 => Dma1tselR::Dma1tsel23,
                    24 => Dma1tselR::Dma1tsel24,
                    25 => Dma1tselR::Dma1tsel25,
                    26 => Dma1tselR::Dma1tsel26,
                    27 => Dma1tselR::Dma1tsel27,
                    28 => Dma1tselR::Dma1tsel28,
                    29 => Dma1tselR::Dma1tsel29,
                    30 => Dma1tselR::Dma1tsel30,
                    31 => Dma1tselR::Dma1tsel31,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel0`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_0(&self) -> bool {
                *self == Dma1tselR::Dma1tsel0
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel1`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_1(&self) -> bool {
                *self == Dma1tselR::Dma1tsel1
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel2`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_2(&self) -> bool {
                *self == Dma1tselR::Dma1tsel2
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel3`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_3(&self) -> bool {
                *self == Dma1tselR::Dma1tsel3
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel4`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_4(&self) -> bool {
                *self == Dma1tselR::Dma1tsel4
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel5`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_5(&self) -> bool {
                *self == Dma1tselR::Dma1tsel5
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel6`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_6(&self) -> bool {
                *self == Dma1tselR::Dma1tsel6
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel7`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_7(&self) -> bool {
                *self == Dma1tselR::Dma1tsel7
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel8`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_8(&self) -> bool {
                *self == Dma1tselR::Dma1tsel8
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel9`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_9(&self) -> bool {
                *self == Dma1tselR::Dma1tsel9
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel10`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_10(&self) -> bool {
                *self == Dma1tselR::Dma1tsel10
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel11`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_11(&self) -> bool {
                *self == Dma1tselR::Dma1tsel11
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel12`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_12(&self) -> bool {
                *self == Dma1tselR::Dma1tsel12
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel13`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_13(&self) -> bool {
                *self == Dma1tselR::Dma1tsel13
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel14`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_14(&self) -> bool {
                *self == Dma1tselR::Dma1tsel14
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel15`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_15(&self) -> bool {
                *self == Dma1tselR::Dma1tsel15
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel16`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_16(&self) -> bool {
                *self == Dma1tselR::Dma1tsel16
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel17`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_17(&self) -> bool {
                *self == Dma1tselR::Dma1tsel17
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel18`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_18(&self) -> bool {
                *self == Dma1tselR::Dma1tsel18
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel19`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_19(&self) -> bool {
                *self == Dma1tselR::Dma1tsel19
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel20`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_20(&self) -> bool {
                *self == Dma1tselR::Dma1tsel20
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel21`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_21(&self) -> bool {
                *self == Dma1tselR::Dma1tsel21
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel22`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_22(&self) -> bool {
                *self == Dma1tselR::Dma1tsel22
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel23`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_23(&self) -> bool {
                *self == Dma1tselR::Dma1tsel23
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel24`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_24(&self) -> bool {
                *self == Dma1tselR::Dma1tsel24
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel25`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_25(&self) -> bool {
                *self == Dma1tselR::Dma1tsel25
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel26`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_26(&self) -> bool {
                *self == Dma1tselR::Dma1tsel26
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel27`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_27(&self) -> bool {
                *self == Dma1tselR::Dma1tsel27
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel28`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_28(&self) -> bool {
                *self == Dma1tselR::Dma1tsel28
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel29`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_29(&self) -> bool {
                *self == Dma1tselR::Dma1tsel29
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel30`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_30(&self) -> bool {
                *self == Dma1tselR::Dma1tsel30
            }
            # [ doc = "Checks if the value of the field is `Dma1tsel31`" ]
            # [ inline ( always ) ]
            pub fn is_dma1tsel_31(&self) -> bool {
                *self == Dma1tselR::Dma1tsel31
            }
        }
        # [ doc = "Values that can be written to the field `DMA0TSEL`" ]
        pub enum Dma0tselW {
            # [ doc = "DMA channel 0 transfer select 0:  DMA_REQ (sw)" ]
            Dma0tsel0,
            # [ doc = "DMA channel 0 transfer select 1:  Timer0_A (TA0CCR0.IFG)" ]
            Dma0tsel1,
            # [ doc = "DMA channel 0 transfer select 2:  Timer0_A (TA0CCR2.IFG)" ]
            Dma0tsel2,
            # [ doc = "DMA channel 0 transfer select 3:  Timer1_A (TA1CCR0.IFG)" ]
            Dma0tsel3,
            # [ doc = "DMA channel 0 transfer select 4:  Timer1_A (TA1CCR2.IFG)" ]
            Dma0tsel4,
            # [ doc = "DMA channel 0 transfer select 5:  TimerB (TB0CCR0.IFG)" ]
            Dma0tsel5,
            # [ doc = "DMA channel 0 transfer select 6:  TimerB (TB0CCR2.IFG)" ]
            Dma0tsel6,
            # [ doc = "DMA channel 0 transfer select 7:  Reserved" ]
            Dma0tsel7,
            # [ doc = "DMA channel 0 transfer select 8:  Reserved" ]
            Dma0tsel8,
            # [ doc = "DMA channel 0 transfer select 9:  Reserved" ]
            Dma0tsel9,
            # [ doc = "DMA channel 0 transfer select 10: Reserved" ]
            Dma0tsel10,
            # [ doc = "DMA channel 0 transfer select 11: Reserved" ]
            Dma0tsel11,
            # [ doc = "DMA channel 0 transfer select 12: Reserved" ]
            Dma0tsel12,
            # [ doc = "DMA channel 0 transfer select 13: Reserved" ]
            Dma0tsel13,
            # [ doc = "DMA channel 0 transfer select 14: RFRXIFG" ]
            Dma0tsel14,
            # [ doc = "DMA channel 0 transfer select 15: RFTXIFG" ]
            Dma0tsel15,
            # [ doc = "DMA channel 0 transfer select 16: USCIA0 receive" ]
            Dma0tsel16,
            # [ doc = "DMA channel 0 transfer select 17: USCIA0 transmit" ]
            Dma0tsel17,
            # [ doc = "DMA channel 0 transfer select 18: USCIB0 receive" ]
            Dma0tsel18,
            # [ doc = "DMA channel 0 transfer select 19: USCIB0 transmit" ]
            Dma0tsel19,
            # [ doc = "DMA channel 0 transfer select 20: Reserved" ]
            Dma0tsel20,
            # [ doc = "DMA channel 0 transfer select 21: Reserved" ]
            Dma0tsel21,
            # [ doc = "DMA channel 0 transfer select 22: Reserved" ]
            Dma0tsel22,
            # [ doc = "DMA channel 0 transfer select 23: Reserved" ]
            Dma0tsel23,
            # [ doc = "DMA channel 0 transfer select 24: ADC12IFGx" ]
            Dma0tsel24,
            # [ doc = "DMA channel 0 transfer select 25: Reserved" ]
            Dma0tsel25,
            # [ doc = "DMA channel 0 transfer select 26: Reserved" ]
            Dma0tsel26,
            # [ doc = "DMA channel 0 transfer select 27: Reserved" ]
            Dma0tsel27,
            # [ doc = "DMA channel 0 transfer select 28: Reserved" ]
            Dma0tsel28,
            # [ doc = "DMA channel 0 transfer select 29: Multiplier ready" ]
            Dma0tsel29,
            # [ doc = "DMA channel 0 transfer select 30: previous DMA channel DMA2IFG" ]
            Dma0tsel30,
            # [ doc = "DMA channel 0 transfer select 31: ext. Trigger (DMAE0)" ]
            Dma0tsel31,
        }
        impl Dma0tselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Dma0tselW::Dma0tsel0 => 0,
                    Dma0tselW::Dma0tsel1 => 1,
                    Dma0tselW::Dma0tsel2 => 2,
                    Dma0tselW::Dma0tsel3 => 3,
                    Dma0tselW::Dma0tsel4 => 4,
                    Dma0tselW::Dma0tsel5 => 5,
                    Dma0tselW::Dma0tsel6 => 6,
                    Dma0tselW::Dma0tsel7 => 7,
                    Dma0tselW::Dma0tsel8 => 8,
                    Dma0tselW::Dma0tsel9 => 9,
                    Dma0tselW::Dma0tsel10 => 10,
                    Dma0tselW::Dma0tsel11 => 11,
                    Dma0tselW::Dma0tsel12 => 12,
                    Dma0tselW::Dma0tsel13 => 13,
                    Dma0tselW::Dma0tsel14 => 14,
                    Dma0tselW::Dma0tsel15 => 15,
                    Dma0tselW::Dma0tsel16 => 16,
                    Dma0tselW::Dma0tsel17 => 17,
                    Dma0tselW::Dma0tsel18 => 18,
                    Dma0tselW::Dma0tsel19 => 19,
                    Dma0tselW::Dma0tsel20 => 20,
                    Dma0tselW::Dma0tsel21 => 21,
                    Dma0tselW::Dma0tsel22 => 22,
                    Dma0tselW::Dma0tsel23 => 23,
                    Dma0tselW::Dma0tsel24 => 24,
                    Dma0tselW::Dma0tsel25 => 25,
                    Dma0tselW::Dma0tsel26 => 26,
                    Dma0tselW::Dma0tsel27 => 27,
                    Dma0tselW::Dma0tsel28 => 28,
                    Dma0tselW::Dma0tsel29 => 29,
                    Dma0tselW::Dma0tsel30 => 30,
                    Dma0tselW::Dma0tsel31 => 31,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dma0tselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dma0tselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Dma0tselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA channel 0 transfer select 0: DMA_REQ (sw)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_0(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel0)
            }
            # [ doc = "DMA channel 0 transfer select 1: Timer0_A (TA0CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_1(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel1)
            }
            # [ doc = "DMA channel 0 transfer select 2: Timer0_A (TA0CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_2(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel2)
            }
            # [ doc = "DMA channel 0 transfer select 3: Timer1_A (TA1CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_3(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel3)
            }
            # [ doc = "DMA channel 0 transfer select 4: Timer1_A (TA1CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_4(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel4)
            }
            # [ doc = "DMA channel 0 transfer select 5: TimerB (TB0CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_5(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel5)
            }
            # [ doc = "DMA channel 0 transfer select 6: TimerB (TB0CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_6(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel6)
            }
            # [ doc = "DMA channel 0 transfer select 7: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_7(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel7)
            }
            # [ doc = "DMA channel 0 transfer select 8: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_8(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel8)
            }
            # [ doc = "DMA channel 0 transfer select 9: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_9(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel9)
            }
            # [ doc = "DMA channel 0 transfer select 10: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_10(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel10)
            }
            # [ doc = "DMA channel 0 transfer select 11: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_11(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel11)
            }
            # [ doc = "DMA channel 0 transfer select 12: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_12(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel12)
            }
            # [ doc = "DMA channel 0 transfer select 13: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_13(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel13)
            }
            # [ doc = "DMA channel 0 transfer select 14: RFRXIFG" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_14(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel14)
            }
            # [ doc = "DMA channel 0 transfer select 15: RFTXIFG" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_15(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel15)
            }
            # [ doc = "DMA channel 0 transfer select 16: USCIA0 receive" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_16(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel16)
            }
            # [ doc = "DMA channel 0 transfer select 17: USCIA0 transmit" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_17(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel17)
            }
            # [ doc = "DMA channel 0 transfer select 18: USCIB0 receive" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_18(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel18)
            }
            # [ doc = "DMA channel 0 transfer select 19: USCIB0 transmit" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_19(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel19)
            }
            # [ doc = "DMA channel 0 transfer select 20: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_20(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel20)
            }
            # [ doc = "DMA channel 0 transfer select 21: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_21(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel21)
            }
            # [ doc = "DMA channel 0 transfer select 22: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_22(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel22)
            }
            # [ doc = "DMA channel 0 transfer select 23: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_23(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel23)
            }
            # [ doc = "DMA channel 0 transfer select 24: ADC12IFGx" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_24(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel24)
            }
            # [ doc = "DMA channel 0 transfer select 25: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_25(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel25)
            }
            # [ doc = "DMA channel 0 transfer select 26: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_26(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel26)
            }
            # [ doc = "DMA channel 0 transfer select 27: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_27(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel27)
            }
            # [ doc = "DMA channel 0 transfer select 28: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_28(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel28)
            }
            # [ doc = "DMA channel 0 transfer select 29: Multiplier ready" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_29(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel29)
            }
            # [ doc = "DMA channel 0 transfer select 30: previous DMA channel DMA2IFG" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_30(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel30)
            }
            # [ doc = "DMA channel 0 transfer select 31: ext. Trigger (DMAE0)" ]
            # [ inline ( always ) ]
            pub fn dma0tsel_31(self) -> &'a mut W {
                self.variant(Dma0tselW::Dma0tsel31)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMA1TSEL`" ]
        pub enum Dma1tselW {
            # [ doc = "DMA channel 1 transfer select 0:  DMA_REQ (sw)" ]
            Dma1tsel0,
            # [ doc = "DMA channel 1 transfer select 1:  Timer0_A (TA0CCR0.IFG)" ]
            Dma1tsel1,
            # [ doc = "DMA channel 1 transfer select 2:  Timer0_A (TA0CCR2.IFG)" ]
            Dma1tsel2,
            # [ doc = "DMA channel 1 transfer select 3:  Timer1_A (TA1CCR0.IFG)" ]
            Dma1tsel3,
            # [ doc = "DMA channel 1 transfer select 4:  Timer1_A (TA1CCR2.IFG)" ]
            Dma1tsel4,
            # [ doc = "DMA channel 1 transfer select 5:  TimerB (TB0CCR0.IFG)" ]
            Dma1tsel5,
            # [ doc = "DMA channel 1 transfer select 6:  TimerB (TB0CCR2.IFG)" ]
            Dma1tsel6,
            # [ doc = "DMA channel 1 transfer select 7:  Reserved" ]
            Dma1tsel7,
            # [ doc = "DMA channel 1 transfer select 8:  Reserved" ]
            Dma1tsel8,
            # [ doc = "DMA channel 1 transfer select 9:  Reserved" ]
            Dma1tsel9,
            # [ doc = "DMA channel 1 transfer select 10: Reserved" ]
            Dma1tsel10,
            # [ doc = "DMA channel 1 transfer select 11: Reserved" ]
            Dma1tsel11,
            # [ doc = "DMA channel 1 transfer select 12: Reserved" ]
            Dma1tsel12,
            # [ doc = "DMA channel 1 transfer select 13: Reserved" ]
            Dma1tsel13,
            # [ doc = "DMA channel 1 transfer select 14: RFRXIFG" ]
            Dma1tsel14,
            # [ doc = "DMA channel 1 transfer select 15: RFTXIFG" ]
            Dma1tsel15,
            # [ doc = "DMA channel 1 transfer select 16: USCIA0 receive" ]
            Dma1tsel16,
            # [ doc = "DMA channel 1 transfer select 17: USCIA0 transmit" ]
            Dma1tsel17,
            # [ doc = "DMA channel 1 transfer select 18: USCIB0 receive" ]
            Dma1tsel18,
            # [ doc = "DMA channel 1 transfer select 19: USCIB0 transmit" ]
            Dma1tsel19,
            # [ doc = "DMA channel 1 transfer select 20: Reserved" ]
            Dma1tsel20,
            # [ doc = "DMA channel 1 transfer select 21: Reserved" ]
            Dma1tsel21,
            # [ doc = "DMA channel 1 transfer select 22: Reserved" ]
            Dma1tsel22,
            # [ doc = "DMA channel 1 transfer select 23: Reserved" ]
            Dma1tsel23,
            # [ doc = "DMA channel 1 transfer select 24: ADC12IFGx" ]
            Dma1tsel24,
            # [ doc = "DMA channel 1 transfer select 25: Reserved" ]
            Dma1tsel25,
            # [ doc = "DMA channel 1 transfer select 26: Reserved" ]
            Dma1tsel26,
            # [ doc = "DMA channel 1 transfer select 27: Reserved" ]
            Dma1tsel27,
            # [ doc = "DMA channel 1 transfer select 28: Reserved" ]
            Dma1tsel28,
            # [ doc = "DMA channel 1 transfer select 29: Multiplier ready" ]
            Dma1tsel29,
            # [ doc = "DMA channel 1 transfer select 30: previous DMA channel DMA0IFG" ]
            Dma1tsel30,
            # [ doc = "DMA channel 1 transfer select 31: ext. Trigger (DMAE0)" ]
            Dma1tsel31,
        }
        impl Dma1tselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Dma1tselW::Dma1tsel0 => 0,
                    Dma1tselW::Dma1tsel1 => 1,
                    Dma1tselW::Dma1tsel2 => 2,
                    Dma1tselW::Dma1tsel3 => 3,
                    Dma1tselW::Dma1tsel4 => 4,
                    Dma1tselW::Dma1tsel5 => 5,
                    Dma1tselW::Dma1tsel6 => 6,
                    Dma1tselW::Dma1tsel7 => 7,
                    Dma1tselW::Dma1tsel8 => 8,
                    Dma1tselW::Dma1tsel9 => 9,
                    Dma1tselW::Dma1tsel10 => 10,
                    Dma1tselW::Dma1tsel11 => 11,
                    Dma1tselW::Dma1tsel12 => 12,
                    Dma1tselW::Dma1tsel13 => 13,
                    Dma1tselW::Dma1tsel14 => 14,
                    Dma1tselW::Dma1tsel15 => 15,
                    Dma1tselW::Dma1tsel16 => 16,
                    Dma1tselW::Dma1tsel17 => 17,
                    Dma1tselW::Dma1tsel18 => 18,
                    Dma1tselW::Dma1tsel19 => 19,
                    Dma1tselW::Dma1tsel20 => 20,
                    Dma1tselW::Dma1tsel21 => 21,
                    Dma1tselW::Dma1tsel22 => 22,
                    Dma1tselW::Dma1tsel23 => 23,
                    Dma1tselW::Dma1tsel24 => 24,
                    Dma1tselW::Dma1tsel25 => 25,
                    Dma1tselW::Dma1tsel26 => 26,
                    Dma1tselW::Dma1tsel27 => 27,
                    Dma1tselW::Dma1tsel28 => 28,
                    Dma1tselW::Dma1tsel29 => 29,
                    Dma1tselW::Dma1tsel30 => 30,
                    Dma1tselW::Dma1tsel31 => 31,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dma1tselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dma1tselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Dma1tselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA channel 1 transfer select 0: DMA_REQ (sw)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_0(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel0)
            }
            # [ doc = "DMA channel 1 transfer select 1: Timer0_A (TA0CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_1(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel1)
            }
            # [ doc = "DMA channel 1 transfer select 2: Timer0_A (TA0CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_2(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel2)
            }
            # [ doc = "DMA channel 1 transfer select 3: Timer1_A (TA1CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_3(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel3)
            }
            # [ doc = "DMA channel 1 transfer select 4: Timer1_A (TA1CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_4(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel4)
            }
            # [ doc = "DMA channel 1 transfer select 5: TimerB (TB0CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_5(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel5)
            }
            # [ doc = "DMA channel 1 transfer select 6: TimerB (TB0CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_6(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel6)
            }
            # [ doc = "DMA channel 1 transfer select 7: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_7(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel7)
            }
            # [ doc = "DMA channel 1 transfer select 8: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_8(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel8)
            }
            # [ doc = "DMA channel 1 transfer select 9: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_9(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel9)
            }
            # [ doc = "DMA channel 1 transfer select 10: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_10(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel10)
            }
            # [ doc = "DMA channel 1 transfer select 11: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_11(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel11)
            }
            # [ doc = "DMA channel 1 transfer select 12: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_12(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel12)
            }
            # [ doc = "DMA channel 1 transfer select 13: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_13(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel13)
            }
            # [ doc = "DMA channel 1 transfer select 14: RFRXIFG" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_14(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel14)
            }
            # [ doc = "DMA channel 1 transfer select 15: RFTXIFG" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_15(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel15)
            }
            # [ doc = "DMA channel 1 transfer select 16: USCIA0 receive" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_16(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel16)
            }
            # [ doc = "DMA channel 1 transfer select 17: USCIA0 transmit" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_17(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel17)
            }
            # [ doc = "DMA channel 1 transfer select 18: USCIB0 receive" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_18(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel18)
            }
            # [ doc = "DMA channel 1 transfer select 19: USCIB0 transmit" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_19(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel19)
            }
            # [ doc = "DMA channel 1 transfer select 20: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_20(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel20)
            }
            # [ doc = "DMA channel 1 transfer select 21: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_21(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel21)
            }
            # [ doc = "DMA channel 1 transfer select 22: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_22(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel22)
            }
            # [ doc = "DMA channel 1 transfer select 23: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_23(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel23)
            }
            # [ doc = "DMA channel 1 transfer select 24: ADC12IFGx" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_24(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel24)
            }
            # [ doc = "DMA channel 1 transfer select 25: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_25(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel25)
            }
            # [ doc = "DMA channel 1 transfer select 26: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_26(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel26)
            }
            # [ doc = "DMA channel 1 transfer select 27: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_27(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel27)
            }
            # [ doc = "DMA channel 1 transfer select 28: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_28(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel28)
            }
            # [ doc = "DMA channel 1 transfer select 29: Multiplier ready" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_29(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel29)
            }
            # [ doc = "DMA channel 1 transfer select 30: previous DMA channel DMA0IFG" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_30(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel30)
            }
            # [ doc = "DMA channel 1 transfer select 31: ext. Trigger (DMAE0)" ]
            # [ inline ( always ) ]
            pub fn dma1tsel_31(self) -> &'a mut W {
                self.variant(Dma1tselW::Dma1tsel31)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 4:8 - DMA channel 0 transfer select bit 0" ]
            # [ inline ( always ) ]
            pub fn dma0tsel(&self) -> Dma0tselR {
                Dma0tselR::_from({
                                     const MASK: u8 = 31;
                                     const OFFSET: u8 = 4;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bits 12:16 - DMA channel 1 transfer select bit 0" ]
            # [ inline ( always ) ]
            pub fn dma1tsel(&self) -> Dma1tselR {
                Dma1tselR::_from({
                                     const MASK: u8 = 31;
                                     const OFFSET: u8 = 12;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:8 - DMA channel 0 transfer select bit 0" ]
            # [ inline ( always ) ]
            pub fn dma0tsel(&mut self) -> _Dma0tselW {
                _Dma0tselW { w: self }
            }
            # [ doc = "Bits 12:16 - DMA channel 1 transfer select bit 0" ]
            # [ inline ( always ) ]
            pub fn dma1tsel(&mut self) -> _Dma1tselW {
                _Dma1tselW { w: self }
            }
        }
    }
    # [ doc = "DMA Module Control 1" ]
    pub struct Dmactl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Module Control 1" ]
    pub mod dmactl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dmactl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DMA2TSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Dma2tselR {
            # [ doc = "DMA channel 2 transfer select 0:  DMA_REQ (sw)" ]
            Dma2tsel0,
            # [ doc = "DMA channel 2 transfer select 1:  Timer0_A (TA0CCR0.IFG)" ]
            Dma2tsel1,
            # [ doc = "DMA channel 2 transfer select 2:  Timer0_A (TA0CCR2.IFG)" ]
            Dma2tsel2,
            # [ doc = "DMA channel 2 transfer select 3:  Timer1_A (TA1CCR0.IFG)" ]
            Dma2tsel3,
            # [ doc = "DMA channel 2 transfer select 4:  Timer1_A (TA1CCR2.IFG)" ]
            Dma2tsel4,
            # [ doc = "DMA channel 2 transfer select 5:  TimerB (TB0CCR0.IFG)" ]
            Dma2tsel5,
            # [ doc = "DMA channel 2 transfer select 6:  TimerB (TB0CCR2.IFG)" ]
            Dma2tsel6,
            # [ doc = "DMA channel 2 transfer select 7:  Reserved" ]
            Dma2tsel7,
            # [ doc = "DMA channel 2 transfer select 8:  Reserved" ]
            Dma2tsel8,
            # [ doc = "DMA channel 2 transfer select 9:  Reserved" ]
            Dma2tsel9,
            # [ doc = "DMA channel 2 transfer select 10: Reserved" ]
            Dma2tsel10,
            # [ doc = "DMA channel 2 transfer select 11: Reserved" ]
            Dma2tsel11,
            # [ doc = "DMA channel 2 transfer select 12: Reserved" ]
            Dma2tsel12,
            # [ doc = "DMA channel 2 transfer select 13: Reserved" ]
            Dma2tsel13,
            # [ doc = "DMA channel 2 transfer select 14: RFRXIFG" ]
            Dma2tsel14,
            # [ doc = "DMA channel 2 transfer select 15: RFTXIFG" ]
            Dma2tsel15,
            # [ doc = "DMA channel 2 transfer select 16: USCIA0 receive" ]
            Dma2tsel16,
            # [ doc = "DMA channel 2 transfer select 17: USCIA0 transmit" ]
            Dma2tsel17,
            # [ doc = "DMA channel 2 transfer select 18: USCIB0 receive" ]
            Dma2tsel18,
            # [ doc = "DMA channel 2 transfer select 19: USCIB0 transmit" ]
            Dma2tsel19,
            # [ doc = "DMA channel 2 transfer select 20: Reserved" ]
            Dma2tsel20,
            # [ doc = "DMA channel 2 transfer select 21: Reserved" ]
            Dma2tsel21,
            # [ doc = "DMA channel 2 transfer select 22: Reserved" ]
            Dma2tsel22,
            # [ doc = "DMA channel 2 transfer select 23: Reserved" ]
            Dma2tsel23,
            # [ doc = "DMA channel 2 transfer select 24: ADC12IFGx" ]
            Dma2tsel24,
            # [ doc = "DMA channel 2 transfer select 25: Reserved" ]
            Dma2tsel25,
            # [ doc = "DMA channel 2 transfer select 26: Reserved" ]
            Dma2tsel26,
            # [ doc = "DMA channel 2 transfer select 27: Reserved" ]
            Dma2tsel27,
            # [ doc = "DMA channel 2 transfer select 28: Reserved" ]
            Dma2tsel28,
            # [ doc = "DMA channel 2 transfer select 29: Multiplier ready" ]
            Dma2tsel29,
            # [ doc = "DMA channel 2 transfer select 30: previous DMA channel DMA1IFG" ]
            Dma2tsel30,
            # [ doc = "DMA channel 2 transfer select 31: ext. Trigger (DMAE0)" ]
            Dma2tsel31,
        }
        impl Dma2tselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Dma2tselR::Dma2tsel0 => 0,
                    Dma2tselR::Dma2tsel1 => 1,
                    Dma2tselR::Dma2tsel2 => 2,
                    Dma2tselR::Dma2tsel3 => 3,
                    Dma2tselR::Dma2tsel4 => 4,
                    Dma2tselR::Dma2tsel5 => 5,
                    Dma2tselR::Dma2tsel6 => 6,
                    Dma2tselR::Dma2tsel7 => 7,
                    Dma2tselR::Dma2tsel8 => 8,
                    Dma2tselR::Dma2tsel9 => 9,
                    Dma2tselR::Dma2tsel10 => 10,
                    Dma2tselR::Dma2tsel11 => 11,
                    Dma2tselR::Dma2tsel12 => 12,
                    Dma2tselR::Dma2tsel13 => 13,
                    Dma2tselR::Dma2tsel14 => 14,
                    Dma2tselR::Dma2tsel15 => 15,
                    Dma2tselR::Dma2tsel16 => 16,
                    Dma2tselR::Dma2tsel17 => 17,
                    Dma2tselR::Dma2tsel18 => 18,
                    Dma2tselR::Dma2tsel19 => 19,
                    Dma2tselR::Dma2tsel20 => 20,
                    Dma2tselR::Dma2tsel21 => 21,
                    Dma2tselR::Dma2tsel22 => 22,
                    Dma2tselR::Dma2tsel23 => 23,
                    Dma2tselR::Dma2tsel24 => 24,
                    Dma2tselR::Dma2tsel25 => 25,
                    Dma2tselR::Dma2tsel26 => 26,
                    Dma2tselR::Dma2tsel27 => 27,
                    Dma2tselR::Dma2tsel28 => 28,
                    Dma2tselR::Dma2tsel29 => 29,
                    Dma2tselR::Dma2tsel30 => 30,
                    Dma2tselR::Dma2tsel31 => 31,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Dma2tselR {
                match bits {
                    0 => Dma2tselR::Dma2tsel0,
                    1 => Dma2tselR::Dma2tsel1,
                    2 => Dma2tselR::Dma2tsel2,
                    3 => Dma2tselR::Dma2tsel3,
                    4 => Dma2tselR::Dma2tsel4,
                    5 => Dma2tselR::Dma2tsel5,
                    6 => Dma2tselR::Dma2tsel6,
                    7 => Dma2tselR::Dma2tsel7,
                    8 => Dma2tselR::Dma2tsel8,
                    9 => Dma2tselR::Dma2tsel9,
                    10 => Dma2tselR::Dma2tsel10,
                    11 => Dma2tselR::Dma2tsel11,
                    12 => Dma2tselR::Dma2tsel12,
                    13 => Dma2tselR::Dma2tsel13,
                    14 => Dma2tselR::Dma2tsel14,
                    15 => Dma2tselR::Dma2tsel15,
                    16 => Dma2tselR::Dma2tsel16,
                    17 => Dma2tselR::Dma2tsel17,
                    18 => Dma2tselR::Dma2tsel18,
                    19 => Dma2tselR::Dma2tsel19,
                    20 => Dma2tselR::Dma2tsel20,
                    21 => Dma2tselR::Dma2tsel21,
                    22 => Dma2tselR::Dma2tsel22,
                    23 => Dma2tselR::Dma2tsel23,
                    24 => Dma2tselR::Dma2tsel24,
                    25 => Dma2tselR::Dma2tsel25,
                    26 => Dma2tselR::Dma2tsel26,
                    27 => Dma2tselR::Dma2tsel27,
                    28 => Dma2tselR::Dma2tsel28,
                    29 => Dma2tselR::Dma2tsel29,
                    30 => Dma2tselR::Dma2tsel30,
                    31 => Dma2tselR::Dma2tsel31,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel0`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_0(&self) -> bool {
                *self == Dma2tselR::Dma2tsel0
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel1`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_1(&self) -> bool {
                *self == Dma2tselR::Dma2tsel1
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel2`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_2(&self) -> bool {
                *self == Dma2tselR::Dma2tsel2
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel3`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_3(&self) -> bool {
                *self == Dma2tselR::Dma2tsel3
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel4`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_4(&self) -> bool {
                *self == Dma2tselR::Dma2tsel4
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel5`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_5(&self) -> bool {
                *self == Dma2tselR::Dma2tsel5
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel6`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_6(&self) -> bool {
                *self == Dma2tselR::Dma2tsel6
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel7`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_7(&self) -> bool {
                *self == Dma2tselR::Dma2tsel7
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel8`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_8(&self) -> bool {
                *self == Dma2tselR::Dma2tsel8
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel9`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_9(&self) -> bool {
                *self == Dma2tselR::Dma2tsel9
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel10`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_10(&self) -> bool {
                *self == Dma2tselR::Dma2tsel10
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel11`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_11(&self) -> bool {
                *self == Dma2tselR::Dma2tsel11
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel12`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_12(&self) -> bool {
                *self == Dma2tselR::Dma2tsel12
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel13`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_13(&self) -> bool {
                *self == Dma2tselR::Dma2tsel13
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel14`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_14(&self) -> bool {
                *self == Dma2tselR::Dma2tsel14
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel15`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_15(&self) -> bool {
                *self == Dma2tselR::Dma2tsel15
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel16`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_16(&self) -> bool {
                *self == Dma2tselR::Dma2tsel16
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel17`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_17(&self) -> bool {
                *self == Dma2tselR::Dma2tsel17
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel18`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_18(&self) -> bool {
                *self == Dma2tselR::Dma2tsel18
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel19`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_19(&self) -> bool {
                *self == Dma2tselR::Dma2tsel19
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel20`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_20(&self) -> bool {
                *self == Dma2tselR::Dma2tsel20
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel21`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_21(&self) -> bool {
                *self == Dma2tselR::Dma2tsel21
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel22`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_22(&self) -> bool {
                *self == Dma2tselR::Dma2tsel22
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel23`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_23(&self) -> bool {
                *self == Dma2tselR::Dma2tsel23
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel24`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_24(&self) -> bool {
                *self == Dma2tselR::Dma2tsel24
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel25`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_25(&self) -> bool {
                *self == Dma2tselR::Dma2tsel25
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel26`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_26(&self) -> bool {
                *self == Dma2tselR::Dma2tsel26
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel27`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_27(&self) -> bool {
                *self == Dma2tselR::Dma2tsel27
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel28`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_28(&self) -> bool {
                *self == Dma2tselR::Dma2tsel28
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel29`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_29(&self) -> bool {
                *self == Dma2tselR::Dma2tsel29
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel30`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_30(&self) -> bool {
                *self == Dma2tselR::Dma2tsel30
            }
            # [ doc = "Checks if the value of the field is `Dma2tsel31`" ]
            # [ inline ( always ) ]
            pub fn is_dma2tsel_31(&self) -> bool {
                *self == Dma2tselR::Dma2tsel31
            }
        }
        # [ doc = "Values that can be written to the field `DMA2TSEL`" ]
        pub enum Dma2tselW {
            # [ doc = "DMA channel 2 transfer select 0:  DMA_REQ (sw)" ]
            Dma2tsel0,
            # [ doc = "DMA channel 2 transfer select 1:  Timer0_A (TA0CCR0.IFG)" ]
            Dma2tsel1,
            # [ doc = "DMA channel 2 transfer select 2:  Timer0_A (TA0CCR2.IFG)" ]
            Dma2tsel2,
            # [ doc = "DMA channel 2 transfer select 3:  Timer1_A (TA1CCR0.IFG)" ]
            Dma2tsel3,
            # [ doc = "DMA channel 2 transfer select 4:  Timer1_A (TA1CCR2.IFG)" ]
            Dma2tsel4,
            # [ doc = "DMA channel 2 transfer select 5:  TimerB (TB0CCR0.IFG)" ]
            Dma2tsel5,
            # [ doc = "DMA channel 2 transfer select 6:  TimerB (TB0CCR2.IFG)" ]
            Dma2tsel6,
            # [ doc = "DMA channel 2 transfer select 7:  Reserved" ]
            Dma2tsel7,
            # [ doc = "DMA channel 2 transfer select 8:  Reserved" ]
            Dma2tsel8,
            # [ doc = "DMA channel 2 transfer select 9:  Reserved" ]
            Dma2tsel9,
            # [ doc = "DMA channel 2 transfer select 10: Reserved" ]
            Dma2tsel10,
            # [ doc = "DMA channel 2 transfer select 11: Reserved" ]
            Dma2tsel11,
            # [ doc = "DMA channel 2 transfer select 12: Reserved" ]
            Dma2tsel12,
            # [ doc = "DMA channel 2 transfer select 13: Reserved" ]
            Dma2tsel13,
            # [ doc = "DMA channel 2 transfer select 14: RFRXIFG" ]
            Dma2tsel14,
            # [ doc = "DMA channel 2 transfer select 15: RFTXIFG" ]
            Dma2tsel15,
            # [ doc = "DMA channel 2 transfer select 16: USCIA0 receive" ]
            Dma2tsel16,
            # [ doc = "DMA channel 2 transfer select 17: USCIA0 transmit" ]
            Dma2tsel17,
            # [ doc = "DMA channel 2 transfer select 18: USCIB0 receive" ]
            Dma2tsel18,
            # [ doc = "DMA channel 2 transfer select 19: USCIB0 transmit" ]
            Dma2tsel19,
            # [ doc = "DMA channel 2 transfer select 20: Reserved" ]
            Dma2tsel20,
            # [ doc = "DMA channel 2 transfer select 21: Reserved" ]
            Dma2tsel21,
            # [ doc = "DMA channel 2 transfer select 22: Reserved" ]
            Dma2tsel22,
            # [ doc = "DMA channel 2 transfer select 23: Reserved" ]
            Dma2tsel23,
            # [ doc = "DMA channel 2 transfer select 24: ADC12IFGx" ]
            Dma2tsel24,
            # [ doc = "DMA channel 2 transfer select 25: Reserved" ]
            Dma2tsel25,
            # [ doc = "DMA channel 2 transfer select 26: Reserved" ]
            Dma2tsel26,
            # [ doc = "DMA channel 2 transfer select 27: Reserved" ]
            Dma2tsel27,
            # [ doc = "DMA channel 2 transfer select 28: Reserved" ]
            Dma2tsel28,
            # [ doc = "DMA channel 2 transfer select 29: Multiplier ready" ]
            Dma2tsel29,
            # [ doc = "DMA channel 2 transfer select 30: previous DMA channel DMA1IFG" ]
            Dma2tsel30,
            # [ doc = "DMA channel 2 transfer select 31: ext. Trigger (DMAE0)" ]
            Dma2tsel31,
        }
        impl Dma2tselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Dma2tselW::Dma2tsel0 => 0,
                    Dma2tselW::Dma2tsel1 => 1,
                    Dma2tselW::Dma2tsel2 => 2,
                    Dma2tselW::Dma2tsel3 => 3,
                    Dma2tselW::Dma2tsel4 => 4,
                    Dma2tselW::Dma2tsel5 => 5,
                    Dma2tselW::Dma2tsel6 => 6,
                    Dma2tselW::Dma2tsel7 => 7,
                    Dma2tselW::Dma2tsel8 => 8,
                    Dma2tselW::Dma2tsel9 => 9,
                    Dma2tselW::Dma2tsel10 => 10,
                    Dma2tselW::Dma2tsel11 => 11,
                    Dma2tselW::Dma2tsel12 => 12,
                    Dma2tselW::Dma2tsel13 => 13,
                    Dma2tselW::Dma2tsel14 => 14,
                    Dma2tselW::Dma2tsel15 => 15,
                    Dma2tselW::Dma2tsel16 => 16,
                    Dma2tselW::Dma2tsel17 => 17,
                    Dma2tselW::Dma2tsel18 => 18,
                    Dma2tselW::Dma2tsel19 => 19,
                    Dma2tselW::Dma2tsel20 => 20,
                    Dma2tselW::Dma2tsel21 => 21,
                    Dma2tselW::Dma2tsel22 => 22,
                    Dma2tselW::Dma2tsel23 => 23,
                    Dma2tselW::Dma2tsel24 => 24,
                    Dma2tselW::Dma2tsel25 => 25,
                    Dma2tselW::Dma2tsel26 => 26,
                    Dma2tselW::Dma2tsel27 => 27,
                    Dma2tselW::Dma2tsel28 => 28,
                    Dma2tselW::Dma2tsel29 => 29,
                    Dma2tselW::Dma2tsel30 => 30,
                    Dma2tselW::Dma2tsel31 => 31,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dma2tselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dma2tselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Dma2tselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA channel 2 transfer select 0: DMA_REQ (sw)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_0(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel0)
            }
            # [ doc = "DMA channel 2 transfer select 1: Timer0_A (TA0CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_1(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel1)
            }
            # [ doc = "DMA channel 2 transfer select 2: Timer0_A (TA0CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_2(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel2)
            }
            # [ doc = "DMA channel 2 transfer select 3: Timer1_A (TA1CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_3(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel3)
            }
            # [ doc = "DMA channel 2 transfer select 4: Timer1_A (TA1CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_4(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel4)
            }
            # [ doc = "DMA channel 2 transfer select 5: TimerB (TB0CCR0.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_5(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel5)
            }
            # [ doc = "DMA channel 2 transfer select 6: TimerB (TB0CCR2.IFG)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_6(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel6)
            }
            # [ doc = "DMA channel 2 transfer select 7: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_7(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel7)
            }
            # [ doc = "DMA channel 2 transfer select 8: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_8(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel8)
            }
            # [ doc = "DMA channel 2 transfer select 9: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_9(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel9)
            }
            # [ doc = "DMA channel 2 transfer select 10: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_10(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel10)
            }
            # [ doc = "DMA channel 2 transfer select 11: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_11(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel11)
            }
            # [ doc = "DMA channel 2 transfer select 12: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_12(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel12)
            }
            # [ doc = "DMA channel 2 transfer select 13: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_13(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel13)
            }
            # [ doc = "DMA channel 2 transfer select 14: RFRXIFG" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_14(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel14)
            }
            # [ doc = "DMA channel 2 transfer select 15: RFTXIFG" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_15(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel15)
            }
            # [ doc = "DMA channel 2 transfer select 16: USCIA0 receive" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_16(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel16)
            }
            # [ doc = "DMA channel 2 transfer select 17: USCIA0 transmit" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_17(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel17)
            }
            # [ doc = "DMA channel 2 transfer select 18: USCIB0 receive" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_18(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel18)
            }
            # [ doc = "DMA channel 2 transfer select 19: USCIB0 transmit" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_19(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel19)
            }
            # [ doc = "DMA channel 2 transfer select 20: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_20(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel20)
            }
            # [ doc = "DMA channel 2 transfer select 21: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_21(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel21)
            }
            # [ doc = "DMA channel 2 transfer select 22: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_22(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel22)
            }
            # [ doc = "DMA channel 2 transfer select 23: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_23(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel23)
            }
            # [ doc = "DMA channel 2 transfer select 24: ADC12IFGx" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_24(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel24)
            }
            # [ doc = "DMA channel 2 transfer select 25: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_25(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel25)
            }
            # [ doc = "DMA channel 2 transfer select 26: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_26(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel26)
            }
            # [ doc = "DMA channel 2 transfer select 27: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_27(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel27)
            }
            # [ doc = "DMA channel 2 transfer select 28: Reserved" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_28(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel28)
            }
            # [ doc = "DMA channel 2 transfer select 29: Multiplier ready" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_29(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel29)
            }
            # [ doc = "DMA channel 2 transfer select 30: previous DMA channel DMA1IFG" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_30(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel30)
            }
            # [ doc = "DMA channel 2 transfer select 31: ext. Trigger (DMAE0)" ]
            # [ inline ( always ) ]
            pub fn dma2tsel_31(self) -> &'a mut W {
                self.variant(Dma2tselW::Dma2tsel31)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 4:8 - DMA channel 2 transfer select bit 0" ]
            # [ inline ( always ) ]
            pub fn dma2tsel(&self) -> Dma2tselR {
                Dma2tselR::_from({
                                     const MASK: u8 = 31;
                                     const OFFSET: u8 = 4;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 4:8 - DMA channel 2 transfer select bit 0" ]
            # [ inline ( always ) ]
            pub fn dma2tsel(&mut self) -> _Dma2tselW {
                _Dma2tselW { w: self }
            }
        }
    }
    # [ doc = "DMA Module Control 2" ]
    pub struct Dmactl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Module Control 2" ]
    pub mod dmactl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dmactl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Module Control 3" ]
    pub struct Dmactl3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Module Control 3" ]
    pub mod dmactl3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dmactl3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Module Control 4" ]
    pub struct Dmactl4 {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Module Control 4" ]
    pub mod dmactl4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dmactl4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EnnmiR {
            bits: u8,
        }
        impl EnnmiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RoundrobinR {
            bits: u8,
        }
        impl RoundrobinR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmarmwdisR {
            bits: u8,
        }
        impl DmarmwdisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EnnmiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnnmiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RoundrobinW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RoundrobinW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmarmwdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmarmwdisW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Enable NMI interruption of DMA" ]
            # [ inline ( always ) ]
            pub fn ennmi(&self) -> EnnmiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                EnnmiR { bits }
            }
            # [ doc = "Bit 1 - Round-Robin DMA channel priorities" ]
            # [ inline ( always ) ]
            pub fn roundrobin(&self) -> RoundrobinR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RoundrobinR { bits }
            }
            # [ doc = "Bit 2 - Inhibited DMA transfers during read-modify-write CPU operations" ]
            # [ inline ( always ) ]
            pub fn dmarmwdis(&self) -> DmarmwdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmarmwdisR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Enable NMI interruption of DMA" ]
            # [ inline ( always ) ]
            pub fn ennmi(&mut self) -> _EnnmiW {
                _EnnmiW { w: self }
            }
            # [ doc = "Bit 1 - Round-Robin DMA channel priorities" ]
            # [ inline ( always ) ]
            pub fn roundrobin(&mut self) -> _RoundrobinW {
                _RoundrobinW { w: self }
            }
            # [ doc = "Bit 2 - Inhibited DMA transfers during read-modify-write CPU operations" ]
            # [ inline ( always ) ]
            pub fn dmarmwdis(&mut self) -> _DmarmwdisW {
                _DmarmwdisW { w: self }
            }
        }
    }
    # [ doc = "DMA Interrupt Vector Word" ]
    pub struct Dmaiv {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Interrupt Vector Word" ]
    pub mod dmaiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dmaiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 0 Control" ]
    pub struct Dma0ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Channel 0 Control" ]
    pub mod dma0ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dma0ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmareqR {
            bits: u8,
        }
        impl DmareqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaabortR {
            bits: u8,
        }
        impl DmaabortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaieR {
            bits: u8,
        }
        impl DmaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaifgR {
            bits: u8,
        }
        impl DmaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaenR {
            bits: u8,
        }
        impl DmaenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmalevelR {
            bits: u8,
        }
        impl DmalevelR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmasrcbyteR {
            bits: u8,
        }
        impl DmasrcbyteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmadstbyteR {
            bits: u8,
        }
        impl DmadstbyteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `DMASRCINCR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmasrcincrR {
            # [ doc = "DMA source increment 0: source address unchanged" ]
            Dmasrcincr0,
            # [ doc = "DMA source increment 1: source address unchanged" ]
            Dmasrcincr1,
            # [ doc = "DMA source increment 2: source address decremented" ]
            Dmasrcincr2,
            # [ doc = "DMA source increment 3: source address incremented" ]
            Dmasrcincr3,
        }
        impl DmasrcincrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmasrcincrR::Dmasrcincr0 => 0,
                    DmasrcincrR::Dmasrcincr1 => 1,
                    DmasrcincrR::Dmasrcincr2 => 2,
                    DmasrcincrR::Dmasrcincr3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmasrcincrR {
                match bits {
                    0 => DmasrcincrR::Dmasrcincr0,
                    1 => DmasrcincrR::Dmasrcincr1,
                    2 => DmasrcincrR::Dmasrcincr2,
                    3 => DmasrcincrR::Dmasrcincr3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr0`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_0(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr0
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr1`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_1(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr1
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr2`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_2(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr2
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr3`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_3(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr3
            }
        }
        # [ doc = "Possible values of the field `DMADSTINCR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmadstincrR {
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            Dmadstincr0,
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            Dmadstincr1,
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            Dmadstincr2,
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            Dmadstincr3,
        }
        impl DmadstincrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmadstincrR::Dmadstincr0 => 0,
                    DmadstincrR::Dmadstincr1 => 1,
                    DmadstincrR::Dmadstincr2 => 2,
                    DmadstincrR::Dmadstincr3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmadstincrR {
                match bits {
                    0 => DmadstincrR::Dmadstincr0,
                    1 => DmadstincrR::Dmadstincr1,
                    2 => DmadstincrR::Dmadstincr2,
                    3 => DmadstincrR::Dmadstincr3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr0`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_0(&self) -> bool {
                *self == DmadstincrR::Dmadstincr0
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr1`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_1(&self) -> bool {
                *self == DmadstincrR::Dmadstincr1
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr2`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_2(&self) -> bool {
                *self == DmadstincrR::Dmadstincr2
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr3`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_3(&self) -> bool {
                *self == DmadstincrR::Dmadstincr3
            }
        }
        # [ doc = "Possible values of the field `DMADT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmadtR {
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            Dmadt0,
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            Dmadt1,
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            Dmadt2,
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            Dmadt3,
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            Dmadt4,
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            Dmadt5,
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            Dmadt6,
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            Dmadt7,
        }
        impl DmadtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmadtR::Dmadt0 => 0,
                    DmadtR::Dmadt1 => 1,
                    DmadtR::Dmadt2 => 2,
                    DmadtR::Dmadt3 => 3,
                    DmadtR::Dmadt4 => 4,
                    DmadtR::Dmadt5 => 5,
                    DmadtR::Dmadt6 => 6,
                    DmadtR::Dmadt7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmadtR {
                match bits {
                    0 => DmadtR::Dmadt0,
                    1 => DmadtR::Dmadt1,
                    2 => DmadtR::Dmadt2,
                    3 => DmadtR::Dmadt3,
                    4 => DmadtR::Dmadt4,
                    5 => DmadtR::Dmadt5,
                    6 => DmadtR::Dmadt6,
                    7 => DmadtR::Dmadt7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmadt0`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_0(&self) -> bool {
                *self == DmadtR::Dmadt0
            }
            # [ doc = "Checks if the value of the field is `Dmadt1`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_1(&self) -> bool {
                *self == DmadtR::Dmadt1
            }
            # [ doc = "Checks if the value of the field is `Dmadt2`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_2(&self) -> bool {
                *self == DmadtR::Dmadt2
            }
            # [ doc = "Checks if the value of the field is `Dmadt3`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_3(&self) -> bool {
                *self == DmadtR::Dmadt3
            }
            # [ doc = "Checks if the value of the field is `Dmadt4`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_4(&self) -> bool {
                *self == DmadtR::Dmadt4
            }
            # [ doc = "Checks if the value of the field is `Dmadt5`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_5(&self) -> bool {
                *self == DmadtR::Dmadt5
            }
            # [ doc = "Checks if the value of the field is `Dmadt6`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_6(&self) -> bool {
                *self == DmadtR::Dmadt6
            }
            # [ doc = "Checks if the value of the field is `Dmadt7`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_7(&self) -> bool {
                *self == DmadtR::Dmadt7
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmareqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmareqW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaabortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaabortW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmalevelW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmalevelW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmasrcbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmasrcbyteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadstbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadstbyteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMASRCINCR`" ]
        pub enum DmasrcincrW {
            # [ doc = "DMA source increment 0: source address unchanged" ]
            Dmasrcincr0,
            # [ doc = "DMA source increment 1: source address unchanged" ]
            Dmasrcincr1,
            # [ doc = "DMA source increment 2: source address decremented" ]
            Dmasrcincr2,
            # [ doc = "DMA source increment 3: source address incremented" ]
            Dmasrcincr3,
        }
        impl DmasrcincrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmasrcincrW::Dmasrcincr0 => 0,
                    DmasrcincrW::Dmasrcincr1 => 1,
                    DmasrcincrW::Dmasrcincr2 => 2,
                    DmasrcincrW::Dmasrcincr3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmasrcincrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmasrcincrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmasrcincrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA source increment 0: source address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_0(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr0)
            }
            # [ doc = "DMA source increment 1: source address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_1(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr1)
            }
            # [ doc = "DMA source increment 2: source address decremented" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_2(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr2)
            }
            # [ doc = "DMA source increment 3: source address incremented" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_3(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMADSTINCR`" ]
        pub enum DmadstincrW {
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            Dmadstincr0,
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            Dmadstincr1,
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            Dmadstincr2,
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            Dmadstincr3,
        }
        impl DmadstincrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmadstincrW::Dmadstincr0 => 0,
                    DmadstincrW::Dmadstincr1 => 1,
                    DmadstincrW::Dmadstincr2 => 2,
                    DmadstincrW::Dmadstincr3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadstincrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadstincrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmadstincrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_0(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr0)
            }
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_1(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr1)
            }
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_2(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr2)
            }
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_3(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMADT`" ]
        pub enum DmadtW {
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            Dmadt0,
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            Dmadt1,
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            Dmadt2,
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            Dmadt3,
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            Dmadt4,
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            Dmadt5,
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            Dmadt6,
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            Dmadt7,
        }
        impl DmadtW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmadtW::Dmadt0 => 0,
                    DmadtW::Dmadt1 => 1,
                    DmadtW::Dmadt2 => 2,
                    DmadtW::Dmadt3 => 3,
                    DmadtW::Dmadt4 => 4,
                    DmadtW::Dmadt5 => 5,
                    DmadtW::Dmadt6 => 6,
                    DmadtW::Dmadt7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadtW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmadtW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_0(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt0)
            }
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_1(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt1)
            }
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_2(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt2)
            }
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_3(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt3)
            }
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_4(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt4)
            }
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_5(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt5)
            }
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_6(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt6)
            }
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_7(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Initiate DMA transfer with DMATSEL" ]
            # [ inline ( always ) ]
            pub fn dmareq(&self) -> DmareqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmareqR { bits }
            }
            # [ doc = "Bit 1 - DMA transfer aborted by NMI" ]
            # [ inline ( always ) ]
            pub fn dmaabort(&self) -> DmaabortR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaabortR { bits }
            }
            # [ doc = "Bit 2 - DMA interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaie(&self) -> DmaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaieR { bits }
            }
            # [ doc = "Bit 3 - DMA interrupt flag" ]
            # [ inline ( always ) ]
            pub fn dmaifg(&self) -> DmaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaifgR { bits }
            }
            # [ doc = "Bit 4 - DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&self) -> DmaenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaenR { bits }
            }
            # [ doc = "Bit 5 - DMA level sensitive trigger select" ]
            # [ inline ( always ) ]
            pub fn dmalevel(&self) -> DmalevelR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmalevelR { bits }
            }
            # [ doc = "Bit 6 - DMA source byte" ]
            # [ inline ( always ) ]
            pub fn dmasrcbyte(&self) -> DmasrcbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmasrcbyteR { bits }
            }
            # [ doc = "Bit 7 - DMA destination byte" ]
            # [ inline ( always ) ]
            pub fn dmadstbyte(&self) -> DmadstbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmadstbyteR { bits }
            }
            # [ doc = "Bits 9:10 - DMA source increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr(&self) -> DmasrcincrR {
                DmasrcincrR::_from({
                                       const MASK: u8 = 3;
                                       const OFFSET: u8 = 9;
                                       ((self.bits >> OFFSET) & MASK as u16) as u8
                                   })
            }
            # [ doc = "Bits 11:12 - DMA destination increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadstincr(&self) -> DmadstincrR {
                DmadstincrR::_from({
                                       const MASK: u8 = 3;
                                       const OFFSET: u8 = 11;
                                       ((self.bits >> OFFSET) & MASK as u16) as u8
                                   })
            }
            # [ doc = "Bits 14:16 - DMA transfer mode bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadt(&self) -> DmadtR {
                DmadtR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 14;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Initiate DMA transfer with DMATSEL" ]
            # [ inline ( always ) ]
            pub fn dmareq(&mut self) -> _DmareqW {
                _DmareqW { w: self }
            }
            # [ doc = "Bit 1 - DMA transfer aborted by NMI" ]
            # [ inline ( always ) ]
            pub fn dmaabort(&mut self) -> _DmaabortW {
                _DmaabortW { w: self }
            }
            # [ doc = "Bit 2 - DMA interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaie(&mut self) -> _DmaieW {
                _DmaieW { w: self }
            }
            # [ doc = "Bit 3 - DMA interrupt flag" ]
            # [ inline ( always ) ]
            pub fn dmaifg(&mut self) -> _DmaifgW {
                _DmaifgW { w: self }
            }
            # [ doc = "Bit 4 - DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&mut self) -> _DmaenW {
                _DmaenW { w: self }
            }
            # [ doc = "Bit 5 - DMA level sensitive trigger select" ]
            # [ inline ( always ) ]
            pub fn dmalevel(&mut self) -> _DmalevelW {
                _DmalevelW { w: self }
            }
            # [ doc = "Bit 6 - DMA source byte" ]
            # [ inline ( always ) ]
            pub fn dmasrcbyte(&mut self) -> _DmasrcbyteW {
                _DmasrcbyteW { w: self }
            }
            # [ doc = "Bit 7 - DMA destination byte" ]
            # [ inline ( always ) ]
            pub fn dmadstbyte(&mut self) -> _DmadstbyteW {
                _DmadstbyteW { w: self }
            }
            # [ doc = "Bits 9:10 - DMA source increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr(&mut self) -> _DmasrcincrW {
                _DmasrcincrW { w: self }
            }
            # [ doc = "Bits 11:12 - DMA destination increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadstincr(&mut self) -> _DmadstincrW {
                _DmadstincrW { w: self }
            }
            # [ doc = "Bits 14:16 - DMA transfer mode bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadt(&mut self) -> _DmadtW {
                _DmadtW { w: self }
            }
        }
    }
    # [ doc = "DMA Channel 0 Source Address" ]
    pub struct Dma0sa {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA Channel 0 Source Address" ]
    pub mod dma0sa {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dma0sa {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 0 Destination Address" ]
    pub struct Dma0da {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA Channel 0 Destination Address" ]
    pub mod dma0da {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dma0da {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 0 Transfer Size" ]
    pub struct Dma0sz {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Channel 0 Transfer Size" ]
    pub mod dma0sz {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dma0sz {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 1 Control" ]
    pub struct Dma1ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Channel 1 Control" ]
    pub mod dma1ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dma1ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmareqR {
            bits: u8,
        }
        impl DmareqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaabortR {
            bits: u8,
        }
        impl DmaabortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaieR {
            bits: u8,
        }
        impl DmaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaifgR {
            bits: u8,
        }
        impl DmaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaenR {
            bits: u8,
        }
        impl DmaenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmalevelR {
            bits: u8,
        }
        impl DmalevelR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmasrcbyteR {
            bits: u8,
        }
        impl DmasrcbyteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmadstbyteR {
            bits: u8,
        }
        impl DmadstbyteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `DMASRCINCR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmasrcincrR {
            # [ doc = "DMA source increment 0: source address unchanged" ]
            Dmasrcincr0,
            # [ doc = "DMA source increment 1: source address unchanged" ]
            Dmasrcincr1,
            # [ doc = "DMA source increment 2: source address decremented" ]
            Dmasrcincr2,
            # [ doc = "DMA source increment 3: source address incremented" ]
            Dmasrcincr3,
        }
        impl DmasrcincrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmasrcincrR::Dmasrcincr0 => 0,
                    DmasrcincrR::Dmasrcincr1 => 1,
                    DmasrcincrR::Dmasrcincr2 => 2,
                    DmasrcincrR::Dmasrcincr3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmasrcincrR {
                match bits {
                    0 => DmasrcincrR::Dmasrcincr0,
                    1 => DmasrcincrR::Dmasrcincr1,
                    2 => DmasrcincrR::Dmasrcincr2,
                    3 => DmasrcincrR::Dmasrcincr3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr0`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_0(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr0
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr1`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_1(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr1
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr2`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_2(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr2
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr3`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_3(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr3
            }
        }
        # [ doc = "Possible values of the field `DMADSTINCR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmadstincrR {
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            Dmadstincr0,
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            Dmadstincr1,
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            Dmadstincr2,
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            Dmadstincr3,
        }
        impl DmadstincrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmadstincrR::Dmadstincr0 => 0,
                    DmadstincrR::Dmadstincr1 => 1,
                    DmadstincrR::Dmadstincr2 => 2,
                    DmadstincrR::Dmadstincr3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmadstincrR {
                match bits {
                    0 => DmadstincrR::Dmadstincr0,
                    1 => DmadstincrR::Dmadstincr1,
                    2 => DmadstincrR::Dmadstincr2,
                    3 => DmadstincrR::Dmadstincr3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr0`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_0(&self) -> bool {
                *self == DmadstincrR::Dmadstincr0
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr1`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_1(&self) -> bool {
                *self == DmadstincrR::Dmadstincr1
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr2`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_2(&self) -> bool {
                *self == DmadstincrR::Dmadstincr2
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr3`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_3(&self) -> bool {
                *self == DmadstincrR::Dmadstincr3
            }
        }
        # [ doc = "Possible values of the field `DMADT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmadtR {
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            Dmadt0,
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            Dmadt1,
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            Dmadt2,
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            Dmadt3,
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            Dmadt4,
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            Dmadt5,
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            Dmadt6,
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            Dmadt7,
        }
        impl DmadtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmadtR::Dmadt0 => 0,
                    DmadtR::Dmadt1 => 1,
                    DmadtR::Dmadt2 => 2,
                    DmadtR::Dmadt3 => 3,
                    DmadtR::Dmadt4 => 4,
                    DmadtR::Dmadt5 => 5,
                    DmadtR::Dmadt6 => 6,
                    DmadtR::Dmadt7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmadtR {
                match bits {
                    0 => DmadtR::Dmadt0,
                    1 => DmadtR::Dmadt1,
                    2 => DmadtR::Dmadt2,
                    3 => DmadtR::Dmadt3,
                    4 => DmadtR::Dmadt4,
                    5 => DmadtR::Dmadt5,
                    6 => DmadtR::Dmadt6,
                    7 => DmadtR::Dmadt7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmadt0`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_0(&self) -> bool {
                *self == DmadtR::Dmadt0
            }
            # [ doc = "Checks if the value of the field is `Dmadt1`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_1(&self) -> bool {
                *self == DmadtR::Dmadt1
            }
            # [ doc = "Checks if the value of the field is `Dmadt2`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_2(&self) -> bool {
                *self == DmadtR::Dmadt2
            }
            # [ doc = "Checks if the value of the field is `Dmadt3`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_3(&self) -> bool {
                *self == DmadtR::Dmadt3
            }
            # [ doc = "Checks if the value of the field is `Dmadt4`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_4(&self) -> bool {
                *self == DmadtR::Dmadt4
            }
            # [ doc = "Checks if the value of the field is `Dmadt5`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_5(&self) -> bool {
                *self == DmadtR::Dmadt5
            }
            # [ doc = "Checks if the value of the field is `Dmadt6`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_6(&self) -> bool {
                *self == DmadtR::Dmadt6
            }
            # [ doc = "Checks if the value of the field is `Dmadt7`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_7(&self) -> bool {
                *self == DmadtR::Dmadt7
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmareqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmareqW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaabortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaabortW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmalevelW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmalevelW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmasrcbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmasrcbyteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadstbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadstbyteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMASRCINCR`" ]
        pub enum DmasrcincrW {
            # [ doc = "DMA source increment 0: source address unchanged" ]
            Dmasrcincr0,
            # [ doc = "DMA source increment 1: source address unchanged" ]
            Dmasrcincr1,
            # [ doc = "DMA source increment 2: source address decremented" ]
            Dmasrcincr2,
            # [ doc = "DMA source increment 3: source address incremented" ]
            Dmasrcincr3,
        }
        impl DmasrcincrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmasrcincrW::Dmasrcincr0 => 0,
                    DmasrcincrW::Dmasrcincr1 => 1,
                    DmasrcincrW::Dmasrcincr2 => 2,
                    DmasrcincrW::Dmasrcincr3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmasrcincrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmasrcincrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmasrcincrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA source increment 0: source address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_0(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr0)
            }
            # [ doc = "DMA source increment 1: source address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_1(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr1)
            }
            # [ doc = "DMA source increment 2: source address decremented" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_2(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr2)
            }
            # [ doc = "DMA source increment 3: source address incremented" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_3(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMADSTINCR`" ]
        pub enum DmadstincrW {
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            Dmadstincr0,
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            Dmadstincr1,
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            Dmadstincr2,
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            Dmadstincr3,
        }
        impl DmadstincrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmadstincrW::Dmadstincr0 => 0,
                    DmadstincrW::Dmadstincr1 => 1,
                    DmadstincrW::Dmadstincr2 => 2,
                    DmadstincrW::Dmadstincr3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadstincrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadstincrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmadstincrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_0(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr0)
            }
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_1(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr1)
            }
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_2(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr2)
            }
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_3(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMADT`" ]
        pub enum DmadtW {
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            Dmadt0,
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            Dmadt1,
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            Dmadt2,
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            Dmadt3,
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            Dmadt4,
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            Dmadt5,
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            Dmadt6,
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            Dmadt7,
        }
        impl DmadtW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmadtW::Dmadt0 => 0,
                    DmadtW::Dmadt1 => 1,
                    DmadtW::Dmadt2 => 2,
                    DmadtW::Dmadt3 => 3,
                    DmadtW::Dmadt4 => 4,
                    DmadtW::Dmadt5 => 5,
                    DmadtW::Dmadt6 => 6,
                    DmadtW::Dmadt7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadtW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmadtW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_0(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt0)
            }
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_1(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt1)
            }
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_2(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt2)
            }
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_3(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt3)
            }
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_4(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt4)
            }
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_5(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt5)
            }
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_6(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt6)
            }
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_7(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Initiate DMA transfer with DMATSEL" ]
            # [ inline ( always ) ]
            pub fn dmareq(&self) -> DmareqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmareqR { bits }
            }
            # [ doc = "Bit 1 - DMA transfer aborted by NMI" ]
            # [ inline ( always ) ]
            pub fn dmaabort(&self) -> DmaabortR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaabortR { bits }
            }
            # [ doc = "Bit 2 - DMA interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaie(&self) -> DmaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaieR { bits }
            }
            # [ doc = "Bit 3 - DMA interrupt flag" ]
            # [ inline ( always ) ]
            pub fn dmaifg(&self) -> DmaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaifgR { bits }
            }
            # [ doc = "Bit 4 - DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&self) -> DmaenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaenR { bits }
            }
            # [ doc = "Bit 5 - DMA level sensitive trigger select" ]
            # [ inline ( always ) ]
            pub fn dmalevel(&self) -> DmalevelR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmalevelR { bits }
            }
            # [ doc = "Bit 6 - DMA source byte" ]
            # [ inline ( always ) ]
            pub fn dmasrcbyte(&self) -> DmasrcbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmasrcbyteR { bits }
            }
            # [ doc = "Bit 7 - DMA destination byte" ]
            # [ inline ( always ) ]
            pub fn dmadstbyte(&self) -> DmadstbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmadstbyteR { bits }
            }
            # [ doc = "Bits 9:10 - DMA source increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr(&self) -> DmasrcincrR {
                DmasrcincrR::_from({
                                       const MASK: u8 = 3;
                                       const OFFSET: u8 = 9;
                                       ((self.bits >> OFFSET) & MASK as u16) as u8
                                   })
            }
            # [ doc = "Bits 11:12 - DMA destination increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadstincr(&self) -> DmadstincrR {
                DmadstincrR::_from({
                                       const MASK: u8 = 3;
                                       const OFFSET: u8 = 11;
                                       ((self.bits >> OFFSET) & MASK as u16) as u8
                                   })
            }
            # [ doc = "Bits 14:16 - DMA transfer mode bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadt(&self) -> DmadtR {
                DmadtR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 14;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Initiate DMA transfer with DMATSEL" ]
            # [ inline ( always ) ]
            pub fn dmareq(&mut self) -> _DmareqW {
                _DmareqW { w: self }
            }
            # [ doc = "Bit 1 - DMA transfer aborted by NMI" ]
            # [ inline ( always ) ]
            pub fn dmaabort(&mut self) -> _DmaabortW {
                _DmaabortW { w: self }
            }
            # [ doc = "Bit 2 - DMA interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaie(&mut self) -> _DmaieW {
                _DmaieW { w: self }
            }
            # [ doc = "Bit 3 - DMA interrupt flag" ]
            # [ inline ( always ) ]
            pub fn dmaifg(&mut self) -> _DmaifgW {
                _DmaifgW { w: self }
            }
            # [ doc = "Bit 4 - DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&mut self) -> _DmaenW {
                _DmaenW { w: self }
            }
            # [ doc = "Bit 5 - DMA level sensitive trigger select" ]
            # [ inline ( always ) ]
            pub fn dmalevel(&mut self) -> _DmalevelW {
                _DmalevelW { w: self }
            }
            # [ doc = "Bit 6 - DMA source byte" ]
            # [ inline ( always ) ]
            pub fn dmasrcbyte(&mut self) -> _DmasrcbyteW {
                _DmasrcbyteW { w: self }
            }
            # [ doc = "Bit 7 - DMA destination byte" ]
            # [ inline ( always ) ]
            pub fn dmadstbyte(&mut self) -> _DmadstbyteW {
                _DmadstbyteW { w: self }
            }
            # [ doc = "Bits 9:10 - DMA source increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr(&mut self) -> _DmasrcincrW {
                _DmasrcincrW { w: self }
            }
            # [ doc = "Bits 11:12 - DMA destination increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadstincr(&mut self) -> _DmadstincrW {
                _DmadstincrW { w: self }
            }
            # [ doc = "Bits 14:16 - DMA transfer mode bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadt(&mut self) -> _DmadtW {
                _DmadtW { w: self }
            }
        }
    }
    # [ doc = "DMA Channel 1 Source Address" ]
    pub struct Dma1sa {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA Channel 1 Source Address" ]
    pub mod dma1sa {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dma1sa {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 1 Destination Address" ]
    pub struct Dma1da {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA Channel 1 Destination Address" ]
    pub mod dma1da {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dma1da {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 1 Transfer Size" ]
    pub struct Dma1sz {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Channel 1 Transfer Size" ]
    pub mod dma1sz {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dma1sz {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 2 Control" ]
    pub struct Dma2ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Channel 2 Control" ]
    pub mod dma2ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dma2ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmareqR {
            bits: u8,
        }
        impl DmareqR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaabortR {
            bits: u8,
        }
        impl DmaabortR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaieR {
            bits: u8,
        }
        impl DmaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaifgR {
            bits: u8,
        }
        impl DmaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmaenR {
            bits: u8,
        }
        impl DmaenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmalevelR {
            bits: u8,
        }
        impl DmalevelR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmasrcbyteR {
            bits: u8,
        }
        impl DmasrcbyteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DmadstbyteR {
            bits: u8,
        }
        impl DmadstbyteR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `DMASRCINCR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmasrcincrR {
            # [ doc = "DMA source increment 0: source address unchanged" ]
            Dmasrcincr0,
            # [ doc = "DMA source increment 1: source address unchanged" ]
            Dmasrcincr1,
            # [ doc = "DMA source increment 2: source address decremented" ]
            Dmasrcincr2,
            # [ doc = "DMA source increment 3: source address incremented" ]
            Dmasrcincr3,
        }
        impl DmasrcincrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmasrcincrR::Dmasrcincr0 => 0,
                    DmasrcincrR::Dmasrcincr1 => 1,
                    DmasrcincrR::Dmasrcincr2 => 2,
                    DmasrcincrR::Dmasrcincr3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmasrcincrR {
                match bits {
                    0 => DmasrcincrR::Dmasrcincr0,
                    1 => DmasrcincrR::Dmasrcincr1,
                    2 => DmasrcincrR::Dmasrcincr2,
                    3 => DmasrcincrR::Dmasrcincr3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr0`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_0(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr0
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr1`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_1(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr1
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr2`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_2(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr2
            }
            # [ doc = "Checks if the value of the field is `Dmasrcincr3`" ]
            # [ inline ( always ) ]
            pub fn is_dmasrcincr_3(&self) -> bool {
                *self == DmasrcincrR::Dmasrcincr3
            }
        }
        # [ doc = "Possible values of the field `DMADSTINCR`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmadstincrR {
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            Dmadstincr0,
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            Dmadstincr1,
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            Dmadstincr2,
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            Dmadstincr3,
        }
        impl DmadstincrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmadstincrR::Dmadstincr0 => 0,
                    DmadstincrR::Dmadstincr1 => 1,
                    DmadstincrR::Dmadstincr2 => 2,
                    DmadstincrR::Dmadstincr3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmadstincrR {
                match bits {
                    0 => DmadstincrR::Dmadstincr0,
                    1 => DmadstincrR::Dmadstincr1,
                    2 => DmadstincrR::Dmadstincr2,
                    3 => DmadstincrR::Dmadstincr3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr0`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_0(&self) -> bool {
                *self == DmadstincrR::Dmadstincr0
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr1`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_1(&self) -> bool {
                *self == DmadstincrR::Dmadstincr1
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr2`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_2(&self) -> bool {
                *self == DmadstincrR::Dmadstincr2
            }
            # [ doc = "Checks if the value of the field is `Dmadstincr3`" ]
            # [ inline ( always ) ]
            pub fn is_dmadstincr_3(&self) -> bool {
                *self == DmadstincrR::Dmadstincr3
            }
        }
        # [ doc = "Possible values of the field `DMADT`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DmadtR {
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            Dmadt0,
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            Dmadt1,
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            Dmadt2,
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            Dmadt3,
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            Dmadt4,
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            Dmadt5,
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            Dmadt6,
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            Dmadt7,
        }
        impl DmadtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmadtR::Dmadt0 => 0,
                    DmadtR::Dmadt1 => 1,
                    DmadtR::Dmadt2 => 2,
                    DmadtR::Dmadt3 => 3,
                    DmadtR::Dmadt4 => 4,
                    DmadtR::Dmadt5 => 5,
                    DmadtR::Dmadt6 => 6,
                    DmadtR::Dmadt7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DmadtR {
                match bits {
                    0 => DmadtR::Dmadt0,
                    1 => DmadtR::Dmadt1,
                    2 => DmadtR::Dmadt2,
                    3 => DmadtR::Dmadt3,
                    4 => DmadtR::Dmadt4,
                    5 => DmadtR::Dmadt5,
                    6 => DmadtR::Dmadt6,
                    7 => DmadtR::Dmadt7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dmadt0`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_0(&self) -> bool {
                *self == DmadtR::Dmadt0
            }
            # [ doc = "Checks if the value of the field is `Dmadt1`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_1(&self) -> bool {
                *self == DmadtR::Dmadt1
            }
            # [ doc = "Checks if the value of the field is `Dmadt2`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_2(&self) -> bool {
                *self == DmadtR::Dmadt2
            }
            # [ doc = "Checks if the value of the field is `Dmadt3`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_3(&self) -> bool {
                *self == DmadtR::Dmadt3
            }
            # [ doc = "Checks if the value of the field is `Dmadt4`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_4(&self) -> bool {
                *self == DmadtR::Dmadt4
            }
            # [ doc = "Checks if the value of the field is `Dmadt5`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_5(&self) -> bool {
                *self == DmadtR::Dmadt5
            }
            # [ doc = "Checks if the value of the field is `Dmadt6`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_6(&self) -> bool {
                *self == DmadtR::Dmadt6
            }
            # [ doc = "Checks if the value of the field is `Dmadt7`" ]
            # [ inline ( always ) ]
            pub fn is_dmadt_7(&self) -> bool {
                *self == DmadtR::Dmadt7
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmareqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmareqW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaabortW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaabortW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmalevelW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmalevelW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmasrcbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmasrcbyteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadstbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadstbyteW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMASRCINCR`" ]
        pub enum DmasrcincrW {
            # [ doc = "DMA source increment 0: source address unchanged" ]
            Dmasrcincr0,
            # [ doc = "DMA source increment 1: source address unchanged" ]
            Dmasrcincr1,
            # [ doc = "DMA source increment 2: source address decremented" ]
            Dmasrcincr2,
            # [ doc = "DMA source increment 3: source address incremented" ]
            Dmasrcincr3,
        }
        impl DmasrcincrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmasrcincrW::Dmasrcincr0 => 0,
                    DmasrcincrW::Dmasrcincr1 => 1,
                    DmasrcincrW::Dmasrcincr2 => 2,
                    DmasrcincrW::Dmasrcincr3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmasrcincrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmasrcincrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmasrcincrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA source increment 0: source address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_0(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr0)
            }
            # [ doc = "DMA source increment 1: source address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_1(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr1)
            }
            # [ doc = "DMA source increment 2: source address decremented" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_2(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr2)
            }
            # [ doc = "DMA source increment 3: source address incremented" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr_3(self) -> &'a mut W {
                self.variant(DmasrcincrW::Dmasrcincr3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMADSTINCR`" ]
        pub enum DmadstincrW {
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            Dmadstincr0,
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            Dmadstincr1,
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            Dmadstincr2,
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            Dmadstincr3,
        }
        impl DmadstincrW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmadstincrW::Dmadstincr0 => 0,
                    DmadstincrW::Dmadstincr1 => 1,
                    DmadstincrW::Dmadstincr2 => 2,
                    DmadstincrW::Dmadstincr3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadstincrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadstincrW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmadstincrW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA destination increment 0: destination address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_0(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr0)
            }
            # [ doc = "DMA destination increment 1: destination address unchanged" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_1(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr1)
            }
            # [ doc = "DMA destination increment 2: destination address decremented" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_2(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr2)
            }
            # [ doc = "DMA destination increment 3: destination address incremented" ]
            # [ inline ( always ) ]
            pub fn dmadstincr_3(self) -> &'a mut W {
                self.variant(DmadstincrW::Dmadstincr3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DMADT`" ]
        pub enum DmadtW {
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            Dmadt0,
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            Dmadt1,
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            Dmadt2,
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            Dmadt3,
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            Dmadt4,
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            Dmadt5,
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            Dmadt6,
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            Dmadt7,
        }
        impl DmadtW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmadtW::Dmadt0 => 0,
                    DmadtW::Dmadt1 => 1,
                    DmadtW::Dmadt2 => 2,
                    DmadtW::Dmadt3 => 3,
                    DmadtW::Dmadt4 => 4,
                    DmadtW::Dmadt5 => 5,
                    DmadtW::Dmadt6 => 6,
                    DmadtW::Dmadt7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DmadtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmadtW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DmadtW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DMA transfer mode 0: Single transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_0(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt0)
            }
            # [ doc = "DMA transfer mode 1: Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_1(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt1)
            }
            # [ doc = "DMA transfer mode 2: Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_2(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt2)
            }
            # [ doc = "DMA transfer mode 3: Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_3(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt3)
            }
            # [ doc = "DMA transfer mode 4: Repeated Single transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_4(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt4)
            }
            # [ doc = "DMA transfer mode 5: Repeated Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_5(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt5)
            }
            # [ doc = "DMA transfer mode 6: Repeated Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_6(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt6)
            }
            # [ doc = "DMA transfer mode 7: Repeated Burst-Block transfer" ]
            # [ inline ( always ) ]
            pub fn dmadt_7(self) -> &'a mut W {
                self.variant(DmadtW::Dmadt7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Initiate DMA transfer with DMATSEL" ]
            # [ inline ( always ) ]
            pub fn dmareq(&self) -> DmareqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmareqR { bits }
            }
            # [ doc = "Bit 1 - DMA transfer aborted by NMI" ]
            # [ inline ( always ) ]
            pub fn dmaabort(&self) -> DmaabortR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaabortR { bits }
            }
            # [ doc = "Bit 2 - DMA interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaie(&self) -> DmaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaieR { bits }
            }
            # [ doc = "Bit 3 - DMA interrupt flag" ]
            # [ inline ( always ) ]
            pub fn dmaifg(&self) -> DmaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaifgR { bits }
            }
            # [ doc = "Bit 4 - DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&self) -> DmaenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmaenR { bits }
            }
            # [ doc = "Bit 5 - DMA level sensitive trigger select" ]
            # [ inline ( always ) ]
            pub fn dmalevel(&self) -> DmalevelR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmalevelR { bits }
            }
            # [ doc = "Bit 6 - DMA source byte" ]
            # [ inline ( always ) ]
            pub fn dmasrcbyte(&self) -> DmasrcbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmasrcbyteR { bits }
            }
            # [ doc = "Bit 7 - DMA destination byte" ]
            # [ inline ( always ) ]
            pub fn dmadstbyte(&self) -> DmadstbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DmadstbyteR { bits }
            }
            # [ doc = "Bits 9:10 - DMA source increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr(&self) -> DmasrcincrR {
                DmasrcincrR::_from({
                                       const MASK: u8 = 3;
                                       const OFFSET: u8 = 9;
                                       ((self.bits >> OFFSET) & MASK as u16) as u8
                                   })
            }
            # [ doc = "Bits 11:12 - DMA destination increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadstincr(&self) -> DmadstincrR {
                DmadstincrR::_from({
                                       const MASK: u8 = 3;
                                       const OFFSET: u8 = 11;
                                       ((self.bits >> OFFSET) & MASK as u16) as u8
                                   })
            }
            # [ doc = "Bits 14:16 - DMA transfer mode bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadt(&self) -> DmadtR {
                DmadtR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 14;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Initiate DMA transfer with DMATSEL" ]
            # [ inline ( always ) ]
            pub fn dmareq(&mut self) -> _DmareqW {
                _DmareqW { w: self }
            }
            # [ doc = "Bit 1 - DMA transfer aborted by NMI" ]
            # [ inline ( always ) ]
            pub fn dmaabort(&mut self) -> _DmaabortW {
                _DmaabortW { w: self }
            }
            # [ doc = "Bit 2 - DMA interrupt enable" ]
            # [ inline ( always ) ]
            pub fn dmaie(&mut self) -> _DmaieW {
                _DmaieW { w: self }
            }
            # [ doc = "Bit 3 - DMA interrupt flag" ]
            # [ inline ( always ) ]
            pub fn dmaifg(&mut self) -> _DmaifgW {
                _DmaifgW { w: self }
            }
            # [ doc = "Bit 4 - DMA enable" ]
            # [ inline ( always ) ]
            pub fn dmaen(&mut self) -> _DmaenW {
                _DmaenW { w: self }
            }
            # [ doc = "Bit 5 - DMA level sensitive trigger select" ]
            # [ inline ( always ) ]
            pub fn dmalevel(&mut self) -> _DmalevelW {
                _DmalevelW { w: self }
            }
            # [ doc = "Bit 6 - DMA source byte" ]
            # [ inline ( always ) ]
            pub fn dmasrcbyte(&mut self) -> _DmasrcbyteW {
                _DmasrcbyteW { w: self }
            }
            # [ doc = "Bit 7 - DMA destination byte" ]
            # [ inline ( always ) ]
            pub fn dmadstbyte(&mut self) -> _DmadstbyteW {
                _DmadstbyteW { w: self }
            }
            # [ doc = "Bits 9:10 - DMA source increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmasrcincr(&mut self) -> _DmasrcincrW {
                _DmasrcincrW { w: self }
            }
            # [ doc = "Bits 11:12 - DMA destination increment bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadstincr(&mut self) -> _DmadstincrW {
                _DmadstincrW { w: self }
            }
            # [ doc = "Bits 14:16 - DMA transfer mode bit 0" ]
            # [ inline ( always ) ]
            pub fn dmadt(&mut self) -> _DmadtW {
                _DmadtW { w: self }
            }
        }
    }
    # [ doc = "DMA Channel 2 Source Address" ]
    pub struct Dma2sa {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA Channel 2 Source Address" ]
    pub mod dma2sa {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dma2sa {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 2 Destination Address" ]
    pub struct Dma2da {
        register: VolatileCell<u32>,
    }
    # [ doc = "DMA Channel 2 Destination Address" ]
    pub mod dma2da {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u32,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u32,
        }
        impl super::Dma2da {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "DMA Channel 2 Transfer Size" ]
    pub struct Dma2sz {
        register: VolatileCell<u16>,
    }
    # [ doc = "DMA Channel 2 Transfer Size" ]
    pub mod dma2sz {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Dma2sz {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "DMA" ]
pub struct Dma {
    register_block: dma::RegisterBlock,
}
impl Deref for Dma {
    type Target = dma::RegisterBlock;
    fn deref(&self) -> &dma::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Flash" ]
pub const FLASH: Peripheral<Flash> = unsafe { Peripheral::new(0) };
# [ doc = "Flash" ]
pub mod flash {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 320usize],
        # [ doc = "0x140 - FLASH Control 1" ]
        pub fctl1: Fctl1,
        _reserved1: [u8; 2usize],
        # [ doc = "0x144 - FLASH Control 3" ]
        pub fctl3: Fctl3,
        # [ doc = "0x146 - FLASH Control 4" ]
        pub fctl4: Fctl4,
    }
    # [ doc = "FLASH Control 1" ]
    pub struct Fctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "FLASH Control 1" ]
    pub mod fctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Fctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EraseR {
            bits: u8,
        }
        impl EraseR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MerasR {
            bits: u8,
        }
        impl MerasR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SwrtR {
            bits: u8,
        }
        impl SwrtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WrtR {
            bits: u8,
        }
        impl WrtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BlkwrtR {
            bits: u8,
        }
        impl BlkwrtR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EraseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EraseW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MerasW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MerasW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SwrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwrtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BlkwrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BlkwrtW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 1 - Enable bit for Flash segment erase" ]
            # [ inline ( always ) ]
            pub fn erase(&self) -> EraseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                EraseR { bits }
            }
            # [ doc = "Bit 2 - Enable bit for Flash mass erase" ]
            # [ inline ( always ) ]
            pub fn meras(&self) -> MerasR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                MerasR { bits }
            }
            # [ doc = "Bit 5 - Smart Write enable" ]
            # [ inline ( always ) ]
            pub fn swrt(&self) -> SwrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SwrtR { bits }
            }
            # [ doc = "Bit 6 - Enable bit for Flash write" ]
            # [ inline ( always ) ]
            pub fn wrt(&self) -> WrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WrtR { bits }
            }
            # [ doc = "Bit 7 - Enable bit for Flash segment write" ]
            # [ inline ( always ) ]
            pub fn blkwrt(&self) -> BlkwrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                BlkwrtR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 1 - Enable bit for Flash segment erase" ]
            # [ inline ( always ) ]
            pub fn erase(&mut self) -> _EraseW {
                _EraseW { w: self }
            }
            # [ doc = "Bit 2 - Enable bit for Flash mass erase" ]
            # [ inline ( always ) ]
            pub fn meras(&mut self) -> _MerasW {
                _MerasW { w: self }
            }
            # [ doc = "Bit 5 - Smart Write enable" ]
            # [ inline ( always ) ]
            pub fn swrt(&mut self) -> _SwrtW {
                _SwrtW { w: self }
            }
            # [ doc = "Bit 6 - Enable bit for Flash write" ]
            # [ inline ( always ) ]
            pub fn wrt(&mut self) -> _WrtW {
                _WrtW { w: self }
            }
            # [ doc = "Bit 7 - Enable bit for Flash segment write" ]
            # [ inline ( always ) ]
            pub fn blkwrt(&mut self) -> _BlkwrtW {
                _BlkwrtW { w: self }
            }
        }
    }
    # [ doc = "FLASH Control 3" ]
    pub struct Fctl3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "FLASH Control 3" ]
    pub mod fctl3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Fctl3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BusyR {
            bits: u8,
        }
        impl BusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct KeyvR {
            bits: u8,
        }
        impl KeyvR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccvifgR {
            bits: u8,
        }
        impl AccvifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WaitR {
            bits: u8,
        }
        impl WaitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct EmexR {
            bits: u8,
        }
        impl EmexR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockaR {
            bits: u8,
        }
        impl LockaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _KeyvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KeyvW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccvifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccvifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WaitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WaitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _EmexW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EmexW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockaW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Flash busy: 1" ]
            # [ inline ( always ) ]
            pub fn busy(&self) -> BusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                BusyR { bits }
            }
            # [ doc = "Bit 1 - Flash Key violation flag" ]
            # [ inline ( always ) ]
            pub fn keyv(&self) -> KeyvR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                KeyvR { bits }
            }
            # [ doc = "Bit 2 - Flash Access violation flag" ]
            # [ inline ( always ) ]
            pub fn accvifg(&self) -> AccvifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AccvifgR { bits }
            }
            # [ doc = "Bit 3 - Wait flag for segment write" ]
            # [ inline ( always ) ]
            pub fn wait(&self) -> WaitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WaitR { bits }
            }
            # [ doc = "Bit 4 - Lock bit: 1 - Flash is locked (read only)" ]
            # [ inline ( always ) ]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                LockR { bits }
            }
            # [ doc = "Bit 5 - Flash Emergency Exit" ]
            # [ inline ( always ) ]
            pub fn emex(&self) -> EmexR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                EmexR { bits }
            }
            # [ doc = "Bit 6 - Segment A Lock bit: read = 1 - Segment is locked (read only)" ]
            # [ inline ( always ) ]
            pub fn locka(&self) -> LockaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                LockaR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Flash busy: 1" ]
            # [ inline ( always ) ]
            pub fn busy(&mut self) -> _BusyW {
                _BusyW { w: self }
            }
            # [ doc = "Bit 1 - Flash Key violation flag" ]
            # [ inline ( always ) ]
            pub fn keyv(&mut self) -> _KeyvW {
                _KeyvW { w: self }
            }
            # [ doc = "Bit 2 - Flash Access violation flag" ]
            # [ inline ( always ) ]
            pub fn accvifg(&mut self) -> _AccvifgW {
                _AccvifgW { w: self }
            }
            # [ doc = "Bit 3 - Wait flag for segment write" ]
            # [ inline ( always ) ]
            pub fn wait(&mut self) -> _WaitW {
                _WaitW { w: self }
            }
            # [ doc = "Bit 4 - Lock bit: 1 - Flash is locked (read only)" ]
            # [ inline ( always ) ]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            # [ doc = "Bit 5 - Flash Emergency Exit" ]
            # [ inline ( always ) ]
            pub fn emex(&mut self) -> _EmexW {
                _EmexW { w: self }
            }
            # [ doc = "Bit 6 - Segment A Lock bit: read = 1 - Segment is locked (read only)" ]
            # [ inline ( always ) ]
            pub fn locka(&mut self) -> _LockaW {
                _LockaW { w: self }
            }
        }
    }
    # [ doc = "FLASH Control 4" ]
    pub struct Fctl4 {
        register: VolatileCell<u16>,
    }
    # [ doc = "FLASH Control 4" ]
    pub mod fctl4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Fctl4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct VpeR {
            bits: u8,
        }
        impl VpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mgr0R {
            bits: u8,
        }
        impl Mgr0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mgr1R {
            bits: u8,
        }
        impl Mgr1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct LockinfoR {
            bits: u8,
        }
        impl LockinfoR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _VpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mgr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mgr0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mgr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mgr1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _LockinfoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockinfoW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Voltage Changed during Program Error Flag" ]
            # [ inline ( always ) ]
            pub fn vpe(&self) -> VpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                VpeR { bits }
            }
            # [ doc = "Bit 4 - Marginal read 0 mode." ]
            # [ inline ( always ) ]
            pub fn mgr0(&self) -> Mgr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mgr0R { bits }
            }
            # [ doc = "Bit 5 - Marginal read 1 mode." ]
            # [ inline ( always ) ]
            pub fn mgr1(&self) -> Mgr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mgr1R { bits }
            }
            # [ doc = "Bit 7 - Lock INFO Memory bit: read = 1 - Segment is locked (read only)" ]
            # [ inline ( always ) ]
            pub fn lockinfo(&self) -> LockinfoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                LockinfoR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Voltage Changed during Program Error Flag" ]
            # [ inline ( always ) ]
            pub fn vpe(&mut self) -> _VpeW {
                _VpeW { w: self }
            }
            # [ doc = "Bit 4 - Marginal read 0 mode." ]
            # [ inline ( always ) ]
            pub fn mgr0(&mut self) -> _Mgr0W {
                _Mgr0W { w: self }
            }
            # [ doc = "Bit 5 - Marginal read 1 mode." ]
            # [ inline ( always ) ]
            pub fn mgr1(&mut self) -> _Mgr1W {
                _Mgr1W { w: self }
            }
            # [ doc = "Bit 7 - Lock INFO Memory bit: read = 1 - Segment is locked (read only)" ]
            # [ inline ( always ) ]
            pub fn lockinfo(&mut self) -> _LockinfoW {
                _LockinfoW { w: self }
            }
        }
    }
}
# [ doc = "Flash" ]
pub struct Flash {
    register_block: flash::RegisterBlock,
}
impl Deref for Flash {
    type Target = flash::RegisterBlock;
    fn deref(&self) -> &flash::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "MPY 16 Multiplier 16 Bit Mode" ]
pub const MPY_16_MULTIPLIER_16_BIT_MODE: Peripheral<Mpy16Multiplier16BitMode> =
    unsafe { Peripheral::new(0) };
# [ doc = "MPY 16 Multiplier 16 Bit Mode" ]
pub mod mpy_16_multiplier_16_bit_mode {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1216usize],
        # [ doc = "0x4c0 - Multiply Unsigned/Operand 1" ]
        pub mpy: Mpy,
        # [ doc = "0x4c2 - Multiply Signed/Operand 1" ]
        pub mpys: Mpys,
        # [ doc = "0x4c4 - Multiply Unsigned and Accumulate/Operand 1" ]
        pub mac: Mac,
        # [ doc = "0x4c6 - Multiply Signed and Accumulate/Operand 1" ]
        pub macs: Macs,
        # [ doc = "0x4c8 - Operand 2" ]
        pub op2: Op2,
        # [ doc = "0x4ca - Result Low Word" ]
        pub reslo: Reslo,
        # [ doc = "0x4cc - Result High Word" ]
        pub reshi: Reshi,
        # [ doc = "0x4ce - Sum Extend" ]
        pub sumext: Sumext,
        _reserved1: [u8; 28usize],
        # [ doc = "0x4ec - MPY32 Control Register 0" ]
        pub mpy32ctl0: Mpy32ctl0,
    }
    # [ doc = "Multiply Unsigned/Operand 1" ]
    pub struct Mpy {
        register: VolatileCell<u16>,
    }
    # [ doc = "Multiply Unsigned/Operand 1" ]
    pub mod mpy {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpy {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Multiply Signed/Operand 1" ]
    pub struct Mpys {
        register: VolatileCell<u16>,
    }
    # [ doc = "Multiply Signed/Operand 1" ]
    pub mod mpys {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpys {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Multiply Unsigned and Accumulate/Operand 1" ]
    pub struct Mac {
        register: VolatileCell<u16>,
    }
    # [ doc = "Multiply Unsigned and Accumulate/Operand 1" ]
    pub mod mac {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mac {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Multiply Signed and Accumulate/Operand 1" ]
    pub struct Macs {
        register: VolatileCell<u16>,
    }
    # [ doc = "Multiply Signed and Accumulate/Operand 1" ]
    pub mod macs {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Macs {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Operand 2" ]
    pub struct Op2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Operand 2" ]
    pub mod op2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Op2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Result Low Word" ]
    pub struct Reslo {
        register: VolatileCell<u16>,
    }
    # [ doc = "Result Low Word" ]
    pub mod reslo {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Reslo {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Result High Word" ]
    pub struct Reshi {
        register: VolatileCell<u16>,
    }
    # [ doc = "Result High Word" ]
    pub mod reshi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Reshi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Sum Extend" ]
    pub struct Sumext {
        register: VolatileCell<u16>,
    }
    # [ doc = "Sum Extend" ]
    pub mod sumext {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sumext {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "MPY32 Control Register 0" ]
    pub struct Mpy32ctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "MPY32 Control Register 0" ]
    pub mod mpy32ctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpy32ctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MpycR {
            bits: u8,
        }
        impl MpycR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MpyfracR {
            bits: u8,
        }
        impl MpyfracR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MpysatR {
            bits: u8,
        }
        impl MpysatR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `MPYM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum MpymR {
            # [ doc = "Multiplier mode: MPY" ]
            Mpym0,
            # [ doc = "Multiplier mode: MPYS" ]
            Mpym1,
            # [ doc = "Multiplier mode: MAC" ]
            Mpym2,
            # [ doc = "Multiplier mode: MACS" ]
            Mpym3,
        }
        impl MpymR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    MpymR::Mpym0 => 0,
                    MpymR::Mpym1 => 1,
                    MpymR::Mpym2 => 2,
                    MpymR::Mpym3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> MpymR {
                match bits {
                    0 => MpymR::Mpym0,
                    1 => MpymR::Mpym1,
                    2 => MpymR::Mpym2,
                    3 => MpymR::Mpym3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Mpym0`" ]
            # [ inline ( always ) ]
            pub fn is_mpym_0(&self) -> bool {
                *self == MpymR::Mpym0
            }
            # [ doc = "Checks if the value of the field is `Mpym1`" ]
            # [ inline ( always ) ]
            pub fn is_mpym_1(&self) -> bool {
                *self == MpymR::Mpym1
            }
            # [ doc = "Checks if the value of the field is `Mpym2`" ]
            # [ inline ( always ) ]
            pub fn is_mpym_2(&self) -> bool {
                *self == MpymR::Mpym2
            }
            # [ doc = "Checks if the value of the field is `Mpym3`" ]
            # [ inline ( always ) ]
            pub fn is_mpym_3(&self) -> bool {
                *self == MpymR::Mpym3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Op132R {
            bits: u8,
        }
        impl Op132R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Op232R {
            bits: u8,
        }
        impl Op232R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MpydlywrtenR {
            bits: u8,
        }
        impl MpydlywrtenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mpydly32R {
            bits: u8,
        }
        impl Mpydly32R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MpycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MpycW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MpyfracW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MpyfracW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MpysatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MpysatW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MPYM`" ]
        pub enum MpymW {
            # [ doc = "Multiplier mode: MPY" ]
            Mpym0,
            # [ doc = "Multiplier mode: MPYS" ]
            Mpym1,
            # [ doc = "Multiplier mode: MAC" ]
            Mpym2,
            # [ doc = "Multiplier mode: MACS" ]
            Mpym3,
        }
        impl MpymW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MpymW::Mpym0 => 0,
                    MpymW::Mpym1 => 1,
                    MpymW::Mpym2 => 2,
                    MpymW::Mpym3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MpymW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MpymW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: MpymW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Multiplier mode: MPY" ]
            # [ inline ( always ) ]
            pub fn mpym_0(self) -> &'a mut W {
                self.variant(MpymW::Mpym0)
            }
            # [ doc = "Multiplier mode: MPYS" ]
            # [ inline ( always ) ]
            pub fn mpym_1(self) -> &'a mut W {
                self.variant(MpymW::Mpym1)
            }
            # [ doc = "Multiplier mode: MAC" ]
            # [ inline ( always ) ]
            pub fn mpym_2(self) -> &'a mut W {
                self.variant(MpymW::Mpym2)
            }
            # [ doc = "Multiplier mode: MACS" ]
            # [ inline ( always ) ]
            pub fn mpym_3(self) -> &'a mut W {
                self.variant(MpymW::Mpym3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Op132W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Op132W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Op232W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Op232W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MpydlywrtenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MpydlywrtenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mpydly32W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mpydly32W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Carry of the multiplier" ]
            # [ inline ( always ) ]
            pub fn mpyc(&self) -> MpycR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                MpycR { bits }
            }
            # [ doc = "Bit 2 - Fractional mode" ]
            # [ inline ( always ) ]
            pub fn mpyfrac(&self) -> MpyfracR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                MpyfracR { bits }
            }
            # [ doc = "Bit 3 - Saturation mode" ]
            # [ inline ( always ) ]
            pub fn mpysat(&self) -> MpysatR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                MpysatR { bits }
            }
            # [ doc = "Bits 5:6 - Multiplier mode Bit:0" ]
            # [ inline ( always ) ]
            pub fn mpym(&self) -> MpymR {
                MpymR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 5;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bit 6 - Bit-width of operand 1 0:16Bit / 1:32Bit" ]
            # [ inline ( always ) ]
            pub fn op1_32(&self) -> Op132R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Op132R { bits }
            }
            # [ doc = "Bit 7 - Bit-width of operand 2 0:16Bit / 1:32Bit" ]
            # [ inline ( always ) ]
            pub fn op2_32(&self) -> Op232R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Op232R { bits }
            }
            # [ doc = "Bit 8 - Delayed write enable" ]
            # [ inline ( always ) ]
            pub fn mpydlywrten(&self) -> MpydlywrtenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                MpydlywrtenR { bits }
            }
            # [ doc = "Bit 9 - Delayed write mode" ]
            # [ inline ( always ) ]
            pub fn mpydly32(&self) -> Mpydly32R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mpydly32R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Carry of the multiplier" ]
            # [ inline ( always ) ]
            pub fn mpyc(&mut self) -> _MpycW {
                _MpycW { w: self }
            }
            # [ doc = "Bit 2 - Fractional mode" ]
            # [ inline ( always ) ]
            pub fn mpyfrac(&mut self) -> _MpyfracW {
                _MpyfracW { w: self }
            }
            # [ doc = "Bit 3 - Saturation mode" ]
            # [ inline ( always ) ]
            pub fn mpysat(&mut self) -> _MpysatW {
                _MpysatW { w: self }
            }
            # [ doc = "Bits 5:6 - Multiplier mode Bit:0" ]
            # [ inline ( always ) ]
            pub fn mpym(&mut self) -> _MpymW {
                _MpymW { w: self }
            }
            # [ doc = "Bit 6 - Bit-width of operand 1 0:16Bit / 1:32Bit" ]
            # [ inline ( always ) ]
            pub fn op1_32(&mut self) -> _Op132W {
                _Op132W { w: self }
            }
            # [ doc = "Bit 7 - Bit-width of operand 2 0:16Bit / 1:32Bit" ]
            # [ inline ( always ) ]
            pub fn op2_32(&mut self) -> _Op232W {
                _Op232W { w: self }
            }
            # [ doc = "Bit 8 - Delayed write enable" ]
            # [ inline ( always ) ]
            pub fn mpydlywrten(&mut self) -> _MpydlywrtenW {
                _MpydlywrtenW { w: self }
            }
            # [ doc = "Bit 9 - Delayed write mode" ]
            # [ inline ( always ) ]
            pub fn mpydly32(&mut self) -> _Mpydly32W {
                _Mpydly32W { w: self }
            }
        }
    }
}
# [ doc = "MPY 16 Multiplier 16 Bit Mode" ]
pub struct Mpy16Multiplier16BitMode {
    register_block: mpy_16_multiplier_16_bit_mode::RegisterBlock,
}
impl Deref for Mpy16Multiplier16BitMode {
    type Target = mpy_16_multiplier_16_bit_mode::RegisterBlock;
    fn deref(&self) -> &mpy_16_multiplier_16_bit_mode::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "MPY 32 Multiplier 32 Bit Mode" ]
pub const MPY_32_MULTIPLIER_32_BIT_MODE: Peripheral<Mpy32Multiplier32BitMode> =
    unsafe { Peripheral::new(0) };
# [ doc = "MPY 32 Multiplier 32 Bit Mode" ]
pub mod mpy_32_multiplier_32_bit_mode {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1232usize],
        # [ doc = "0x4d0 - 32-bit operand 1 - multiply - low word" ]
        pub mpy32l: Mpy32l,
        # [ doc = "0x4d2 - 32-bit operand 1 - multiply - high word" ]
        pub mpy32h: Mpy32h,
        # [ doc = "0x4d4 - 32-bit operand 1 - signed multiply - low word" ]
        pub mpys32l: Mpys32l,
        # [ doc = "0x4d6 - 32-bit operand 1 - signed multiply - high word" ]
        pub mpys32h: Mpys32h,
        # [ doc = "0x4d8 - 32-bit operand 1 - multiply accumulate - low word" ]
        pub mac32l: Mac32l,
        # [ doc = "0x4da - 32-bit operand 1 - multiply accumulate - high word" ]
        pub mac32h: Mac32h,
        # [ doc = "0x4dc - 32-bit operand 1 - signed multiply accumulate - low word" ]
        pub macs32l: Macs32l,
        # [ doc = "0x4de - 32-bit operand 1 - signed multiply accumulate - high word" ]
        pub macs32h: Macs32h,
        # [ doc = "0x4e0 - 32-bit operand 2 - low word" ]
        pub op2l: Op2l,
        # [ doc = "0x4e2 - 32-bit operand 2 - high word" ]
        pub op2h: Op2h,
        # [ doc = "0x4e4 - 32x32-bit result 0 - least significant word" ]
        pub res0: Res0,
        # [ doc = "0x4e6 - 32x32-bit result 1" ]
        pub res1: Res1,
        # [ doc = "0x4e8 - 32x32-bit result 2" ]
        pub res2: Res2,
        # [ doc = "0x4ea - 32x32-bit result 3 - most significant word" ]
        pub res3: Res3,
    }
    # [ doc = "32-bit operand 1 - multiply - low word" ]
    pub struct Mpy32l {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - multiply - low word" ]
    pub mod mpy32l {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpy32l {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - multiply - high word" ]
    pub struct Mpy32h {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - multiply - high word" ]
    pub mod mpy32h {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpy32h {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - signed multiply - low word" ]
    pub struct Mpys32l {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - signed multiply - low word" ]
    pub mod mpys32l {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpys32l {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - signed multiply - high word" ]
    pub struct Mpys32h {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - signed multiply - high word" ]
    pub mod mpys32h {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mpys32h {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - multiply accumulate - low word" ]
    pub struct Mac32l {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - multiply accumulate - low word" ]
    pub mod mac32l {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mac32l {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - multiply accumulate - high word" ]
    pub struct Mac32h {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - multiply accumulate - high word" ]
    pub mod mac32h {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Mac32h {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - signed multiply accumulate - low word" ]
    pub struct Macs32l {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - signed multiply accumulate - low word" ]
    pub mod macs32l {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Macs32l {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 1 - signed multiply accumulate - high word" ]
    pub struct Macs32h {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 1 - signed multiply accumulate - high word" ]
    pub mod macs32h {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Macs32h {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 2 - low word" ]
    pub struct Op2l {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 2 - low word" ]
    pub mod op2l {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Op2l {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32-bit operand 2 - high word" ]
    pub struct Op2h {
        register: VolatileCell<u16>,
    }
    # [ doc = "32-bit operand 2 - high word" ]
    pub mod op2h {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Op2h {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32x32-bit result 0 - least significant word" ]
    pub struct Res0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "32x32-bit result 0 - least significant word" ]
    pub mod res0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Res0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32x32-bit result 1" ]
    pub struct Res1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "32x32-bit result 1" ]
    pub mod res1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Res1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32x32-bit result 2" ]
    pub struct Res2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "32x32-bit result 2" ]
    pub mod res2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Res2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "32x32-bit result 3 - most significant word" ]
    pub struct Res3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "32x32-bit result 3 - most significant word" ]
    pub mod res3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Res3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "MPY 32 Multiplier 32 Bit Mode" ]
pub struct Mpy32Multiplier32BitMode {
    register_block: mpy_32_multiplier_32_bit_mode::RegisterBlock,
}
impl Deref for Mpy32Multiplier32BitMode {
    type Target = mpy_32_multiplier_32_bit_mode::RegisterBlock;
    fn deref(&self) -> &mpy_32_multiplier_32_bit_mode::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port A" ]
pub const PORT_A: Peripheral<PortA> = unsafe { Peripheral::new(0) };
# [ doc = "Port A" ]
pub mod port_a {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 512usize],
        # [ doc = "0x200 - Port A Input" ]
        pub pain: Pain,
        # [ doc = "0x202 - Port A Output" ]
        pub paout: Paout,
        # [ doc = "0x204 - Port A Direction" ]
        pub padir: Padir,
        # [ doc = "0x206 - Port A Resistor Enable" ]
        pub paren: Paren,
        # [ doc = "0x208 - Port A Drive Strenght" ]
        pub pads: Pads,
        # [ doc = "0x20a - Port A Selection" ]
        pub pasel: Pasel,
        _reserved1: [u8; 12usize],
        # [ doc = "0x218 - Port A Interrupt Edge Select" ]
        pub paies: Paies,
        # [ doc = "0x21a - Port A Interrupt Enable" ]
        pub paie: Paie,
        # [ doc = "0x21c - Port A Interrupt Flag" ]
        pub paifg: Paifg,
    }
    # [ doc = "Port A Input" ]
    pub struct Pain {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Input" ]
    pub mod pain {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pain {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain0R {
            bits: u8,
        }
        impl Pain0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain1R {
            bits: u8,
        }
        impl Pain1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain2R {
            bits: u8,
        }
        impl Pain2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain3R {
            bits: u8,
        }
        impl Pain3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain4R {
            bits: u8,
        }
        impl Pain4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain5R {
            bits: u8,
        }
        impl Pain5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain6R {
            bits: u8,
        }
        impl Pain6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain7R {
            bits: u8,
        }
        impl Pain7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain8R {
            bits: u8,
        }
        impl Pain8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain9R {
            bits: u8,
        }
        impl Pain9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain10R {
            bits: u8,
        }
        impl Pain10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain11R {
            bits: u8,
        }
        impl Pain11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain12R {
            bits: u8,
        }
        impl Pain12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain13R {
            bits: u8,
        }
        impl Pain13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain14R {
            bits: u8,
        }
        impl Pain14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pain15R {
            bits: u8,
        }
        impl Pain15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pain15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pain15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PAIN0" ]
            # [ inline ( always ) ]
            pub fn pain0(&self) -> Pain0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain0R { bits }
            }
            # [ doc = "Bit 1 - PAIN1" ]
            # [ inline ( always ) ]
            pub fn pain1(&self) -> Pain1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain1R { bits }
            }
            # [ doc = "Bit 2 - PAIN2" ]
            # [ inline ( always ) ]
            pub fn pain2(&self) -> Pain2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain2R { bits }
            }
            # [ doc = "Bit 3 - PAIN3" ]
            # [ inline ( always ) ]
            pub fn pain3(&self) -> Pain3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain3R { bits }
            }
            # [ doc = "Bit 4 - PAIN4" ]
            # [ inline ( always ) ]
            pub fn pain4(&self) -> Pain4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain4R { bits }
            }
            # [ doc = "Bit 5 - PAIN5" ]
            # [ inline ( always ) ]
            pub fn pain5(&self) -> Pain5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain5R { bits }
            }
            # [ doc = "Bit 6 - PAIN6" ]
            # [ inline ( always ) ]
            pub fn pain6(&self) -> Pain6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain6R { bits }
            }
            # [ doc = "Bit 7 - PAIN7" ]
            # [ inline ( always ) ]
            pub fn pain7(&self) -> Pain7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain7R { bits }
            }
            # [ doc = "Bit 8 - PAIN8" ]
            # [ inline ( always ) ]
            pub fn pain8(&self) -> Pain8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain8R { bits }
            }
            # [ doc = "Bit 9 - PAIN9" ]
            # [ inline ( always ) ]
            pub fn pain9(&self) -> Pain9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain9R { bits }
            }
            # [ doc = "Bit 10 - PAIN10" ]
            # [ inline ( always ) ]
            pub fn pain10(&self) -> Pain10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain10R { bits }
            }
            # [ doc = "Bit 11 - PAIN11" ]
            # [ inline ( always ) ]
            pub fn pain11(&self) -> Pain11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain11R { bits }
            }
            # [ doc = "Bit 12 - PAIN12" ]
            # [ inline ( always ) ]
            pub fn pain12(&self) -> Pain12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain12R { bits }
            }
            # [ doc = "Bit 13 - PAIN13" ]
            # [ inline ( always ) ]
            pub fn pain13(&self) -> Pain13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain13R { bits }
            }
            # [ doc = "Bit 14 - PAIN14" ]
            # [ inline ( always ) ]
            pub fn pain14(&self) -> Pain14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain14R { bits }
            }
            # [ doc = "Bit 15 - PAIN15" ]
            # [ inline ( always ) ]
            pub fn pain15(&self) -> Pain15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pain15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PAIN0" ]
            # [ inline ( always ) ]
            pub fn pain0(&mut self) -> _Pain0W {
                _Pain0W { w: self }
            }
            # [ doc = "Bit 1 - PAIN1" ]
            # [ inline ( always ) ]
            pub fn pain1(&mut self) -> _Pain1W {
                _Pain1W { w: self }
            }
            # [ doc = "Bit 2 - PAIN2" ]
            # [ inline ( always ) ]
            pub fn pain2(&mut self) -> _Pain2W {
                _Pain2W { w: self }
            }
            # [ doc = "Bit 3 - PAIN3" ]
            # [ inline ( always ) ]
            pub fn pain3(&mut self) -> _Pain3W {
                _Pain3W { w: self }
            }
            # [ doc = "Bit 4 - PAIN4" ]
            # [ inline ( always ) ]
            pub fn pain4(&mut self) -> _Pain4W {
                _Pain4W { w: self }
            }
            # [ doc = "Bit 5 - PAIN5" ]
            # [ inline ( always ) ]
            pub fn pain5(&mut self) -> _Pain5W {
                _Pain5W { w: self }
            }
            # [ doc = "Bit 6 - PAIN6" ]
            # [ inline ( always ) ]
            pub fn pain6(&mut self) -> _Pain6W {
                _Pain6W { w: self }
            }
            # [ doc = "Bit 7 - PAIN7" ]
            # [ inline ( always ) ]
            pub fn pain7(&mut self) -> _Pain7W {
                _Pain7W { w: self }
            }
            # [ doc = "Bit 8 - PAIN8" ]
            # [ inline ( always ) ]
            pub fn pain8(&mut self) -> _Pain8W {
                _Pain8W { w: self }
            }
            # [ doc = "Bit 9 - PAIN9" ]
            # [ inline ( always ) ]
            pub fn pain9(&mut self) -> _Pain9W {
                _Pain9W { w: self }
            }
            # [ doc = "Bit 10 - PAIN10" ]
            # [ inline ( always ) ]
            pub fn pain10(&mut self) -> _Pain10W {
                _Pain10W { w: self }
            }
            # [ doc = "Bit 11 - PAIN11" ]
            # [ inline ( always ) ]
            pub fn pain11(&mut self) -> _Pain11W {
                _Pain11W { w: self }
            }
            # [ doc = "Bit 12 - PAIN12" ]
            # [ inline ( always ) ]
            pub fn pain12(&mut self) -> _Pain12W {
                _Pain12W { w: self }
            }
            # [ doc = "Bit 13 - PAIN13" ]
            # [ inline ( always ) ]
            pub fn pain13(&mut self) -> _Pain13W {
                _Pain13W { w: self }
            }
            # [ doc = "Bit 14 - PAIN14" ]
            # [ inline ( always ) ]
            pub fn pain14(&mut self) -> _Pain14W {
                _Pain14W { w: self }
            }
            # [ doc = "Bit 15 - PAIN15" ]
            # [ inline ( always ) ]
            pub fn pain15(&mut self) -> _Pain15W {
                _Pain15W { w: self }
            }
        }
    }
    # [ doc = "Port A Output" ]
    pub struct Paout {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Output" ]
    pub mod paout {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Paout {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout0R {
            bits: u8,
        }
        impl Paout0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout1R {
            bits: u8,
        }
        impl Paout1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout2R {
            bits: u8,
        }
        impl Paout2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout3R {
            bits: u8,
        }
        impl Paout3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout4R {
            bits: u8,
        }
        impl Paout4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout5R {
            bits: u8,
        }
        impl Paout5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout6R {
            bits: u8,
        }
        impl Paout6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout7R {
            bits: u8,
        }
        impl Paout7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout8R {
            bits: u8,
        }
        impl Paout8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout9R {
            bits: u8,
        }
        impl Paout9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout10R {
            bits: u8,
        }
        impl Paout10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout11R {
            bits: u8,
        }
        impl Paout11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout12R {
            bits: u8,
        }
        impl Paout12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout13R {
            bits: u8,
        }
        impl Paout13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout14R {
            bits: u8,
        }
        impl Paout14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paout15R {
            bits: u8,
        }
        impl Paout15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paout15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paout15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PAOUT0" ]
            # [ inline ( always ) ]
            pub fn paout0(&self) -> Paout0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout0R { bits }
            }
            # [ doc = "Bit 1 - PAOUT1" ]
            # [ inline ( always ) ]
            pub fn paout1(&self) -> Paout1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout1R { bits }
            }
            # [ doc = "Bit 2 - PAOUT2" ]
            # [ inline ( always ) ]
            pub fn paout2(&self) -> Paout2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout2R { bits }
            }
            # [ doc = "Bit 3 - PAOUT3" ]
            # [ inline ( always ) ]
            pub fn paout3(&self) -> Paout3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout3R { bits }
            }
            # [ doc = "Bit 4 - PAOUT4" ]
            # [ inline ( always ) ]
            pub fn paout4(&self) -> Paout4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout4R { bits }
            }
            # [ doc = "Bit 5 - PAOUT5" ]
            # [ inline ( always ) ]
            pub fn paout5(&self) -> Paout5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout5R { bits }
            }
            # [ doc = "Bit 6 - PAOUT6" ]
            # [ inline ( always ) ]
            pub fn paout6(&self) -> Paout6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout6R { bits }
            }
            # [ doc = "Bit 7 - PAOUT7" ]
            # [ inline ( always ) ]
            pub fn paout7(&self) -> Paout7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout7R { bits }
            }
            # [ doc = "Bit 8 - PAOUT8" ]
            # [ inline ( always ) ]
            pub fn paout8(&self) -> Paout8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout8R { bits }
            }
            # [ doc = "Bit 9 - PAOUT9" ]
            # [ inline ( always ) ]
            pub fn paout9(&self) -> Paout9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout9R { bits }
            }
            # [ doc = "Bit 10 - PAOUT10" ]
            # [ inline ( always ) ]
            pub fn paout10(&self) -> Paout10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout10R { bits }
            }
            # [ doc = "Bit 11 - PAOUT11" ]
            # [ inline ( always ) ]
            pub fn paout11(&self) -> Paout11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout11R { bits }
            }
            # [ doc = "Bit 12 - PAOUT12" ]
            # [ inline ( always ) ]
            pub fn paout12(&self) -> Paout12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout12R { bits }
            }
            # [ doc = "Bit 13 - PAOUT13" ]
            # [ inline ( always ) ]
            pub fn paout13(&self) -> Paout13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout13R { bits }
            }
            # [ doc = "Bit 14 - PAOUT14" ]
            # [ inline ( always ) ]
            pub fn paout14(&self) -> Paout14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout14R { bits }
            }
            # [ doc = "Bit 15 - PAOUT15" ]
            # [ inline ( always ) ]
            pub fn paout15(&self) -> Paout15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paout15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PAOUT0" ]
            # [ inline ( always ) ]
            pub fn paout0(&mut self) -> _Paout0W {
                _Paout0W { w: self }
            }
            # [ doc = "Bit 1 - PAOUT1" ]
            # [ inline ( always ) ]
            pub fn paout1(&mut self) -> _Paout1W {
                _Paout1W { w: self }
            }
            # [ doc = "Bit 2 - PAOUT2" ]
            # [ inline ( always ) ]
            pub fn paout2(&mut self) -> _Paout2W {
                _Paout2W { w: self }
            }
            # [ doc = "Bit 3 - PAOUT3" ]
            # [ inline ( always ) ]
            pub fn paout3(&mut self) -> _Paout3W {
                _Paout3W { w: self }
            }
            # [ doc = "Bit 4 - PAOUT4" ]
            # [ inline ( always ) ]
            pub fn paout4(&mut self) -> _Paout4W {
                _Paout4W { w: self }
            }
            # [ doc = "Bit 5 - PAOUT5" ]
            # [ inline ( always ) ]
            pub fn paout5(&mut self) -> _Paout5W {
                _Paout5W { w: self }
            }
            # [ doc = "Bit 6 - PAOUT6" ]
            # [ inline ( always ) ]
            pub fn paout6(&mut self) -> _Paout6W {
                _Paout6W { w: self }
            }
            # [ doc = "Bit 7 - PAOUT7" ]
            # [ inline ( always ) ]
            pub fn paout7(&mut self) -> _Paout7W {
                _Paout7W { w: self }
            }
            # [ doc = "Bit 8 - PAOUT8" ]
            # [ inline ( always ) ]
            pub fn paout8(&mut self) -> _Paout8W {
                _Paout8W { w: self }
            }
            # [ doc = "Bit 9 - PAOUT9" ]
            # [ inline ( always ) ]
            pub fn paout9(&mut self) -> _Paout9W {
                _Paout9W { w: self }
            }
            # [ doc = "Bit 10 - PAOUT10" ]
            # [ inline ( always ) ]
            pub fn paout10(&mut self) -> _Paout10W {
                _Paout10W { w: self }
            }
            # [ doc = "Bit 11 - PAOUT11" ]
            # [ inline ( always ) ]
            pub fn paout11(&mut self) -> _Paout11W {
                _Paout11W { w: self }
            }
            # [ doc = "Bit 12 - PAOUT12" ]
            # [ inline ( always ) ]
            pub fn paout12(&mut self) -> _Paout12W {
                _Paout12W { w: self }
            }
            # [ doc = "Bit 13 - PAOUT13" ]
            # [ inline ( always ) ]
            pub fn paout13(&mut self) -> _Paout13W {
                _Paout13W { w: self }
            }
            # [ doc = "Bit 14 - PAOUT14" ]
            # [ inline ( always ) ]
            pub fn paout14(&mut self) -> _Paout14W {
                _Paout14W { w: self }
            }
            # [ doc = "Bit 15 - PAOUT15" ]
            # [ inline ( always ) ]
            pub fn paout15(&mut self) -> _Paout15W {
                _Paout15W { w: self }
            }
        }
    }
    # [ doc = "Port A Direction" ]
    pub struct Padir {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Direction" ]
    pub mod padir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Padir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir0R {
            bits: u8,
        }
        impl Padir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir1R {
            bits: u8,
        }
        impl Padir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir2R {
            bits: u8,
        }
        impl Padir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir3R {
            bits: u8,
        }
        impl Padir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir4R {
            bits: u8,
        }
        impl Padir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir5R {
            bits: u8,
        }
        impl Padir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir6R {
            bits: u8,
        }
        impl Padir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir7R {
            bits: u8,
        }
        impl Padir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir8R {
            bits: u8,
        }
        impl Padir8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir9R {
            bits: u8,
        }
        impl Padir9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir10R {
            bits: u8,
        }
        impl Padir10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir11R {
            bits: u8,
        }
        impl Padir11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir12R {
            bits: u8,
        }
        impl Padir12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir13R {
            bits: u8,
        }
        impl Padir13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir14R {
            bits: u8,
        }
        impl Padir14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Padir15R {
            bits: u8,
        }
        impl Padir15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Padir15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Padir15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PADIR0" ]
            # [ inline ( always ) ]
            pub fn padir0(&self) -> Padir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir0R { bits }
            }
            # [ doc = "Bit 1 - PADIR1" ]
            # [ inline ( always ) ]
            pub fn padir1(&self) -> Padir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir1R { bits }
            }
            # [ doc = "Bit 2 - PADIR2" ]
            # [ inline ( always ) ]
            pub fn padir2(&self) -> Padir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir2R { bits }
            }
            # [ doc = "Bit 3 - PADIR3" ]
            # [ inline ( always ) ]
            pub fn padir3(&self) -> Padir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir3R { bits }
            }
            # [ doc = "Bit 4 - PADIR4" ]
            # [ inline ( always ) ]
            pub fn padir4(&self) -> Padir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir4R { bits }
            }
            # [ doc = "Bit 5 - PADIR5" ]
            # [ inline ( always ) ]
            pub fn padir5(&self) -> Padir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir5R { bits }
            }
            # [ doc = "Bit 6 - PADIR6" ]
            # [ inline ( always ) ]
            pub fn padir6(&self) -> Padir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir6R { bits }
            }
            # [ doc = "Bit 7 - PADIR7" ]
            # [ inline ( always ) ]
            pub fn padir7(&self) -> Padir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir7R { bits }
            }
            # [ doc = "Bit 8 - PADIR8" ]
            # [ inline ( always ) ]
            pub fn padir8(&self) -> Padir8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir8R { bits }
            }
            # [ doc = "Bit 9 - PADIR9" ]
            # [ inline ( always ) ]
            pub fn padir9(&self) -> Padir9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir9R { bits }
            }
            # [ doc = "Bit 10 - PADIR10" ]
            # [ inline ( always ) ]
            pub fn padir10(&self) -> Padir10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir10R { bits }
            }
            # [ doc = "Bit 11 - PADIR11" ]
            # [ inline ( always ) ]
            pub fn padir11(&self) -> Padir11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir11R { bits }
            }
            # [ doc = "Bit 12 - PADIR12" ]
            # [ inline ( always ) ]
            pub fn padir12(&self) -> Padir12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir12R { bits }
            }
            # [ doc = "Bit 13 - PADIR13" ]
            # [ inline ( always ) ]
            pub fn padir13(&self) -> Padir13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir13R { bits }
            }
            # [ doc = "Bit 14 - PADIR14" ]
            # [ inline ( always ) ]
            pub fn padir14(&self) -> Padir14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir14R { bits }
            }
            # [ doc = "Bit 15 - PADIR15" ]
            # [ inline ( always ) ]
            pub fn padir15(&self) -> Padir15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Padir15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PADIR0" ]
            # [ inline ( always ) ]
            pub fn padir0(&mut self) -> _Padir0W {
                _Padir0W { w: self }
            }
            # [ doc = "Bit 1 - PADIR1" ]
            # [ inline ( always ) ]
            pub fn padir1(&mut self) -> _Padir1W {
                _Padir1W { w: self }
            }
            # [ doc = "Bit 2 - PADIR2" ]
            # [ inline ( always ) ]
            pub fn padir2(&mut self) -> _Padir2W {
                _Padir2W { w: self }
            }
            # [ doc = "Bit 3 - PADIR3" ]
            # [ inline ( always ) ]
            pub fn padir3(&mut self) -> _Padir3W {
                _Padir3W { w: self }
            }
            # [ doc = "Bit 4 - PADIR4" ]
            # [ inline ( always ) ]
            pub fn padir4(&mut self) -> _Padir4W {
                _Padir4W { w: self }
            }
            # [ doc = "Bit 5 - PADIR5" ]
            # [ inline ( always ) ]
            pub fn padir5(&mut self) -> _Padir5W {
                _Padir5W { w: self }
            }
            # [ doc = "Bit 6 - PADIR6" ]
            # [ inline ( always ) ]
            pub fn padir6(&mut self) -> _Padir6W {
                _Padir6W { w: self }
            }
            # [ doc = "Bit 7 - PADIR7" ]
            # [ inline ( always ) ]
            pub fn padir7(&mut self) -> _Padir7W {
                _Padir7W { w: self }
            }
            # [ doc = "Bit 8 - PADIR8" ]
            # [ inline ( always ) ]
            pub fn padir8(&mut self) -> _Padir8W {
                _Padir8W { w: self }
            }
            # [ doc = "Bit 9 - PADIR9" ]
            # [ inline ( always ) ]
            pub fn padir9(&mut self) -> _Padir9W {
                _Padir9W { w: self }
            }
            # [ doc = "Bit 10 - PADIR10" ]
            # [ inline ( always ) ]
            pub fn padir10(&mut self) -> _Padir10W {
                _Padir10W { w: self }
            }
            # [ doc = "Bit 11 - PADIR11" ]
            # [ inline ( always ) ]
            pub fn padir11(&mut self) -> _Padir11W {
                _Padir11W { w: self }
            }
            # [ doc = "Bit 12 - PADIR12" ]
            # [ inline ( always ) ]
            pub fn padir12(&mut self) -> _Padir12W {
                _Padir12W { w: self }
            }
            # [ doc = "Bit 13 - PADIR13" ]
            # [ inline ( always ) ]
            pub fn padir13(&mut self) -> _Padir13W {
                _Padir13W { w: self }
            }
            # [ doc = "Bit 14 - PADIR14" ]
            # [ inline ( always ) ]
            pub fn padir14(&mut self) -> _Padir14W {
                _Padir14W { w: self }
            }
            # [ doc = "Bit 15 - PADIR15" ]
            # [ inline ( always ) ]
            pub fn padir15(&mut self) -> _Padir15W {
                _Padir15W { w: self }
            }
        }
    }
    # [ doc = "Port A Resistor Enable" ]
    pub struct Paren {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Resistor Enable" ]
    pub mod paren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Paren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren0R {
            bits: u8,
        }
        impl Paren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren1R {
            bits: u8,
        }
        impl Paren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren2R {
            bits: u8,
        }
        impl Paren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren3R {
            bits: u8,
        }
        impl Paren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren4R {
            bits: u8,
        }
        impl Paren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren5R {
            bits: u8,
        }
        impl Paren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren6R {
            bits: u8,
        }
        impl Paren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren7R {
            bits: u8,
        }
        impl Paren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren8R {
            bits: u8,
        }
        impl Paren8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren9R {
            bits: u8,
        }
        impl Paren9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren10R {
            bits: u8,
        }
        impl Paren10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren11R {
            bits: u8,
        }
        impl Paren11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren12R {
            bits: u8,
        }
        impl Paren12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren13R {
            bits: u8,
        }
        impl Paren13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren14R {
            bits: u8,
        }
        impl Paren14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paren15R {
            bits: u8,
        }
        impl Paren15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paren15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paren15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PAREN0" ]
            # [ inline ( always ) ]
            pub fn paren0(&self) -> Paren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren0R { bits }
            }
            # [ doc = "Bit 1 - PAREN1" ]
            # [ inline ( always ) ]
            pub fn paren1(&self) -> Paren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren1R { bits }
            }
            # [ doc = "Bit 2 - PAREN2" ]
            # [ inline ( always ) ]
            pub fn paren2(&self) -> Paren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren2R { bits }
            }
            # [ doc = "Bit 3 - PAREN3" ]
            # [ inline ( always ) ]
            pub fn paren3(&self) -> Paren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren3R { bits }
            }
            # [ doc = "Bit 4 - PAREN4" ]
            # [ inline ( always ) ]
            pub fn paren4(&self) -> Paren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren4R { bits }
            }
            # [ doc = "Bit 5 - PAREN5" ]
            # [ inline ( always ) ]
            pub fn paren5(&self) -> Paren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren5R { bits }
            }
            # [ doc = "Bit 6 - PAREN6" ]
            # [ inline ( always ) ]
            pub fn paren6(&self) -> Paren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren6R { bits }
            }
            # [ doc = "Bit 7 - PAREN7" ]
            # [ inline ( always ) ]
            pub fn paren7(&self) -> Paren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren7R { bits }
            }
            # [ doc = "Bit 8 - PAREN8" ]
            # [ inline ( always ) ]
            pub fn paren8(&self) -> Paren8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren8R { bits }
            }
            # [ doc = "Bit 9 - PAREN9" ]
            # [ inline ( always ) ]
            pub fn paren9(&self) -> Paren9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren9R { bits }
            }
            # [ doc = "Bit 10 - PAREN10" ]
            # [ inline ( always ) ]
            pub fn paren10(&self) -> Paren10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren10R { bits }
            }
            # [ doc = "Bit 11 - PAREN11" ]
            # [ inline ( always ) ]
            pub fn paren11(&self) -> Paren11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren11R { bits }
            }
            # [ doc = "Bit 12 - PAREN12" ]
            # [ inline ( always ) ]
            pub fn paren12(&self) -> Paren12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren12R { bits }
            }
            # [ doc = "Bit 13 - PAREN13" ]
            # [ inline ( always ) ]
            pub fn paren13(&self) -> Paren13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren13R { bits }
            }
            # [ doc = "Bit 14 - PAREN14" ]
            # [ inline ( always ) ]
            pub fn paren14(&self) -> Paren14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren14R { bits }
            }
            # [ doc = "Bit 15 - PAREN15" ]
            # [ inline ( always ) ]
            pub fn paren15(&self) -> Paren15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paren15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PAREN0" ]
            # [ inline ( always ) ]
            pub fn paren0(&mut self) -> _Paren0W {
                _Paren0W { w: self }
            }
            # [ doc = "Bit 1 - PAREN1" ]
            # [ inline ( always ) ]
            pub fn paren1(&mut self) -> _Paren1W {
                _Paren1W { w: self }
            }
            # [ doc = "Bit 2 - PAREN2" ]
            # [ inline ( always ) ]
            pub fn paren2(&mut self) -> _Paren2W {
                _Paren2W { w: self }
            }
            # [ doc = "Bit 3 - PAREN3" ]
            # [ inline ( always ) ]
            pub fn paren3(&mut self) -> _Paren3W {
                _Paren3W { w: self }
            }
            # [ doc = "Bit 4 - PAREN4" ]
            # [ inline ( always ) ]
            pub fn paren4(&mut self) -> _Paren4W {
                _Paren4W { w: self }
            }
            # [ doc = "Bit 5 - PAREN5" ]
            # [ inline ( always ) ]
            pub fn paren5(&mut self) -> _Paren5W {
                _Paren5W { w: self }
            }
            # [ doc = "Bit 6 - PAREN6" ]
            # [ inline ( always ) ]
            pub fn paren6(&mut self) -> _Paren6W {
                _Paren6W { w: self }
            }
            # [ doc = "Bit 7 - PAREN7" ]
            # [ inline ( always ) ]
            pub fn paren7(&mut self) -> _Paren7W {
                _Paren7W { w: self }
            }
            # [ doc = "Bit 8 - PAREN8" ]
            # [ inline ( always ) ]
            pub fn paren8(&mut self) -> _Paren8W {
                _Paren8W { w: self }
            }
            # [ doc = "Bit 9 - PAREN9" ]
            # [ inline ( always ) ]
            pub fn paren9(&mut self) -> _Paren9W {
                _Paren9W { w: self }
            }
            # [ doc = "Bit 10 - PAREN10" ]
            # [ inline ( always ) ]
            pub fn paren10(&mut self) -> _Paren10W {
                _Paren10W { w: self }
            }
            # [ doc = "Bit 11 - PAREN11" ]
            # [ inline ( always ) ]
            pub fn paren11(&mut self) -> _Paren11W {
                _Paren11W { w: self }
            }
            # [ doc = "Bit 12 - PAREN12" ]
            # [ inline ( always ) ]
            pub fn paren12(&mut self) -> _Paren12W {
                _Paren12W { w: self }
            }
            # [ doc = "Bit 13 - PAREN13" ]
            # [ inline ( always ) ]
            pub fn paren13(&mut self) -> _Paren13W {
                _Paren13W { w: self }
            }
            # [ doc = "Bit 14 - PAREN14" ]
            # [ inline ( always ) ]
            pub fn paren14(&mut self) -> _Paren14W {
                _Paren14W { w: self }
            }
            # [ doc = "Bit 15 - PAREN15" ]
            # [ inline ( always ) ]
            pub fn paren15(&mut self) -> _Paren15W {
                _Paren15W { w: self }
            }
        }
    }
    # [ doc = "Port A Drive Strenght" ]
    pub struct Pads {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Drive Strenght" ]
    pub mod pads {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pads {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads0R {
            bits: u8,
        }
        impl Pads0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads1R {
            bits: u8,
        }
        impl Pads1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads2R {
            bits: u8,
        }
        impl Pads2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads3R {
            bits: u8,
        }
        impl Pads3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads4R {
            bits: u8,
        }
        impl Pads4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads5R {
            bits: u8,
        }
        impl Pads5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads6R {
            bits: u8,
        }
        impl Pads6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads7R {
            bits: u8,
        }
        impl Pads7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads8R {
            bits: u8,
        }
        impl Pads8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads9R {
            bits: u8,
        }
        impl Pads9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads10R {
            bits: u8,
        }
        impl Pads10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads11R {
            bits: u8,
        }
        impl Pads11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads12R {
            bits: u8,
        }
        impl Pads12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads13R {
            bits: u8,
        }
        impl Pads13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads14R {
            bits: u8,
        }
        impl Pads14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pads15R {
            bits: u8,
        }
        impl Pads15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pads15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pads15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PADS0" ]
            # [ inline ( always ) ]
            pub fn pads0(&self) -> Pads0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads0R { bits }
            }
            # [ doc = "Bit 1 - PADS1" ]
            # [ inline ( always ) ]
            pub fn pads1(&self) -> Pads1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads1R { bits }
            }
            # [ doc = "Bit 2 - PADS2" ]
            # [ inline ( always ) ]
            pub fn pads2(&self) -> Pads2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads2R { bits }
            }
            # [ doc = "Bit 3 - PADS3" ]
            # [ inline ( always ) ]
            pub fn pads3(&self) -> Pads3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads3R { bits }
            }
            # [ doc = "Bit 4 - PADS4" ]
            # [ inline ( always ) ]
            pub fn pads4(&self) -> Pads4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads4R { bits }
            }
            # [ doc = "Bit 5 - PADS5" ]
            # [ inline ( always ) ]
            pub fn pads5(&self) -> Pads5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads5R { bits }
            }
            # [ doc = "Bit 6 - PADS6" ]
            # [ inline ( always ) ]
            pub fn pads6(&self) -> Pads6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads6R { bits }
            }
            # [ doc = "Bit 7 - PADS7" ]
            # [ inline ( always ) ]
            pub fn pads7(&self) -> Pads7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads7R { bits }
            }
            # [ doc = "Bit 8 - PADS8" ]
            # [ inline ( always ) ]
            pub fn pads8(&self) -> Pads8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads8R { bits }
            }
            # [ doc = "Bit 9 - PADS9" ]
            # [ inline ( always ) ]
            pub fn pads9(&self) -> Pads9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads9R { bits }
            }
            # [ doc = "Bit 10 - PADS10" ]
            # [ inline ( always ) ]
            pub fn pads10(&self) -> Pads10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads10R { bits }
            }
            # [ doc = "Bit 11 - PADS11" ]
            # [ inline ( always ) ]
            pub fn pads11(&self) -> Pads11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads11R { bits }
            }
            # [ doc = "Bit 12 - PADS12" ]
            # [ inline ( always ) ]
            pub fn pads12(&self) -> Pads12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads12R { bits }
            }
            # [ doc = "Bit 13 - PADS13" ]
            # [ inline ( always ) ]
            pub fn pads13(&self) -> Pads13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads13R { bits }
            }
            # [ doc = "Bit 14 - PADS14" ]
            # [ inline ( always ) ]
            pub fn pads14(&self) -> Pads14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads14R { bits }
            }
            # [ doc = "Bit 15 - PADS15" ]
            # [ inline ( always ) ]
            pub fn pads15(&self) -> Pads15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pads15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PADS0" ]
            # [ inline ( always ) ]
            pub fn pads0(&mut self) -> _Pads0W {
                _Pads0W { w: self }
            }
            # [ doc = "Bit 1 - PADS1" ]
            # [ inline ( always ) ]
            pub fn pads1(&mut self) -> _Pads1W {
                _Pads1W { w: self }
            }
            # [ doc = "Bit 2 - PADS2" ]
            # [ inline ( always ) ]
            pub fn pads2(&mut self) -> _Pads2W {
                _Pads2W { w: self }
            }
            # [ doc = "Bit 3 - PADS3" ]
            # [ inline ( always ) ]
            pub fn pads3(&mut self) -> _Pads3W {
                _Pads3W { w: self }
            }
            # [ doc = "Bit 4 - PADS4" ]
            # [ inline ( always ) ]
            pub fn pads4(&mut self) -> _Pads4W {
                _Pads4W { w: self }
            }
            # [ doc = "Bit 5 - PADS5" ]
            # [ inline ( always ) ]
            pub fn pads5(&mut self) -> _Pads5W {
                _Pads5W { w: self }
            }
            # [ doc = "Bit 6 - PADS6" ]
            # [ inline ( always ) ]
            pub fn pads6(&mut self) -> _Pads6W {
                _Pads6W { w: self }
            }
            # [ doc = "Bit 7 - PADS7" ]
            # [ inline ( always ) ]
            pub fn pads7(&mut self) -> _Pads7W {
                _Pads7W { w: self }
            }
            # [ doc = "Bit 8 - PADS8" ]
            # [ inline ( always ) ]
            pub fn pads8(&mut self) -> _Pads8W {
                _Pads8W { w: self }
            }
            # [ doc = "Bit 9 - PADS9" ]
            # [ inline ( always ) ]
            pub fn pads9(&mut self) -> _Pads9W {
                _Pads9W { w: self }
            }
            # [ doc = "Bit 10 - PADS10" ]
            # [ inline ( always ) ]
            pub fn pads10(&mut self) -> _Pads10W {
                _Pads10W { w: self }
            }
            # [ doc = "Bit 11 - PADS11" ]
            # [ inline ( always ) ]
            pub fn pads11(&mut self) -> _Pads11W {
                _Pads11W { w: self }
            }
            # [ doc = "Bit 12 - PADS12" ]
            # [ inline ( always ) ]
            pub fn pads12(&mut self) -> _Pads12W {
                _Pads12W { w: self }
            }
            # [ doc = "Bit 13 - PADS13" ]
            # [ inline ( always ) ]
            pub fn pads13(&mut self) -> _Pads13W {
                _Pads13W { w: self }
            }
            # [ doc = "Bit 14 - PADS14" ]
            # [ inline ( always ) ]
            pub fn pads14(&mut self) -> _Pads14W {
                _Pads14W { w: self }
            }
            # [ doc = "Bit 15 - PADS15" ]
            # [ inline ( always ) ]
            pub fn pads15(&mut self) -> _Pads15W {
                _Pads15W { w: self }
            }
        }
    }
    # [ doc = "Port A Selection" ]
    pub struct Pasel {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Selection" ]
    pub mod pasel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pasel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel0R {
            bits: u8,
        }
        impl Pasel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel1R {
            bits: u8,
        }
        impl Pasel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel2R {
            bits: u8,
        }
        impl Pasel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel3R {
            bits: u8,
        }
        impl Pasel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel4R {
            bits: u8,
        }
        impl Pasel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel5R {
            bits: u8,
        }
        impl Pasel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel6R {
            bits: u8,
        }
        impl Pasel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel7R {
            bits: u8,
        }
        impl Pasel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel8R {
            bits: u8,
        }
        impl Pasel8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel9R {
            bits: u8,
        }
        impl Pasel9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel10R {
            bits: u8,
        }
        impl Pasel10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel11R {
            bits: u8,
        }
        impl Pasel11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel12R {
            bits: u8,
        }
        impl Pasel12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel13R {
            bits: u8,
        }
        impl Pasel13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel14R {
            bits: u8,
        }
        impl Pasel14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pasel15R {
            bits: u8,
        }
        impl Pasel15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pasel15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pasel15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PASEL0" ]
            # [ inline ( always ) ]
            pub fn pasel0(&self) -> Pasel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel0R { bits }
            }
            # [ doc = "Bit 1 - PASEL1" ]
            # [ inline ( always ) ]
            pub fn pasel1(&self) -> Pasel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel1R { bits }
            }
            # [ doc = "Bit 2 - PASEL2" ]
            # [ inline ( always ) ]
            pub fn pasel2(&self) -> Pasel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel2R { bits }
            }
            # [ doc = "Bit 3 - PASEL3" ]
            # [ inline ( always ) ]
            pub fn pasel3(&self) -> Pasel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel3R { bits }
            }
            # [ doc = "Bit 4 - PASEL4" ]
            # [ inline ( always ) ]
            pub fn pasel4(&self) -> Pasel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel4R { bits }
            }
            # [ doc = "Bit 5 - PASEL5" ]
            # [ inline ( always ) ]
            pub fn pasel5(&self) -> Pasel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel5R { bits }
            }
            # [ doc = "Bit 6 - PASEL6" ]
            # [ inline ( always ) ]
            pub fn pasel6(&self) -> Pasel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel6R { bits }
            }
            # [ doc = "Bit 7 - PASEL7" ]
            # [ inline ( always ) ]
            pub fn pasel7(&self) -> Pasel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel7R { bits }
            }
            # [ doc = "Bit 8 - PASEL8" ]
            # [ inline ( always ) ]
            pub fn pasel8(&self) -> Pasel8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel8R { bits }
            }
            # [ doc = "Bit 9 - PASEL9" ]
            # [ inline ( always ) ]
            pub fn pasel9(&self) -> Pasel9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel9R { bits }
            }
            # [ doc = "Bit 10 - PASEL10" ]
            # [ inline ( always ) ]
            pub fn pasel10(&self) -> Pasel10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel10R { bits }
            }
            # [ doc = "Bit 11 - PASEL11" ]
            # [ inline ( always ) ]
            pub fn pasel11(&self) -> Pasel11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel11R { bits }
            }
            # [ doc = "Bit 12 - PASEL12" ]
            # [ inline ( always ) ]
            pub fn pasel12(&self) -> Pasel12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel12R { bits }
            }
            # [ doc = "Bit 13 - PASEL13" ]
            # [ inline ( always ) ]
            pub fn pasel13(&self) -> Pasel13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel13R { bits }
            }
            # [ doc = "Bit 14 - PASEL14" ]
            # [ inline ( always ) ]
            pub fn pasel14(&self) -> Pasel14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel14R { bits }
            }
            # [ doc = "Bit 15 - PASEL15" ]
            # [ inline ( always ) ]
            pub fn pasel15(&self) -> Pasel15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pasel15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PASEL0" ]
            # [ inline ( always ) ]
            pub fn pasel0(&mut self) -> _Pasel0W {
                _Pasel0W { w: self }
            }
            # [ doc = "Bit 1 - PASEL1" ]
            # [ inline ( always ) ]
            pub fn pasel1(&mut self) -> _Pasel1W {
                _Pasel1W { w: self }
            }
            # [ doc = "Bit 2 - PASEL2" ]
            # [ inline ( always ) ]
            pub fn pasel2(&mut self) -> _Pasel2W {
                _Pasel2W { w: self }
            }
            # [ doc = "Bit 3 - PASEL3" ]
            # [ inline ( always ) ]
            pub fn pasel3(&mut self) -> _Pasel3W {
                _Pasel3W { w: self }
            }
            # [ doc = "Bit 4 - PASEL4" ]
            # [ inline ( always ) ]
            pub fn pasel4(&mut self) -> _Pasel4W {
                _Pasel4W { w: self }
            }
            # [ doc = "Bit 5 - PASEL5" ]
            # [ inline ( always ) ]
            pub fn pasel5(&mut self) -> _Pasel5W {
                _Pasel5W { w: self }
            }
            # [ doc = "Bit 6 - PASEL6" ]
            # [ inline ( always ) ]
            pub fn pasel6(&mut self) -> _Pasel6W {
                _Pasel6W { w: self }
            }
            # [ doc = "Bit 7 - PASEL7" ]
            # [ inline ( always ) ]
            pub fn pasel7(&mut self) -> _Pasel7W {
                _Pasel7W { w: self }
            }
            # [ doc = "Bit 8 - PASEL8" ]
            # [ inline ( always ) ]
            pub fn pasel8(&mut self) -> _Pasel8W {
                _Pasel8W { w: self }
            }
            # [ doc = "Bit 9 - PASEL9" ]
            # [ inline ( always ) ]
            pub fn pasel9(&mut self) -> _Pasel9W {
                _Pasel9W { w: self }
            }
            # [ doc = "Bit 10 - PASEL10" ]
            # [ inline ( always ) ]
            pub fn pasel10(&mut self) -> _Pasel10W {
                _Pasel10W { w: self }
            }
            # [ doc = "Bit 11 - PASEL11" ]
            # [ inline ( always ) ]
            pub fn pasel11(&mut self) -> _Pasel11W {
                _Pasel11W { w: self }
            }
            # [ doc = "Bit 12 - PASEL12" ]
            # [ inline ( always ) ]
            pub fn pasel12(&mut self) -> _Pasel12W {
                _Pasel12W { w: self }
            }
            # [ doc = "Bit 13 - PASEL13" ]
            # [ inline ( always ) ]
            pub fn pasel13(&mut self) -> _Pasel13W {
                _Pasel13W { w: self }
            }
            # [ doc = "Bit 14 - PASEL14" ]
            # [ inline ( always ) ]
            pub fn pasel14(&mut self) -> _Pasel14W {
                _Pasel14W { w: self }
            }
            # [ doc = "Bit 15 - PASEL15" ]
            # [ inline ( always ) ]
            pub fn pasel15(&mut self) -> _Pasel15W {
                _Pasel15W { w: self }
            }
        }
    }
    # [ doc = "Port A Interrupt Edge Select" ]
    pub struct Paies {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Interrupt Edge Select" ]
    pub mod paies {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Paies {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies0R {
            bits: u8,
        }
        impl Paies0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies1R {
            bits: u8,
        }
        impl Paies1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies2R {
            bits: u8,
        }
        impl Paies2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies3R {
            bits: u8,
        }
        impl Paies3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies4R {
            bits: u8,
        }
        impl Paies4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies5R {
            bits: u8,
        }
        impl Paies5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies6R {
            bits: u8,
        }
        impl Paies6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies7R {
            bits: u8,
        }
        impl Paies7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies8R {
            bits: u8,
        }
        impl Paies8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies9R {
            bits: u8,
        }
        impl Paies9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies10R {
            bits: u8,
        }
        impl Paies10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies11R {
            bits: u8,
        }
        impl Paies11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies12R {
            bits: u8,
        }
        impl Paies12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies13R {
            bits: u8,
        }
        impl Paies13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies14R {
            bits: u8,
        }
        impl Paies14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paies15R {
            bits: u8,
        }
        impl Paies15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paies15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paies15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PAIES0" ]
            # [ inline ( always ) ]
            pub fn paies0(&self) -> Paies0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies0R { bits }
            }
            # [ doc = "Bit 1 - PAIES1" ]
            # [ inline ( always ) ]
            pub fn paies1(&self) -> Paies1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies1R { bits }
            }
            # [ doc = "Bit 2 - PAIES2" ]
            # [ inline ( always ) ]
            pub fn paies2(&self) -> Paies2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies2R { bits }
            }
            # [ doc = "Bit 3 - PAIES3" ]
            # [ inline ( always ) ]
            pub fn paies3(&self) -> Paies3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies3R { bits }
            }
            # [ doc = "Bit 4 - PAIES4" ]
            # [ inline ( always ) ]
            pub fn paies4(&self) -> Paies4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies4R { bits }
            }
            # [ doc = "Bit 5 - PAIES5" ]
            # [ inline ( always ) ]
            pub fn paies5(&self) -> Paies5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies5R { bits }
            }
            # [ doc = "Bit 6 - PAIES6" ]
            # [ inline ( always ) ]
            pub fn paies6(&self) -> Paies6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies6R { bits }
            }
            # [ doc = "Bit 7 - PAIES7" ]
            # [ inline ( always ) ]
            pub fn paies7(&self) -> Paies7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies7R { bits }
            }
            # [ doc = "Bit 8 - PAIES8" ]
            # [ inline ( always ) ]
            pub fn paies8(&self) -> Paies8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies8R { bits }
            }
            # [ doc = "Bit 9 - PAIES9" ]
            # [ inline ( always ) ]
            pub fn paies9(&self) -> Paies9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies9R { bits }
            }
            # [ doc = "Bit 10 - PAIES10" ]
            # [ inline ( always ) ]
            pub fn paies10(&self) -> Paies10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies10R { bits }
            }
            # [ doc = "Bit 11 - PAIES11" ]
            # [ inline ( always ) ]
            pub fn paies11(&self) -> Paies11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies11R { bits }
            }
            # [ doc = "Bit 12 - PAIES12" ]
            # [ inline ( always ) ]
            pub fn paies12(&self) -> Paies12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies12R { bits }
            }
            # [ doc = "Bit 13 - PAIES13" ]
            # [ inline ( always ) ]
            pub fn paies13(&self) -> Paies13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies13R { bits }
            }
            # [ doc = "Bit 14 - PAIES14" ]
            # [ inline ( always ) ]
            pub fn paies14(&self) -> Paies14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies14R { bits }
            }
            # [ doc = "Bit 15 - PAIES15" ]
            # [ inline ( always ) ]
            pub fn paies15(&self) -> Paies15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paies15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PAIES0" ]
            # [ inline ( always ) ]
            pub fn paies0(&mut self) -> _Paies0W {
                _Paies0W { w: self }
            }
            # [ doc = "Bit 1 - PAIES1" ]
            # [ inline ( always ) ]
            pub fn paies1(&mut self) -> _Paies1W {
                _Paies1W { w: self }
            }
            # [ doc = "Bit 2 - PAIES2" ]
            # [ inline ( always ) ]
            pub fn paies2(&mut self) -> _Paies2W {
                _Paies2W { w: self }
            }
            # [ doc = "Bit 3 - PAIES3" ]
            # [ inline ( always ) ]
            pub fn paies3(&mut self) -> _Paies3W {
                _Paies3W { w: self }
            }
            # [ doc = "Bit 4 - PAIES4" ]
            # [ inline ( always ) ]
            pub fn paies4(&mut self) -> _Paies4W {
                _Paies4W { w: self }
            }
            # [ doc = "Bit 5 - PAIES5" ]
            # [ inline ( always ) ]
            pub fn paies5(&mut self) -> _Paies5W {
                _Paies5W { w: self }
            }
            # [ doc = "Bit 6 - PAIES6" ]
            # [ inline ( always ) ]
            pub fn paies6(&mut self) -> _Paies6W {
                _Paies6W { w: self }
            }
            # [ doc = "Bit 7 - PAIES7" ]
            # [ inline ( always ) ]
            pub fn paies7(&mut self) -> _Paies7W {
                _Paies7W { w: self }
            }
            # [ doc = "Bit 8 - PAIES8" ]
            # [ inline ( always ) ]
            pub fn paies8(&mut self) -> _Paies8W {
                _Paies8W { w: self }
            }
            # [ doc = "Bit 9 - PAIES9" ]
            # [ inline ( always ) ]
            pub fn paies9(&mut self) -> _Paies9W {
                _Paies9W { w: self }
            }
            # [ doc = "Bit 10 - PAIES10" ]
            # [ inline ( always ) ]
            pub fn paies10(&mut self) -> _Paies10W {
                _Paies10W { w: self }
            }
            # [ doc = "Bit 11 - PAIES11" ]
            # [ inline ( always ) ]
            pub fn paies11(&mut self) -> _Paies11W {
                _Paies11W { w: self }
            }
            # [ doc = "Bit 12 - PAIES12" ]
            # [ inline ( always ) ]
            pub fn paies12(&mut self) -> _Paies12W {
                _Paies12W { w: self }
            }
            # [ doc = "Bit 13 - PAIES13" ]
            # [ inline ( always ) ]
            pub fn paies13(&mut self) -> _Paies13W {
                _Paies13W { w: self }
            }
            # [ doc = "Bit 14 - PAIES14" ]
            # [ inline ( always ) ]
            pub fn paies14(&mut self) -> _Paies14W {
                _Paies14W { w: self }
            }
            # [ doc = "Bit 15 - PAIES15" ]
            # [ inline ( always ) ]
            pub fn paies15(&mut self) -> _Paies15W {
                _Paies15W { w: self }
            }
        }
    }
    # [ doc = "Port A Interrupt Enable" ]
    pub struct Paie {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Interrupt Enable" ]
    pub mod paie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Paie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie0R {
            bits: u8,
        }
        impl Paie0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie1R {
            bits: u8,
        }
        impl Paie1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie2R {
            bits: u8,
        }
        impl Paie2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie3R {
            bits: u8,
        }
        impl Paie3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie4R {
            bits: u8,
        }
        impl Paie4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie5R {
            bits: u8,
        }
        impl Paie5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie6R {
            bits: u8,
        }
        impl Paie6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie7R {
            bits: u8,
        }
        impl Paie7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie8R {
            bits: u8,
        }
        impl Paie8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie9R {
            bits: u8,
        }
        impl Paie9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie10R {
            bits: u8,
        }
        impl Paie10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie11R {
            bits: u8,
        }
        impl Paie11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie12R {
            bits: u8,
        }
        impl Paie12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie13R {
            bits: u8,
        }
        impl Paie13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie14R {
            bits: u8,
        }
        impl Paie14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paie15R {
            bits: u8,
        }
        impl Paie15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paie15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paie15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PAIE0" ]
            # [ inline ( always ) ]
            pub fn paie0(&self) -> Paie0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie0R { bits }
            }
            # [ doc = "Bit 1 - PAIE1" ]
            # [ inline ( always ) ]
            pub fn paie1(&self) -> Paie1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie1R { bits }
            }
            # [ doc = "Bit 2 - PAIE2" ]
            # [ inline ( always ) ]
            pub fn paie2(&self) -> Paie2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie2R { bits }
            }
            # [ doc = "Bit 3 - PAIE3" ]
            # [ inline ( always ) ]
            pub fn paie3(&self) -> Paie3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie3R { bits }
            }
            # [ doc = "Bit 4 - PAIE4" ]
            # [ inline ( always ) ]
            pub fn paie4(&self) -> Paie4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie4R { bits }
            }
            # [ doc = "Bit 5 - PAIE5" ]
            # [ inline ( always ) ]
            pub fn paie5(&self) -> Paie5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie5R { bits }
            }
            # [ doc = "Bit 6 - PAIE6" ]
            # [ inline ( always ) ]
            pub fn paie6(&self) -> Paie6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie6R { bits }
            }
            # [ doc = "Bit 7 - PAIE7" ]
            # [ inline ( always ) ]
            pub fn paie7(&self) -> Paie7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie7R { bits }
            }
            # [ doc = "Bit 8 - PAIE8" ]
            # [ inline ( always ) ]
            pub fn paie8(&self) -> Paie8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie8R { bits }
            }
            # [ doc = "Bit 9 - PAIE9" ]
            # [ inline ( always ) ]
            pub fn paie9(&self) -> Paie9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie9R { bits }
            }
            # [ doc = "Bit 10 - PAIE10" ]
            # [ inline ( always ) ]
            pub fn paie10(&self) -> Paie10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie10R { bits }
            }
            # [ doc = "Bit 11 - PAIE11" ]
            # [ inline ( always ) ]
            pub fn paie11(&self) -> Paie11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie11R { bits }
            }
            # [ doc = "Bit 12 - PAIE12" ]
            # [ inline ( always ) ]
            pub fn paie12(&self) -> Paie12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie12R { bits }
            }
            # [ doc = "Bit 13 - PAIE13" ]
            # [ inline ( always ) ]
            pub fn paie13(&self) -> Paie13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie13R { bits }
            }
            # [ doc = "Bit 14 - PAIE14" ]
            # [ inline ( always ) ]
            pub fn paie14(&self) -> Paie14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie14R { bits }
            }
            # [ doc = "Bit 15 - PAIE15" ]
            # [ inline ( always ) ]
            pub fn paie15(&self) -> Paie15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paie15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PAIE0" ]
            # [ inline ( always ) ]
            pub fn paie0(&mut self) -> _Paie0W {
                _Paie0W { w: self }
            }
            # [ doc = "Bit 1 - PAIE1" ]
            # [ inline ( always ) ]
            pub fn paie1(&mut self) -> _Paie1W {
                _Paie1W { w: self }
            }
            # [ doc = "Bit 2 - PAIE2" ]
            # [ inline ( always ) ]
            pub fn paie2(&mut self) -> _Paie2W {
                _Paie2W { w: self }
            }
            # [ doc = "Bit 3 - PAIE3" ]
            # [ inline ( always ) ]
            pub fn paie3(&mut self) -> _Paie3W {
                _Paie3W { w: self }
            }
            # [ doc = "Bit 4 - PAIE4" ]
            # [ inline ( always ) ]
            pub fn paie4(&mut self) -> _Paie4W {
                _Paie4W { w: self }
            }
            # [ doc = "Bit 5 - PAIE5" ]
            # [ inline ( always ) ]
            pub fn paie5(&mut self) -> _Paie5W {
                _Paie5W { w: self }
            }
            # [ doc = "Bit 6 - PAIE6" ]
            # [ inline ( always ) ]
            pub fn paie6(&mut self) -> _Paie6W {
                _Paie6W { w: self }
            }
            # [ doc = "Bit 7 - PAIE7" ]
            # [ inline ( always ) ]
            pub fn paie7(&mut self) -> _Paie7W {
                _Paie7W { w: self }
            }
            # [ doc = "Bit 8 - PAIE8" ]
            # [ inline ( always ) ]
            pub fn paie8(&mut self) -> _Paie8W {
                _Paie8W { w: self }
            }
            # [ doc = "Bit 9 - PAIE9" ]
            # [ inline ( always ) ]
            pub fn paie9(&mut self) -> _Paie9W {
                _Paie9W { w: self }
            }
            # [ doc = "Bit 10 - PAIE10" ]
            # [ inline ( always ) ]
            pub fn paie10(&mut self) -> _Paie10W {
                _Paie10W { w: self }
            }
            # [ doc = "Bit 11 - PAIE11" ]
            # [ inline ( always ) ]
            pub fn paie11(&mut self) -> _Paie11W {
                _Paie11W { w: self }
            }
            # [ doc = "Bit 12 - PAIE12" ]
            # [ inline ( always ) ]
            pub fn paie12(&mut self) -> _Paie12W {
                _Paie12W { w: self }
            }
            # [ doc = "Bit 13 - PAIE13" ]
            # [ inline ( always ) ]
            pub fn paie13(&mut self) -> _Paie13W {
                _Paie13W { w: self }
            }
            # [ doc = "Bit 14 - PAIE14" ]
            # [ inline ( always ) ]
            pub fn paie14(&mut self) -> _Paie14W {
                _Paie14W { w: self }
            }
            # [ doc = "Bit 15 - PAIE15" ]
            # [ inline ( always ) ]
            pub fn paie15(&mut self) -> _Paie15W {
                _Paie15W { w: self }
            }
        }
    }
    # [ doc = "Port A Interrupt Flag" ]
    pub struct Paifg {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port A Interrupt Flag" ]
    pub mod paifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Paifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg0R {
            bits: u8,
        }
        impl Paifg0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg1R {
            bits: u8,
        }
        impl Paifg1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg2R {
            bits: u8,
        }
        impl Paifg2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg3R {
            bits: u8,
        }
        impl Paifg3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg4R {
            bits: u8,
        }
        impl Paifg4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg5R {
            bits: u8,
        }
        impl Paifg5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg6R {
            bits: u8,
        }
        impl Paifg6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg7R {
            bits: u8,
        }
        impl Paifg7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg8R {
            bits: u8,
        }
        impl Paifg8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg9R {
            bits: u8,
        }
        impl Paifg9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg10R {
            bits: u8,
        }
        impl Paifg10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg11R {
            bits: u8,
        }
        impl Paifg11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg12R {
            bits: u8,
        }
        impl Paifg12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg13R {
            bits: u8,
        }
        impl Paifg13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg14R {
            bits: u8,
        }
        impl Paifg14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Paifg15R {
            bits: u8,
        }
        impl Paifg15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Paifg15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Paifg15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PAIFG0" ]
            # [ inline ( always ) ]
            pub fn paifg0(&self) -> Paifg0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg0R { bits }
            }
            # [ doc = "Bit 1 - PAIFG1" ]
            # [ inline ( always ) ]
            pub fn paifg1(&self) -> Paifg1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg1R { bits }
            }
            # [ doc = "Bit 2 - PAIFG2" ]
            # [ inline ( always ) ]
            pub fn paifg2(&self) -> Paifg2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg2R { bits }
            }
            # [ doc = "Bit 3 - PAIFG3" ]
            # [ inline ( always ) ]
            pub fn paifg3(&self) -> Paifg3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg3R { bits }
            }
            # [ doc = "Bit 4 - PAIFG4" ]
            # [ inline ( always ) ]
            pub fn paifg4(&self) -> Paifg4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg4R { bits }
            }
            # [ doc = "Bit 5 - PAIFG5" ]
            # [ inline ( always ) ]
            pub fn paifg5(&self) -> Paifg5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg5R { bits }
            }
            # [ doc = "Bit 6 - PAIFG6" ]
            # [ inline ( always ) ]
            pub fn paifg6(&self) -> Paifg6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg6R { bits }
            }
            # [ doc = "Bit 7 - PAIFG7" ]
            # [ inline ( always ) ]
            pub fn paifg7(&self) -> Paifg7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg7R { bits }
            }
            # [ doc = "Bit 8 - PAIFG8" ]
            # [ inline ( always ) ]
            pub fn paifg8(&self) -> Paifg8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg8R { bits }
            }
            # [ doc = "Bit 9 - PAIFG9" ]
            # [ inline ( always ) ]
            pub fn paifg9(&self) -> Paifg9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg9R { bits }
            }
            # [ doc = "Bit 10 - PAIFG10" ]
            # [ inline ( always ) ]
            pub fn paifg10(&self) -> Paifg10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg10R { bits }
            }
            # [ doc = "Bit 11 - PAIFG11" ]
            # [ inline ( always ) ]
            pub fn paifg11(&self) -> Paifg11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg11R { bits }
            }
            # [ doc = "Bit 12 - PAIFG12" ]
            # [ inline ( always ) ]
            pub fn paifg12(&self) -> Paifg12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg12R { bits }
            }
            # [ doc = "Bit 13 - PAIFG13" ]
            # [ inline ( always ) ]
            pub fn paifg13(&self) -> Paifg13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg13R { bits }
            }
            # [ doc = "Bit 14 - PAIFG14" ]
            # [ inline ( always ) ]
            pub fn paifg14(&self) -> Paifg14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg14R { bits }
            }
            # [ doc = "Bit 15 - PAIFG15" ]
            # [ inline ( always ) ]
            pub fn paifg15(&self) -> Paifg15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Paifg15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PAIFG0" ]
            # [ inline ( always ) ]
            pub fn paifg0(&mut self) -> _Paifg0W {
                _Paifg0W { w: self }
            }
            # [ doc = "Bit 1 - PAIFG1" ]
            # [ inline ( always ) ]
            pub fn paifg1(&mut self) -> _Paifg1W {
                _Paifg1W { w: self }
            }
            # [ doc = "Bit 2 - PAIFG2" ]
            # [ inline ( always ) ]
            pub fn paifg2(&mut self) -> _Paifg2W {
                _Paifg2W { w: self }
            }
            # [ doc = "Bit 3 - PAIFG3" ]
            # [ inline ( always ) ]
            pub fn paifg3(&mut self) -> _Paifg3W {
                _Paifg3W { w: self }
            }
            # [ doc = "Bit 4 - PAIFG4" ]
            # [ inline ( always ) ]
            pub fn paifg4(&mut self) -> _Paifg4W {
                _Paifg4W { w: self }
            }
            # [ doc = "Bit 5 - PAIFG5" ]
            # [ inline ( always ) ]
            pub fn paifg5(&mut self) -> _Paifg5W {
                _Paifg5W { w: self }
            }
            # [ doc = "Bit 6 - PAIFG6" ]
            # [ inline ( always ) ]
            pub fn paifg6(&mut self) -> _Paifg6W {
                _Paifg6W { w: self }
            }
            # [ doc = "Bit 7 - PAIFG7" ]
            # [ inline ( always ) ]
            pub fn paifg7(&mut self) -> _Paifg7W {
                _Paifg7W { w: self }
            }
            # [ doc = "Bit 8 - PAIFG8" ]
            # [ inline ( always ) ]
            pub fn paifg8(&mut self) -> _Paifg8W {
                _Paifg8W { w: self }
            }
            # [ doc = "Bit 9 - PAIFG9" ]
            # [ inline ( always ) ]
            pub fn paifg9(&mut self) -> _Paifg9W {
                _Paifg9W { w: self }
            }
            # [ doc = "Bit 10 - PAIFG10" ]
            # [ inline ( always ) ]
            pub fn paifg10(&mut self) -> _Paifg10W {
                _Paifg10W { w: self }
            }
            # [ doc = "Bit 11 - PAIFG11" ]
            # [ inline ( always ) ]
            pub fn paifg11(&mut self) -> _Paifg11W {
                _Paifg11W { w: self }
            }
            # [ doc = "Bit 12 - PAIFG12" ]
            # [ inline ( always ) ]
            pub fn paifg12(&mut self) -> _Paifg12W {
                _Paifg12W { w: self }
            }
            # [ doc = "Bit 13 - PAIFG13" ]
            # [ inline ( always ) ]
            pub fn paifg13(&mut self) -> _Paifg13W {
                _Paifg13W { w: self }
            }
            # [ doc = "Bit 14 - PAIFG14" ]
            # [ inline ( always ) ]
            pub fn paifg14(&mut self) -> _Paifg14W {
                _Paifg14W { w: self }
            }
            # [ doc = "Bit 15 - PAIFG15" ]
            # [ inline ( always ) ]
            pub fn paifg15(&mut self) -> _Paifg15W {
                _Paifg15W { w: self }
            }
        }
    }
}
# [ doc = "Port A" ]
pub struct PortA {
    register_block: port_a::RegisterBlock,
}
impl Deref for PortA {
    type Target = port_a::RegisterBlock;
    fn deref(&self) -> &port_a::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port 1/2" ]
pub const PORT_1_2: Peripheral<Port12> = unsafe { Peripheral::new(0) };
# [ doc = "Port 1/2" ]
pub mod port_1_2 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 512usize],
        # [ doc = "0x200 - Port 1 Input" ]
        pub p1in: P1in,
        # [ doc = "0x201 - Port 2 Input" ]
        pub p2in: P2in,
        # [ doc = "0x202 - Port 1 Output" ]
        pub p1out: P1out,
        # [ doc = "0x203 - Port 2 Output" ]
        pub p2out: P2out,
        # [ doc = "0x204 - Port 1 Direction" ]
        pub p1dir: P1dir,
        # [ doc = "0x205 - Port 2 Direction" ]
        pub p2dir: P2dir,
        # [ doc = "0x206 - Port 1 Resistor Enable" ]
        pub p1ren: P1ren,
        # [ doc = "0x207 - Port 2 Resistor Enable" ]
        pub p2ren: P2ren,
        # [ doc = "0x208 - Port 1 Drive Strenght" ]
        pub p1ds: P1ds,
        # [ doc = "0x209 - Port 2 Drive Strenght" ]
        pub p2ds: P2ds,
        # [ doc = "0x20a - Port 1 Selection" ]
        pub p1sel: P1sel,
        # [ doc = "0x20b - Port 2 Selection" ]
        pub p2sel: P2sel,
        _reserved1: [u8; 2usize],
        # [ doc = "0x20e - Port 1 Interrupt Vector Word" ]
        pub p1iv: P1iv,
        _reserved2: [u8; 8usize],
        # [ doc = "0x218 - Port 1 Interrupt Edge Select" ]
        pub p1ies: P1ies,
        # [ doc = "0x219 - Port 2 Interrupt Edge Select" ]
        pub p2ies: P2ies,
        # [ doc = "0x21a - Port 1 Interrupt Enable" ]
        pub p1ie: P1ie,
        # [ doc = "0x21b - Port 2 Interrupt Enable" ]
        pub p2ie: P2ie,
        # [ doc = "0x21c - Port 1 Interrupt Flag" ]
        pub p1ifg: P1ifg,
        # [ doc = "0x21d - Port 2 Interrupt Flag" ]
        pub p2ifg: P2ifg,
        # [ doc = "0x21e - Port 2 Interrupt Vector Word" ]
        pub p2iv: P2iv,
    }
    # [ doc = "Port 1 Input" ]
    pub struct P1in {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Input" ]
    pub mod p1in {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1in {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in0R {
            bits: u8,
        }
        impl P1in0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in1R {
            bits: u8,
        }
        impl P1in1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in2R {
            bits: u8,
        }
        impl P1in2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in3R {
            bits: u8,
        }
        impl P1in3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in4R {
            bits: u8,
        }
        impl P1in4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in5R {
            bits: u8,
        }
        impl P1in5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in6R {
            bits: u8,
        }
        impl P1in6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1in7R {
            bits: u8,
        }
        impl P1in7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1in7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1in7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1IN0" ]
            # [ inline ( always ) ]
            pub fn p1in0(&self) -> P1in0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in0R { bits }
            }
            # [ doc = "Bit 1 - P1IN1" ]
            # [ inline ( always ) ]
            pub fn p1in1(&self) -> P1in1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in1R { bits }
            }
            # [ doc = "Bit 2 - P1IN2" ]
            # [ inline ( always ) ]
            pub fn p1in2(&self) -> P1in2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in2R { bits }
            }
            # [ doc = "Bit 3 - P1IN3" ]
            # [ inline ( always ) ]
            pub fn p1in3(&self) -> P1in3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in3R { bits }
            }
            # [ doc = "Bit 4 - P1IN4" ]
            # [ inline ( always ) ]
            pub fn p1in4(&self) -> P1in4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in4R { bits }
            }
            # [ doc = "Bit 5 - P1IN5" ]
            # [ inline ( always ) ]
            pub fn p1in5(&self) -> P1in5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in5R { bits }
            }
            # [ doc = "Bit 6 - P1IN6" ]
            # [ inline ( always ) ]
            pub fn p1in6(&self) -> P1in6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in6R { bits }
            }
            # [ doc = "Bit 7 - P1IN7" ]
            # [ inline ( always ) ]
            pub fn p1in7(&self) -> P1in7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1in7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1IN0" ]
            # [ inline ( always ) ]
            pub fn p1in0(&mut self) -> _P1in0W {
                _P1in0W { w: self }
            }
            # [ doc = "Bit 1 - P1IN1" ]
            # [ inline ( always ) ]
            pub fn p1in1(&mut self) -> _P1in1W {
                _P1in1W { w: self }
            }
            # [ doc = "Bit 2 - P1IN2" ]
            # [ inline ( always ) ]
            pub fn p1in2(&mut self) -> _P1in2W {
                _P1in2W { w: self }
            }
            # [ doc = "Bit 3 - P1IN3" ]
            # [ inline ( always ) ]
            pub fn p1in3(&mut self) -> _P1in3W {
                _P1in3W { w: self }
            }
            # [ doc = "Bit 4 - P1IN4" ]
            # [ inline ( always ) ]
            pub fn p1in4(&mut self) -> _P1in4W {
                _P1in4W { w: self }
            }
            # [ doc = "Bit 5 - P1IN5" ]
            # [ inline ( always ) ]
            pub fn p1in5(&mut self) -> _P1in5W {
                _P1in5W { w: self }
            }
            # [ doc = "Bit 6 - P1IN6" ]
            # [ inline ( always ) ]
            pub fn p1in6(&mut self) -> _P1in6W {
                _P1in6W { w: self }
            }
            # [ doc = "Bit 7 - P1IN7" ]
            # [ inline ( always ) ]
            pub fn p1in7(&mut self) -> _P1in7W {
                _P1in7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Output" ]
    pub struct P1out {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Output" ]
    pub mod p1out {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1out {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out0R {
            bits: u8,
        }
        impl P1out0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out1R {
            bits: u8,
        }
        impl P1out1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out2R {
            bits: u8,
        }
        impl P1out2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out3R {
            bits: u8,
        }
        impl P1out3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out4R {
            bits: u8,
        }
        impl P1out4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out5R {
            bits: u8,
        }
        impl P1out5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out6R {
            bits: u8,
        }
        impl P1out6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1out7R {
            bits: u8,
        }
        impl P1out7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1out7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1out7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1OUT0" ]
            # [ inline ( always ) ]
            pub fn p1out0(&self) -> P1out0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out0R { bits }
            }
            # [ doc = "Bit 1 - P1OUT1" ]
            # [ inline ( always ) ]
            pub fn p1out1(&self) -> P1out1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out1R { bits }
            }
            # [ doc = "Bit 2 - P1OUT2" ]
            # [ inline ( always ) ]
            pub fn p1out2(&self) -> P1out2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out2R { bits }
            }
            # [ doc = "Bit 3 - P1OUT3" ]
            # [ inline ( always ) ]
            pub fn p1out3(&self) -> P1out3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out3R { bits }
            }
            # [ doc = "Bit 4 - P1OUT4" ]
            # [ inline ( always ) ]
            pub fn p1out4(&self) -> P1out4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out4R { bits }
            }
            # [ doc = "Bit 5 - P1OUT5" ]
            # [ inline ( always ) ]
            pub fn p1out5(&self) -> P1out5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out5R { bits }
            }
            # [ doc = "Bit 6 - P1OUT6" ]
            # [ inline ( always ) ]
            pub fn p1out6(&self) -> P1out6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out6R { bits }
            }
            # [ doc = "Bit 7 - P1OUT7" ]
            # [ inline ( always ) ]
            pub fn p1out7(&self) -> P1out7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1out7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1OUT0" ]
            # [ inline ( always ) ]
            pub fn p1out0(&mut self) -> _P1out0W {
                _P1out0W { w: self }
            }
            # [ doc = "Bit 1 - P1OUT1" ]
            # [ inline ( always ) ]
            pub fn p1out1(&mut self) -> _P1out1W {
                _P1out1W { w: self }
            }
            # [ doc = "Bit 2 - P1OUT2" ]
            # [ inline ( always ) ]
            pub fn p1out2(&mut self) -> _P1out2W {
                _P1out2W { w: self }
            }
            # [ doc = "Bit 3 - P1OUT3" ]
            # [ inline ( always ) ]
            pub fn p1out3(&mut self) -> _P1out3W {
                _P1out3W { w: self }
            }
            # [ doc = "Bit 4 - P1OUT4" ]
            # [ inline ( always ) ]
            pub fn p1out4(&mut self) -> _P1out4W {
                _P1out4W { w: self }
            }
            # [ doc = "Bit 5 - P1OUT5" ]
            # [ inline ( always ) ]
            pub fn p1out5(&mut self) -> _P1out5W {
                _P1out5W { w: self }
            }
            # [ doc = "Bit 6 - P1OUT6" ]
            # [ inline ( always ) ]
            pub fn p1out6(&mut self) -> _P1out6W {
                _P1out6W { w: self }
            }
            # [ doc = "Bit 7 - P1OUT7" ]
            # [ inline ( always ) ]
            pub fn p1out7(&mut self) -> _P1out7W {
                _P1out7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Direction" ]
    pub struct P1dir {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Direction" ]
    pub mod p1dir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1dir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir0R {
            bits: u8,
        }
        impl P1dir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir1R {
            bits: u8,
        }
        impl P1dir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir2R {
            bits: u8,
        }
        impl P1dir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir3R {
            bits: u8,
        }
        impl P1dir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir4R {
            bits: u8,
        }
        impl P1dir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir5R {
            bits: u8,
        }
        impl P1dir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir6R {
            bits: u8,
        }
        impl P1dir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1dir7R {
            bits: u8,
        }
        impl P1dir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1dir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1dir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1DIR0" ]
            # [ inline ( always ) ]
            pub fn p1dir0(&self) -> P1dir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir0R { bits }
            }
            # [ doc = "Bit 1 - P1DIR1" ]
            # [ inline ( always ) ]
            pub fn p1dir1(&self) -> P1dir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir1R { bits }
            }
            # [ doc = "Bit 2 - P1DIR2" ]
            # [ inline ( always ) ]
            pub fn p1dir2(&self) -> P1dir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir2R { bits }
            }
            # [ doc = "Bit 3 - P1DIR3" ]
            # [ inline ( always ) ]
            pub fn p1dir3(&self) -> P1dir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir3R { bits }
            }
            # [ doc = "Bit 4 - P1DIR4" ]
            # [ inline ( always ) ]
            pub fn p1dir4(&self) -> P1dir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir4R { bits }
            }
            # [ doc = "Bit 5 - P1DIR5" ]
            # [ inline ( always ) ]
            pub fn p1dir5(&self) -> P1dir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir5R { bits }
            }
            # [ doc = "Bit 6 - P1DIR6" ]
            # [ inline ( always ) ]
            pub fn p1dir6(&self) -> P1dir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir6R { bits }
            }
            # [ doc = "Bit 7 - P1DIR7" ]
            # [ inline ( always ) ]
            pub fn p1dir7(&self) -> P1dir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1dir7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1DIR0" ]
            # [ inline ( always ) ]
            pub fn p1dir0(&mut self) -> _P1dir0W {
                _P1dir0W { w: self }
            }
            # [ doc = "Bit 1 - P1DIR1" ]
            # [ inline ( always ) ]
            pub fn p1dir1(&mut self) -> _P1dir1W {
                _P1dir1W { w: self }
            }
            # [ doc = "Bit 2 - P1DIR2" ]
            # [ inline ( always ) ]
            pub fn p1dir2(&mut self) -> _P1dir2W {
                _P1dir2W { w: self }
            }
            # [ doc = "Bit 3 - P1DIR3" ]
            # [ inline ( always ) ]
            pub fn p1dir3(&mut self) -> _P1dir3W {
                _P1dir3W { w: self }
            }
            # [ doc = "Bit 4 - P1DIR4" ]
            # [ inline ( always ) ]
            pub fn p1dir4(&mut self) -> _P1dir4W {
                _P1dir4W { w: self }
            }
            # [ doc = "Bit 5 - P1DIR5" ]
            # [ inline ( always ) ]
            pub fn p1dir5(&mut self) -> _P1dir5W {
                _P1dir5W { w: self }
            }
            # [ doc = "Bit 6 - P1DIR6" ]
            # [ inline ( always ) ]
            pub fn p1dir6(&mut self) -> _P1dir6W {
                _P1dir6W { w: self }
            }
            # [ doc = "Bit 7 - P1DIR7" ]
            # [ inline ( always ) ]
            pub fn p1dir7(&mut self) -> _P1dir7W {
                _P1dir7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Resistor Enable" ]
    pub struct P1ren {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Resistor Enable" ]
    pub mod p1ren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1ren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren0R {
            bits: u8,
        }
        impl P1ren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren1R {
            bits: u8,
        }
        impl P1ren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren2R {
            bits: u8,
        }
        impl P1ren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren3R {
            bits: u8,
        }
        impl P1ren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren4R {
            bits: u8,
        }
        impl P1ren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren5R {
            bits: u8,
        }
        impl P1ren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren6R {
            bits: u8,
        }
        impl P1ren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ren7R {
            bits: u8,
        }
        impl P1ren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1REN0" ]
            # [ inline ( always ) ]
            pub fn p1ren0(&self) -> P1ren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren0R { bits }
            }
            # [ doc = "Bit 1 - P1REN1" ]
            # [ inline ( always ) ]
            pub fn p1ren1(&self) -> P1ren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren1R { bits }
            }
            # [ doc = "Bit 2 - P1REN2" ]
            # [ inline ( always ) ]
            pub fn p1ren2(&self) -> P1ren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren2R { bits }
            }
            # [ doc = "Bit 3 - P1REN3" ]
            # [ inline ( always ) ]
            pub fn p1ren3(&self) -> P1ren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren3R { bits }
            }
            # [ doc = "Bit 4 - P1REN4" ]
            # [ inline ( always ) ]
            pub fn p1ren4(&self) -> P1ren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren4R { bits }
            }
            # [ doc = "Bit 5 - P1REN5" ]
            # [ inline ( always ) ]
            pub fn p1ren5(&self) -> P1ren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren5R { bits }
            }
            # [ doc = "Bit 6 - P1REN6" ]
            # [ inline ( always ) ]
            pub fn p1ren6(&self) -> P1ren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren6R { bits }
            }
            # [ doc = "Bit 7 - P1REN7" ]
            # [ inline ( always ) ]
            pub fn p1ren7(&self) -> P1ren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ren7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1REN0" ]
            # [ inline ( always ) ]
            pub fn p1ren0(&mut self) -> _P1ren0W {
                _P1ren0W { w: self }
            }
            # [ doc = "Bit 1 - P1REN1" ]
            # [ inline ( always ) ]
            pub fn p1ren1(&mut self) -> _P1ren1W {
                _P1ren1W { w: self }
            }
            # [ doc = "Bit 2 - P1REN2" ]
            # [ inline ( always ) ]
            pub fn p1ren2(&mut self) -> _P1ren2W {
                _P1ren2W { w: self }
            }
            # [ doc = "Bit 3 - P1REN3" ]
            # [ inline ( always ) ]
            pub fn p1ren3(&mut self) -> _P1ren3W {
                _P1ren3W { w: self }
            }
            # [ doc = "Bit 4 - P1REN4" ]
            # [ inline ( always ) ]
            pub fn p1ren4(&mut self) -> _P1ren4W {
                _P1ren4W { w: self }
            }
            # [ doc = "Bit 5 - P1REN5" ]
            # [ inline ( always ) ]
            pub fn p1ren5(&mut self) -> _P1ren5W {
                _P1ren5W { w: self }
            }
            # [ doc = "Bit 6 - P1REN6" ]
            # [ inline ( always ) ]
            pub fn p1ren6(&mut self) -> _P1ren6W {
                _P1ren6W { w: self }
            }
            # [ doc = "Bit 7 - P1REN7" ]
            # [ inline ( always ) ]
            pub fn p1ren7(&mut self) -> _P1ren7W {
                _P1ren7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Drive Strenght" ]
    pub struct P1ds {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Drive Strenght" ]
    pub mod p1ds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1ds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds0R {
            bits: u8,
        }
        impl P1ds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds1R {
            bits: u8,
        }
        impl P1ds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds2R {
            bits: u8,
        }
        impl P1ds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds3R {
            bits: u8,
        }
        impl P1ds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds4R {
            bits: u8,
        }
        impl P1ds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds5R {
            bits: u8,
        }
        impl P1ds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds6R {
            bits: u8,
        }
        impl P1ds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ds7R {
            bits: u8,
        }
        impl P1ds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1DS0" ]
            # [ inline ( always ) ]
            pub fn p1ds0(&self) -> P1ds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds0R { bits }
            }
            # [ doc = "Bit 1 - P1DS1" ]
            # [ inline ( always ) ]
            pub fn p1ds1(&self) -> P1ds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds1R { bits }
            }
            # [ doc = "Bit 2 - P1DS2" ]
            # [ inline ( always ) ]
            pub fn p1ds2(&self) -> P1ds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds2R { bits }
            }
            # [ doc = "Bit 3 - P1DS3" ]
            # [ inline ( always ) ]
            pub fn p1ds3(&self) -> P1ds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds3R { bits }
            }
            # [ doc = "Bit 4 - P1DS4" ]
            # [ inline ( always ) ]
            pub fn p1ds4(&self) -> P1ds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds4R { bits }
            }
            # [ doc = "Bit 5 - P1DS5" ]
            # [ inline ( always ) ]
            pub fn p1ds5(&self) -> P1ds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds5R { bits }
            }
            # [ doc = "Bit 6 - P1DS6" ]
            # [ inline ( always ) ]
            pub fn p1ds6(&self) -> P1ds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds6R { bits }
            }
            # [ doc = "Bit 7 - P1DS7" ]
            # [ inline ( always ) ]
            pub fn p1ds7(&self) -> P1ds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ds7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1DS0" ]
            # [ inline ( always ) ]
            pub fn p1ds0(&mut self) -> _P1ds0W {
                _P1ds0W { w: self }
            }
            # [ doc = "Bit 1 - P1DS1" ]
            # [ inline ( always ) ]
            pub fn p1ds1(&mut self) -> _P1ds1W {
                _P1ds1W { w: self }
            }
            # [ doc = "Bit 2 - P1DS2" ]
            # [ inline ( always ) ]
            pub fn p1ds2(&mut self) -> _P1ds2W {
                _P1ds2W { w: self }
            }
            # [ doc = "Bit 3 - P1DS3" ]
            # [ inline ( always ) ]
            pub fn p1ds3(&mut self) -> _P1ds3W {
                _P1ds3W { w: self }
            }
            # [ doc = "Bit 4 - P1DS4" ]
            # [ inline ( always ) ]
            pub fn p1ds4(&mut self) -> _P1ds4W {
                _P1ds4W { w: self }
            }
            # [ doc = "Bit 5 - P1DS5" ]
            # [ inline ( always ) ]
            pub fn p1ds5(&mut self) -> _P1ds5W {
                _P1ds5W { w: self }
            }
            # [ doc = "Bit 6 - P1DS6" ]
            # [ inline ( always ) ]
            pub fn p1ds6(&mut self) -> _P1ds6W {
                _P1ds6W { w: self }
            }
            # [ doc = "Bit 7 - P1DS7" ]
            # [ inline ( always ) ]
            pub fn p1ds7(&mut self) -> _P1ds7W {
                _P1ds7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Selection" ]
    pub struct P1sel {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Selection" ]
    pub mod p1sel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1sel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel0R {
            bits: u8,
        }
        impl P1sel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel1R {
            bits: u8,
        }
        impl P1sel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel2R {
            bits: u8,
        }
        impl P1sel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel3R {
            bits: u8,
        }
        impl P1sel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel4R {
            bits: u8,
        }
        impl P1sel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel5R {
            bits: u8,
        }
        impl P1sel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel6R {
            bits: u8,
        }
        impl P1sel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1sel7R {
            bits: u8,
        }
        impl P1sel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1sel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1sel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1SEL0" ]
            # [ inline ( always ) ]
            pub fn p1sel0(&self) -> P1sel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel0R { bits }
            }
            # [ doc = "Bit 1 - P1SEL1" ]
            # [ inline ( always ) ]
            pub fn p1sel1(&self) -> P1sel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel1R { bits }
            }
            # [ doc = "Bit 2 - P1SEL2" ]
            # [ inline ( always ) ]
            pub fn p1sel2(&self) -> P1sel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel2R { bits }
            }
            # [ doc = "Bit 3 - P1SEL3" ]
            # [ inline ( always ) ]
            pub fn p1sel3(&self) -> P1sel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel3R { bits }
            }
            # [ doc = "Bit 4 - P1SEL4" ]
            # [ inline ( always ) ]
            pub fn p1sel4(&self) -> P1sel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel4R { bits }
            }
            # [ doc = "Bit 5 - P1SEL5" ]
            # [ inline ( always ) ]
            pub fn p1sel5(&self) -> P1sel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel5R { bits }
            }
            # [ doc = "Bit 6 - P1SEL6" ]
            # [ inline ( always ) ]
            pub fn p1sel6(&self) -> P1sel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel6R { bits }
            }
            # [ doc = "Bit 7 - P1SEL7" ]
            # [ inline ( always ) ]
            pub fn p1sel7(&self) -> P1sel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1sel7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1SEL0" ]
            # [ inline ( always ) ]
            pub fn p1sel0(&mut self) -> _P1sel0W {
                _P1sel0W { w: self }
            }
            # [ doc = "Bit 1 - P1SEL1" ]
            # [ inline ( always ) ]
            pub fn p1sel1(&mut self) -> _P1sel1W {
                _P1sel1W { w: self }
            }
            # [ doc = "Bit 2 - P1SEL2" ]
            # [ inline ( always ) ]
            pub fn p1sel2(&mut self) -> _P1sel2W {
                _P1sel2W { w: self }
            }
            # [ doc = "Bit 3 - P1SEL3" ]
            # [ inline ( always ) ]
            pub fn p1sel3(&mut self) -> _P1sel3W {
                _P1sel3W { w: self }
            }
            # [ doc = "Bit 4 - P1SEL4" ]
            # [ inline ( always ) ]
            pub fn p1sel4(&mut self) -> _P1sel4W {
                _P1sel4W { w: self }
            }
            # [ doc = "Bit 5 - P1SEL5" ]
            # [ inline ( always ) ]
            pub fn p1sel5(&mut self) -> _P1sel5W {
                _P1sel5W { w: self }
            }
            # [ doc = "Bit 6 - P1SEL6" ]
            # [ inline ( always ) ]
            pub fn p1sel6(&mut self) -> _P1sel6W {
                _P1sel6W { w: self }
            }
            # [ doc = "Bit 7 - P1SEL7" ]
            # [ inline ( always ) ]
            pub fn p1sel7(&mut self) -> _P1sel7W {
                _P1sel7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Interrupt Vector Word" ]
    pub struct P1iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port 1 Interrupt Vector Word" ]
    pub mod p1iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P1iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Port 1 Interrupt Edge Select" ]
    pub struct P1ies {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Interrupt Edge Select" ]
    pub mod p1ies {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1ies {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies0R {
            bits: u8,
        }
        impl P1ies0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies1R {
            bits: u8,
        }
        impl P1ies1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies2R {
            bits: u8,
        }
        impl P1ies2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies3R {
            bits: u8,
        }
        impl P1ies3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies4R {
            bits: u8,
        }
        impl P1ies4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies5R {
            bits: u8,
        }
        impl P1ies5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies6R {
            bits: u8,
        }
        impl P1ies6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ies7R {
            bits: u8,
        }
        impl P1ies7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ies7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ies7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1IES0" ]
            # [ inline ( always ) ]
            pub fn p1ies0(&self) -> P1ies0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies0R { bits }
            }
            # [ doc = "Bit 1 - P1IES1" ]
            # [ inline ( always ) ]
            pub fn p1ies1(&self) -> P1ies1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies1R { bits }
            }
            # [ doc = "Bit 2 - P1IES2" ]
            # [ inline ( always ) ]
            pub fn p1ies2(&self) -> P1ies2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies2R { bits }
            }
            # [ doc = "Bit 3 - P1IES3" ]
            # [ inline ( always ) ]
            pub fn p1ies3(&self) -> P1ies3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies3R { bits }
            }
            # [ doc = "Bit 4 - P1IES4" ]
            # [ inline ( always ) ]
            pub fn p1ies4(&self) -> P1ies4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies4R { bits }
            }
            # [ doc = "Bit 5 - P1IES5" ]
            # [ inline ( always ) ]
            pub fn p1ies5(&self) -> P1ies5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies5R { bits }
            }
            # [ doc = "Bit 6 - P1IES6" ]
            # [ inline ( always ) ]
            pub fn p1ies6(&self) -> P1ies6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies6R { bits }
            }
            # [ doc = "Bit 7 - P1IES7" ]
            # [ inline ( always ) ]
            pub fn p1ies7(&self) -> P1ies7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ies7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1IES0" ]
            # [ inline ( always ) ]
            pub fn p1ies0(&mut self) -> _P1ies0W {
                _P1ies0W { w: self }
            }
            # [ doc = "Bit 1 - P1IES1" ]
            # [ inline ( always ) ]
            pub fn p1ies1(&mut self) -> _P1ies1W {
                _P1ies1W { w: self }
            }
            # [ doc = "Bit 2 - P1IES2" ]
            # [ inline ( always ) ]
            pub fn p1ies2(&mut self) -> _P1ies2W {
                _P1ies2W { w: self }
            }
            # [ doc = "Bit 3 - P1IES3" ]
            # [ inline ( always ) ]
            pub fn p1ies3(&mut self) -> _P1ies3W {
                _P1ies3W { w: self }
            }
            # [ doc = "Bit 4 - P1IES4" ]
            # [ inline ( always ) ]
            pub fn p1ies4(&mut self) -> _P1ies4W {
                _P1ies4W { w: self }
            }
            # [ doc = "Bit 5 - P1IES5" ]
            # [ inline ( always ) ]
            pub fn p1ies5(&mut self) -> _P1ies5W {
                _P1ies5W { w: self }
            }
            # [ doc = "Bit 6 - P1IES6" ]
            # [ inline ( always ) ]
            pub fn p1ies6(&mut self) -> _P1ies6W {
                _P1ies6W { w: self }
            }
            # [ doc = "Bit 7 - P1IES7" ]
            # [ inline ( always ) ]
            pub fn p1ies7(&mut self) -> _P1ies7W {
                _P1ies7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Interrupt Enable" ]
    pub struct P1ie {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Interrupt Enable" ]
    pub mod p1ie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1ie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie0R {
            bits: u8,
        }
        impl P1ie0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie1R {
            bits: u8,
        }
        impl P1ie1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie2R {
            bits: u8,
        }
        impl P1ie2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie3R {
            bits: u8,
        }
        impl P1ie3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie4R {
            bits: u8,
        }
        impl P1ie4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie5R {
            bits: u8,
        }
        impl P1ie5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie6R {
            bits: u8,
        }
        impl P1ie6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ie7R {
            bits: u8,
        }
        impl P1ie7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ie7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ie7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1IE0" ]
            # [ inline ( always ) ]
            pub fn p1ie0(&self) -> P1ie0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie0R { bits }
            }
            # [ doc = "Bit 1 - P1IE1" ]
            # [ inline ( always ) ]
            pub fn p1ie1(&self) -> P1ie1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie1R { bits }
            }
            # [ doc = "Bit 2 - P1IE2" ]
            # [ inline ( always ) ]
            pub fn p1ie2(&self) -> P1ie2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie2R { bits }
            }
            # [ doc = "Bit 3 - P1IE3" ]
            # [ inline ( always ) ]
            pub fn p1ie3(&self) -> P1ie3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie3R { bits }
            }
            # [ doc = "Bit 4 - P1IE4" ]
            # [ inline ( always ) ]
            pub fn p1ie4(&self) -> P1ie4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie4R { bits }
            }
            # [ doc = "Bit 5 - P1IE5" ]
            # [ inline ( always ) ]
            pub fn p1ie5(&self) -> P1ie5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie5R { bits }
            }
            # [ doc = "Bit 6 - P1IE6" ]
            # [ inline ( always ) ]
            pub fn p1ie6(&self) -> P1ie6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie6R { bits }
            }
            # [ doc = "Bit 7 - P1IE7" ]
            # [ inline ( always ) ]
            pub fn p1ie7(&self) -> P1ie7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ie7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1IE0" ]
            # [ inline ( always ) ]
            pub fn p1ie0(&mut self) -> _P1ie0W {
                _P1ie0W { w: self }
            }
            # [ doc = "Bit 1 - P1IE1" ]
            # [ inline ( always ) ]
            pub fn p1ie1(&mut self) -> _P1ie1W {
                _P1ie1W { w: self }
            }
            # [ doc = "Bit 2 - P1IE2" ]
            # [ inline ( always ) ]
            pub fn p1ie2(&mut self) -> _P1ie2W {
                _P1ie2W { w: self }
            }
            # [ doc = "Bit 3 - P1IE3" ]
            # [ inline ( always ) ]
            pub fn p1ie3(&mut self) -> _P1ie3W {
                _P1ie3W { w: self }
            }
            # [ doc = "Bit 4 - P1IE4" ]
            # [ inline ( always ) ]
            pub fn p1ie4(&mut self) -> _P1ie4W {
                _P1ie4W { w: self }
            }
            # [ doc = "Bit 5 - P1IE5" ]
            # [ inline ( always ) ]
            pub fn p1ie5(&mut self) -> _P1ie5W {
                _P1ie5W { w: self }
            }
            # [ doc = "Bit 6 - P1IE6" ]
            # [ inline ( always ) ]
            pub fn p1ie6(&mut self) -> _P1ie6W {
                _P1ie6W { w: self }
            }
            # [ doc = "Bit 7 - P1IE7" ]
            # [ inline ( always ) ]
            pub fn p1ie7(&mut self) -> _P1ie7W {
                _P1ie7W { w: self }
            }
        }
    }
    # [ doc = "Port 1 Interrupt Flag" ]
    pub struct P1ifg {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 1 Interrupt Flag" ]
    pub mod p1ifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1ifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg0R {
            bits: u8,
        }
        impl P1ifg0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg1R {
            bits: u8,
        }
        impl P1ifg1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg2R {
            bits: u8,
        }
        impl P1ifg2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg3R {
            bits: u8,
        }
        impl P1ifg3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg4R {
            bits: u8,
        }
        impl P1ifg4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg5R {
            bits: u8,
        }
        impl P1ifg5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg6R {
            bits: u8,
        }
        impl P1ifg6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P1ifg7R {
            bits: u8,
        }
        impl P1ifg7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P1ifg7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P1ifg7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P1IFG0" ]
            # [ inline ( always ) ]
            pub fn p1ifg0(&self) -> P1ifg0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg0R { bits }
            }
            # [ doc = "Bit 1 - P1IFG1" ]
            # [ inline ( always ) ]
            pub fn p1ifg1(&self) -> P1ifg1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg1R { bits }
            }
            # [ doc = "Bit 2 - P1IFG2" ]
            # [ inline ( always ) ]
            pub fn p1ifg2(&self) -> P1ifg2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg2R { bits }
            }
            # [ doc = "Bit 3 - P1IFG3" ]
            # [ inline ( always ) ]
            pub fn p1ifg3(&self) -> P1ifg3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg3R { bits }
            }
            # [ doc = "Bit 4 - P1IFG4" ]
            # [ inline ( always ) ]
            pub fn p1ifg4(&self) -> P1ifg4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg4R { bits }
            }
            # [ doc = "Bit 5 - P1IFG5" ]
            # [ inline ( always ) ]
            pub fn p1ifg5(&self) -> P1ifg5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg5R { bits }
            }
            # [ doc = "Bit 6 - P1IFG6" ]
            # [ inline ( always ) ]
            pub fn p1ifg6(&self) -> P1ifg6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg6R { bits }
            }
            # [ doc = "Bit 7 - P1IFG7" ]
            # [ inline ( always ) ]
            pub fn p1ifg7(&self) -> P1ifg7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P1ifg7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P1IFG0" ]
            # [ inline ( always ) ]
            pub fn p1ifg0(&mut self) -> _P1ifg0W {
                _P1ifg0W { w: self }
            }
            # [ doc = "Bit 1 - P1IFG1" ]
            # [ inline ( always ) ]
            pub fn p1ifg1(&mut self) -> _P1ifg1W {
                _P1ifg1W { w: self }
            }
            # [ doc = "Bit 2 - P1IFG2" ]
            # [ inline ( always ) ]
            pub fn p1ifg2(&mut self) -> _P1ifg2W {
                _P1ifg2W { w: self }
            }
            # [ doc = "Bit 3 - P1IFG3" ]
            # [ inline ( always ) ]
            pub fn p1ifg3(&mut self) -> _P1ifg3W {
                _P1ifg3W { w: self }
            }
            # [ doc = "Bit 4 - P1IFG4" ]
            # [ inline ( always ) ]
            pub fn p1ifg4(&mut self) -> _P1ifg4W {
                _P1ifg4W { w: self }
            }
            # [ doc = "Bit 5 - P1IFG5" ]
            # [ inline ( always ) ]
            pub fn p1ifg5(&mut self) -> _P1ifg5W {
                _P1ifg5W { w: self }
            }
            # [ doc = "Bit 6 - P1IFG6" ]
            # [ inline ( always ) ]
            pub fn p1ifg6(&mut self) -> _P1ifg6W {
                _P1ifg6W { w: self }
            }
            # [ doc = "Bit 7 - P1IFG7" ]
            # [ inline ( always ) ]
            pub fn p1ifg7(&mut self) -> _P1ifg7W {
                _P1ifg7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Input" ]
    pub struct P2in {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Input" ]
    pub mod p2in {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2in {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in0R {
            bits: u8,
        }
        impl P2in0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in1R {
            bits: u8,
        }
        impl P2in1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in2R {
            bits: u8,
        }
        impl P2in2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in3R {
            bits: u8,
        }
        impl P2in3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in4R {
            bits: u8,
        }
        impl P2in4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in5R {
            bits: u8,
        }
        impl P2in5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in6R {
            bits: u8,
        }
        impl P2in6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2in7R {
            bits: u8,
        }
        impl P2in7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2in7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2in7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2IN0" ]
            # [ inline ( always ) ]
            pub fn p2in0(&self) -> P2in0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in0R { bits }
            }
            # [ doc = "Bit 1 - P2IN1" ]
            # [ inline ( always ) ]
            pub fn p2in1(&self) -> P2in1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in1R { bits }
            }
            # [ doc = "Bit 2 - P2IN2" ]
            # [ inline ( always ) ]
            pub fn p2in2(&self) -> P2in2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in2R { bits }
            }
            # [ doc = "Bit 3 - P2IN3" ]
            # [ inline ( always ) ]
            pub fn p2in3(&self) -> P2in3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in3R { bits }
            }
            # [ doc = "Bit 4 - P2IN4" ]
            # [ inline ( always ) ]
            pub fn p2in4(&self) -> P2in4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in4R { bits }
            }
            # [ doc = "Bit 5 - P2IN5" ]
            # [ inline ( always ) ]
            pub fn p2in5(&self) -> P2in5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in5R { bits }
            }
            # [ doc = "Bit 6 - P2IN6" ]
            # [ inline ( always ) ]
            pub fn p2in6(&self) -> P2in6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in6R { bits }
            }
            # [ doc = "Bit 7 - P2IN7" ]
            # [ inline ( always ) ]
            pub fn p2in7(&self) -> P2in7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2in7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2IN0" ]
            # [ inline ( always ) ]
            pub fn p2in0(&mut self) -> _P2in0W {
                _P2in0W { w: self }
            }
            # [ doc = "Bit 1 - P2IN1" ]
            # [ inline ( always ) ]
            pub fn p2in1(&mut self) -> _P2in1W {
                _P2in1W { w: self }
            }
            # [ doc = "Bit 2 - P2IN2" ]
            # [ inline ( always ) ]
            pub fn p2in2(&mut self) -> _P2in2W {
                _P2in2W { w: self }
            }
            # [ doc = "Bit 3 - P2IN3" ]
            # [ inline ( always ) ]
            pub fn p2in3(&mut self) -> _P2in3W {
                _P2in3W { w: self }
            }
            # [ doc = "Bit 4 - P2IN4" ]
            # [ inline ( always ) ]
            pub fn p2in4(&mut self) -> _P2in4W {
                _P2in4W { w: self }
            }
            # [ doc = "Bit 5 - P2IN5" ]
            # [ inline ( always ) ]
            pub fn p2in5(&mut self) -> _P2in5W {
                _P2in5W { w: self }
            }
            # [ doc = "Bit 6 - P2IN6" ]
            # [ inline ( always ) ]
            pub fn p2in6(&mut self) -> _P2in6W {
                _P2in6W { w: self }
            }
            # [ doc = "Bit 7 - P2IN7" ]
            # [ inline ( always ) ]
            pub fn p2in7(&mut self) -> _P2in7W {
                _P2in7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Output" ]
    pub struct P2out {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Output" ]
    pub mod p2out {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2out {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out0R {
            bits: u8,
        }
        impl P2out0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out1R {
            bits: u8,
        }
        impl P2out1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out2R {
            bits: u8,
        }
        impl P2out2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out3R {
            bits: u8,
        }
        impl P2out3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out4R {
            bits: u8,
        }
        impl P2out4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out5R {
            bits: u8,
        }
        impl P2out5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out6R {
            bits: u8,
        }
        impl P2out6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2out7R {
            bits: u8,
        }
        impl P2out7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2out7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2out7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2OUT0" ]
            # [ inline ( always ) ]
            pub fn p2out0(&self) -> P2out0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out0R { bits }
            }
            # [ doc = "Bit 1 - P2OUT1" ]
            # [ inline ( always ) ]
            pub fn p2out1(&self) -> P2out1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out1R { bits }
            }
            # [ doc = "Bit 2 - P2OUT2" ]
            # [ inline ( always ) ]
            pub fn p2out2(&self) -> P2out2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out2R { bits }
            }
            # [ doc = "Bit 3 - P2OUT3" ]
            # [ inline ( always ) ]
            pub fn p2out3(&self) -> P2out3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out3R { bits }
            }
            # [ doc = "Bit 4 - P2OUT4" ]
            # [ inline ( always ) ]
            pub fn p2out4(&self) -> P2out4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out4R { bits }
            }
            # [ doc = "Bit 5 - P2OUT5" ]
            # [ inline ( always ) ]
            pub fn p2out5(&self) -> P2out5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out5R { bits }
            }
            # [ doc = "Bit 6 - P2OUT6" ]
            # [ inline ( always ) ]
            pub fn p2out6(&self) -> P2out6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out6R { bits }
            }
            # [ doc = "Bit 7 - P2OUT7" ]
            # [ inline ( always ) ]
            pub fn p2out7(&self) -> P2out7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2out7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2OUT0" ]
            # [ inline ( always ) ]
            pub fn p2out0(&mut self) -> _P2out0W {
                _P2out0W { w: self }
            }
            # [ doc = "Bit 1 - P2OUT1" ]
            # [ inline ( always ) ]
            pub fn p2out1(&mut self) -> _P2out1W {
                _P2out1W { w: self }
            }
            # [ doc = "Bit 2 - P2OUT2" ]
            # [ inline ( always ) ]
            pub fn p2out2(&mut self) -> _P2out2W {
                _P2out2W { w: self }
            }
            # [ doc = "Bit 3 - P2OUT3" ]
            # [ inline ( always ) ]
            pub fn p2out3(&mut self) -> _P2out3W {
                _P2out3W { w: self }
            }
            # [ doc = "Bit 4 - P2OUT4" ]
            # [ inline ( always ) ]
            pub fn p2out4(&mut self) -> _P2out4W {
                _P2out4W { w: self }
            }
            # [ doc = "Bit 5 - P2OUT5" ]
            # [ inline ( always ) ]
            pub fn p2out5(&mut self) -> _P2out5W {
                _P2out5W { w: self }
            }
            # [ doc = "Bit 6 - P2OUT6" ]
            # [ inline ( always ) ]
            pub fn p2out6(&mut self) -> _P2out6W {
                _P2out6W { w: self }
            }
            # [ doc = "Bit 7 - P2OUT7" ]
            # [ inline ( always ) ]
            pub fn p2out7(&mut self) -> _P2out7W {
                _P2out7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Direction" ]
    pub struct P2dir {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Direction" ]
    pub mod p2dir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2dir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir0R {
            bits: u8,
        }
        impl P2dir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir1R {
            bits: u8,
        }
        impl P2dir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir2R {
            bits: u8,
        }
        impl P2dir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir3R {
            bits: u8,
        }
        impl P2dir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir4R {
            bits: u8,
        }
        impl P2dir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir5R {
            bits: u8,
        }
        impl P2dir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir6R {
            bits: u8,
        }
        impl P2dir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2dir7R {
            bits: u8,
        }
        impl P2dir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2dir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2dir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2DIR0" ]
            # [ inline ( always ) ]
            pub fn p2dir0(&self) -> P2dir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir0R { bits }
            }
            # [ doc = "Bit 1 - P2DIR1" ]
            # [ inline ( always ) ]
            pub fn p2dir1(&self) -> P2dir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir1R { bits }
            }
            # [ doc = "Bit 2 - P2DIR2" ]
            # [ inline ( always ) ]
            pub fn p2dir2(&self) -> P2dir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir2R { bits }
            }
            # [ doc = "Bit 3 - P2DIR3" ]
            # [ inline ( always ) ]
            pub fn p2dir3(&self) -> P2dir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir3R { bits }
            }
            # [ doc = "Bit 4 - P2DIR4" ]
            # [ inline ( always ) ]
            pub fn p2dir4(&self) -> P2dir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir4R { bits }
            }
            # [ doc = "Bit 5 - P2DIR5" ]
            # [ inline ( always ) ]
            pub fn p2dir5(&self) -> P2dir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir5R { bits }
            }
            # [ doc = "Bit 6 - P2DIR6" ]
            # [ inline ( always ) ]
            pub fn p2dir6(&self) -> P2dir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir6R { bits }
            }
            # [ doc = "Bit 7 - P2DIR7" ]
            # [ inline ( always ) ]
            pub fn p2dir7(&self) -> P2dir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2dir7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2DIR0" ]
            # [ inline ( always ) ]
            pub fn p2dir0(&mut self) -> _P2dir0W {
                _P2dir0W { w: self }
            }
            # [ doc = "Bit 1 - P2DIR1" ]
            # [ inline ( always ) ]
            pub fn p2dir1(&mut self) -> _P2dir1W {
                _P2dir1W { w: self }
            }
            # [ doc = "Bit 2 - P2DIR2" ]
            # [ inline ( always ) ]
            pub fn p2dir2(&mut self) -> _P2dir2W {
                _P2dir2W { w: self }
            }
            # [ doc = "Bit 3 - P2DIR3" ]
            # [ inline ( always ) ]
            pub fn p2dir3(&mut self) -> _P2dir3W {
                _P2dir3W { w: self }
            }
            # [ doc = "Bit 4 - P2DIR4" ]
            # [ inline ( always ) ]
            pub fn p2dir4(&mut self) -> _P2dir4W {
                _P2dir4W { w: self }
            }
            # [ doc = "Bit 5 - P2DIR5" ]
            # [ inline ( always ) ]
            pub fn p2dir5(&mut self) -> _P2dir5W {
                _P2dir5W { w: self }
            }
            # [ doc = "Bit 6 - P2DIR6" ]
            # [ inline ( always ) ]
            pub fn p2dir6(&mut self) -> _P2dir6W {
                _P2dir6W { w: self }
            }
            # [ doc = "Bit 7 - P2DIR7" ]
            # [ inline ( always ) ]
            pub fn p2dir7(&mut self) -> _P2dir7W {
                _P2dir7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Resistor Enable" ]
    pub struct P2ren {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Resistor Enable" ]
    pub mod p2ren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2ren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren0R {
            bits: u8,
        }
        impl P2ren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren1R {
            bits: u8,
        }
        impl P2ren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren2R {
            bits: u8,
        }
        impl P2ren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren3R {
            bits: u8,
        }
        impl P2ren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren4R {
            bits: u8,
        }
        impl P2ren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren5R {
            bits: u8,
        }
        impl P2ren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren6R {
            bits: u8,
        }
        impl P2ren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ren7R {
            bits: u8,
        }
        impl P2ren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2REN0" ]
            # [ inline ( always ) ]
            pub fn p2ren0(&self) -> P2ren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren0R { bits }
            }
            # [ doc = "Bit 1 - P2REN1" ]
            # [ inline ( always ) ]
            pub fn p2ren1(&self) -> P2ren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren1R { bits }
            }
            # [ doc = "Bit 2 - P2REN2" ]
            # [ inline ( always ) ]
            pub fn p2ren2(&self) -> P2ren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren2R { bits }
            }
            # [ doc = "Bit 3 - P2REN3" ]
            # [ inline ( always ) ]
            pub fn p2ren3(&self) -> P2ren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren3R { bits }
            }
            # [ doc = "Bit 4 - P2REN4" ]
            # [ inline ( always ) ]
            pub fn p2ren4(&self) -> P2ren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren4R { bits }
            }
            # [ doc = "Bit 5 - P2REN5" ]
            # [ inline ( always ) ]
            pub fn p2ren5(&self) -> P2ren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren5R { bits }
            }
            # [ doc = "Bit 6 - P2REN6" ]
            # [ inline ( always ) ]
            pub fn p2ren6(&self) -> P2ren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren6R { bits }
            }
            # [ doc = "Bit 7 - P2REN7" ]
            # [ inline ( always ) ]
            pub fn p2ren7(&self) -> P2ren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ren7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2REN0" ]
            # [ inline ( always ) ]
            pub fn p2ren0(&mut self) -> _P2ren0W {
                _P2ren0W { w: self }
            }
            # [ doc = "Bit 1 - P2REN1" ]
            # [ inline ( always ) ]
            pub fn p2ren1(&mut self) -> _P2ren1W {
                _P2ren1W { w: self }
            }
            # [ doc = "Bit 2 - P2REN2" ]
            # [ inline ( always ) ]
            pub fn p2ren2(&mut self) -> _P2ren2W {
                _P2ren2W { w: self }
            }
            # [ doc = "Bit 3 - P2REN3" ]
            # [ inline ( always ) ]
            pub fn p2ren3(&mut self) -> _P2ren3W {
                _P2ren3W { w: self }
            }
            # [ doc = "Bit 4 - P2REN4" ]
            # [ inline ( always ) ]
            pub fn p2ren4(&mut self) -> _P2ren4W {
                _P2ren4W { w: self }
            }
            # [ doc = "Bit 5 - P2REN5" ]
            # [ inline ( always ) ]
            pub fn p2ren5(&mut self) -> _P2ren5W {
                _P2ren5W { w: self }
            }
            # [ doc = "Bit 6 - P2REN6" ]
            # [ inline ( always ) ]
            pub fn p2ren6(&mut self) -> _P2ren6W {
                _P2ren6W { w: self }
            }
            # [ doc = "Bit 7 - P2REN7" ]
            # [ inline ( always ) ]
            pub fn p2ren7(&mut self) -> _P2ren7W {
                _P2ren7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Drive Strenght" ]
    pub struct P2ds {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Drive Strenght" ]
    pub mod p2ds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2ds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds0R {
            bits: u8,
        }
        impl P2ds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds1R {
            bits: u8,
        }
        impl P2ds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds2R {
            bits: u8,
        }
        impl P2ds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds3R {
            bits: u8,
        }
        impl P2ds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds4R {
            bits: u8,
        }
        impl P2ds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds5R {
            bits: u8,
        }
        impl P2ds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds6R {
            bits: u8,
        }
        impl P2ds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ds7R {
            bits: u8,
        }
        impl P2ds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2DS0" ]
            # [ inline ( always ) ]
            pub fn p2ds0(&self) -> P2ds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds0R { bits }
            }
            # [ doc = "Bit 1 - P2DS1" ]
            # [ inline ( always ) ]
            pub fn p2ds1(&self) -> P2ds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds1R { bits }
            }
            # [ doc = "Bit 2 - P2DS2" ]
            # [ inline ( always ) ]
            pub fn p2ds2(&self) -> P2ds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds2R { bits }
            }
            # [ doc = "Bit 3 - P2DS3" ]
            # [ inline ( always ) ]
            pub fn p2ds3(&self) -> P2ds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds3R { bits }
            }
            # [ doc = "Bit 4 - P2DS4" ]
            # [ inline ( always ) ]
            pub fn p2ds4(&self) -> P2ds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds4R { bits }
            }
            # [ doc = "Bit 5 - P2DS5" ]
            # [ inline ( always ) ]
            pub fn p2ds5(&self) -> P2ds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds5R { bits }
            }
            # [ doc = "Bit 6 - P2DS6" ]
            # [ inline ( always ) ]
            pub fn p2ds6(&self) -> P2ds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds6R { bits }
            }
            # [ doc = "Bit 7 - P2DS7" ]
            # [ inline ( always ) ]
            pub fn p2ds7(&self) -> P2ds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ds7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2DS0" ]
            # [ inline ( always ) ]
            pub fn p2ds0(&mut self) -> _P2ds0W {
                _P2ds0W { w: self }
            }
            # [ doc = "Bit 1 - P2DS1" ]
            # [ inline ( always ) ]
            pub fn p2ds1(&mut self) -> _P2ds1W {
                _P2ds1W { w: self }
            }
            # [ doc = "Bit 2 - P2DS2" ]
            # [ inline ( always ) ]
            pub fn p2ds2(&mut self) -> _P2ds2W {
                _P2ds2W { w: self }
            }
            # [ doc = "Bit 3 - P2DS3" ]
            # [ inline ( always ) ]
            pub fn p2ds3(&mut self) -> _P2ds3W {
                _P2ds3W { w: self }
            }
            # [ doc = "Bit 4 - P2DS4" ]
            # [ inline ( always ) ]
            pub fn p2ds4(&mut self) -> _P2ds4W {
                _P2ds4W { w: self }
            }
            # [ doc = "Bit 5 - P2DS5" ]
            # [ inline ( always ) ]
            pub fn p2ds5(&mut self) -> _P2ds5W {
                _P2ds5W { w: self }
            }
            # [ doc = "Bit 6 - P2DS6" ]
            # [ inline ( always ) ]
            pub fn p2ds6(&mut self) -> _P2ds6W {
                _P2ds6W { w: self }
            }
            # [ doc = "Bit 7 - P2DS7" ]
            # [ inline ( always ) ]
            pub fn p2ds7(&mut self) -> _P2ds7W {
                _P2ds7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Selection" ]
    pub struct P2sel {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Selection" ]
    pub mod p2sel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2sel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel0R {
            bits: u8,
        }
        impl P2sel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel1R {
            bits: u8,
        }
        impl P2sel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel2R {
            bits: u8,
        }
        impl P2sel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel3R {
            bits: u8,
        }
        impl P2sel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel4R {
            bits: u8,
        }
        impl P2sel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel5R {
            bits: u8,
        }
        impl P2sel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel6R {
            bits: u8,
        }
        impl P2sel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2sel7R {
            bits: u8,
        }
        impl P2sel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2sel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2sel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2SEL0" ]
            # [ inline ( always ) ]
            pub fn p2sel0(&self) -> P2sel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel0R { bits }
            }
            # [ doc = "Bit 1 - P2SEL1" ]
            # [ inline ( always ) ]
            pub fn p2sel1(&self) -> P2sel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel1R { bits }
            }
            # [ doc = "Bit 2 - P2SEL2" ]
            # [ inline ( always ) ]
            pub fn p2sel2(&self) -> P2sel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel2R { bits }
            }
            # [ doc = "Bit 3 - P2SEL3" ]
            # [ inline ( always ) ]
            pub fn p2sel3(&self) -> P2sel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel3R { bits }
            }
            # [ doc = "Bit 4 - P2SEL4" ]
            # [ inline ( always ) ]
            pub fn p2sel4(&self) -> P2sel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel4R { bits }
            }
            # [ doc = "Bit 5 - P2SEL5" ]
            # [ inline ( always ) ]
            pub fn p2sel5(&self) -> P2sel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel5R { bits }
            }
            # [ doc = "Bit 6 - P2SEL6" ]
            # [ inline ( always ) ]
            pub fn p2sel6(&self) -> P2sel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel6R { bits }
            }
            # [ doc = "Bit 7 - P2SEL7" ]
            # [ inline ( always ) ]
            pub fn p2sel7(&self) -> P2sel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2sel7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2SEL0" ]
            # [ inline ( always ) ]
            pub fn p2sel0(&mut self) -> _P2sel0W {
                _P2sel0W { w: self }
            }
            # [ doc = "Bit 1 - P2SEL1" ]
            # [ inline ( always ) ]
            pub fn p2sel1(&mut self) -> _P2sel1W {
                _P2sel1W { w: self }
            }
            # [ doc = "Bit 2 - P2SEL2" ]
            # [ inline ( always ) ]
            pub fn p2sel2(&mut self) -> _P2sel2W {
                _P2sel2W { w: self }
            }
            # [ doc = "Bit 3 - P2SEL3" ]
            # [ inline ( always ) ]
            pub fn p2sel3(&mut self) -> _P2sel3W {
                _P2sel3W { w: self }
            }
            # [ doc = "Bit 4 - P2SEL4" ]
            # [ inline ( always ) ]
            pub fn p2sel4(&mut self) -> _P2sel4W {
                _P2sel4W { w: self }
            }
            # [ doc = "Bit 5 - P2SEL5" ]
            # [ inline ( always ) ]
            pub fn p2sel5(&mut self) -> _P2sel5W {
                _P2sel5W { w: self }
            }
            # [ doc = "Bit 6 - P2SEL6" ]
            # [ inline ( always ) ]
            pub fn p2sel6(&mut self) -> _P2sel6W {
                _P2sel6W { w: self }
            }
            # [ doc = "Bit 7 - P2SEL7" ]
            # [ inline ( always ) ]
            pub fn p2sel7(&mut self) -> _P2sel7W {
                _P2sel7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Interrupt Vector Word" ]
    pub struct P2iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port 2 Interrupt Vector Word" ]
    pub mod p2iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P2iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Port 2 Interrupt Edge Select" ]
    pub struct P2ies {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Interrupt Edge Select" ]
    pub mod p2ies {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2ies {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies0R {
            bits: u8,
        }
        impl P2ies0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies1R {
            bits: u8,
        }
        impl P2ies1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies2R {
            bits: u8,
        }
        impl P2ies2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies3R {
            bits: u8,
        }
        impl P2ies3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies4R {
            bits: u8,
        }
        impl P2ies4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies5R {
            bits: u8,
        }
        impl P2ies5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies6R {
            bits: u8,
        }
        impl P2ies6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ies7R {
            bits: u8,
        }
        impl P2ies7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ies7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ies7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2IES0" ]
            # [ inline ( always ) ]
            pub fn p2ies0(&self) -> P2ies0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies0R { bits }
            }
            # [ doc = "Bit 1 - P2IES1" ]
            # [ inline ( always ) ]
            pub fn p2ies1(&self) -> P2ies1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies1R { bits }
            }
            # [ doc = "Bit 2 - P2IES2" ]
            # [ inline ( always ) ]
            pub fn p2ies2(&self) -> P2ies2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies2R { bits }
            }
            # [ doc = "Bit 3 - P2IES3" ]
            # [ inline ( always ) ]
            pub fn p2ies3(&self) -> P2ies3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies3R { bits }
            }
            # [ doc = "Bit 4 - P2IES4" ]
            # [ inline ( always ) ]
            pub fn p2ies4(&self) -> P2ies4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies4R { bits }
            }
            # [ doc = "Bit 5 - P2IES5" ]
            # [ inline ( always ) ]
            pub fn p2ies5(&self) -> P2ies5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies5R { bits }
            }
            # [ doc = "Bit 6 - P2IES6" ]
            # [ inline ( always ) ]
            pub fn p2ies6(&self) -> P2ies6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies6R { bits }
            }
            # [ doc = "Bit 7 - P2IES7" ]
            # [ inline ( always ) ]
            pub fn p2ies7(&self) -> P2ies7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ies7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2IES0" ]
            # [ inline ( always ) ]
            pub fn p2ies0(&mut self) -> _P2ies0W {
                _P2ies0W { w: self }
            }
            # [ doc = "Bit 1 - P2IES1" ]
            # [ inline ( always ) ]
            pub fn p2ies1(&mut self) -> _P2ies1W {
                _P2ies1W { w: self }
            }
            # [ doc = "Bit 2 - P2IES2" ]
            # [ inline ( always ) ]
            pub fn p2ies2(&mut self) -> _P2ies2W {
                _P2ies2W { w: self }
            }
            # [ doc = "Bit 3 - P2IES3" ]
            # [ inline ( always ) ]
            pub fn p2ies3(&mut self) -> _P2ies3W {
                _P2ies3W { w: self }
            }
            # [ doc = "Bit 4 - P2IES4" ]
            # [ inline ( always ) ]
            pub fn p2ies4(&mut self) -> _P2ies4W {
                _P2ies4W { w: self }
            }
            # [ doc = "Bit 5 - P2IES5" ]
            # [ inline ( always ) ]
            pub fn p2ies5(&mut self) -> _P2ies5W {
                _P2ies5W { w: self }
            }
            # [ doc = "Bit 6 - P2IES6" ]
            # [ inline ( always ) ]
            pub fn p2ies6(&mut self) -> _P2ies6W {
                _P2ies6W { w: self }
            }
            # [ doc = "Bit 7 - P2IES7" ]
            # [ inline ( always ) ]
            pub fn p2ies7(&mut self) -> _P2ies7W {
                _P2ies7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Interrupt Enable" ]
    pub struct P2ie {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Interrupt Enable" ]
    pub mod p2ie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2ie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie0R {
            bits: u8,
        }
        impl P2ie0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie1R {
            bits: u8,
        }
        impl P2ie1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie2R {
            bits: u8,
        }
        impl P2ie2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie3R {
            bits: u8,
        }
        impl P2ie3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie4R {
            bits: u8,
        }
        impl P2ie4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie5R {
            bits: u8,
        }
        impl P2ie5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie6R {
            bits: u8,
        }
        impl P2ie6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ie7R {
            bits: u8,
        }
        impl P2ie7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ie7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ie7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2IE0" ]
            # [ inline ( always ) ]
            pub fn p2ie0(&self) -> P2ie0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie0R { bits }
            }
            # [ doc = "Bit 1 - P2IE1" ]
            # [ inline ( always ) ]
            pub fn p2ie1(&self) -> P2ie1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie1R { bits }
            }
            # [ doc = "Bit 2 - P2IE2" ]
            # [ inline ( always ) ]
            pub fn p2ie2(&self) -> P2ie2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie2R { bits }
            }
            # [ doc = "Bit 3 - P2IE3" ]
            # [ inline ( always ) ]
            pub fn p2ie3(&self) -> P2ie3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie3R { bits }
            }
            # [ doc = "Bit 4 - P2IE4" ]
            # [ inline ( always ) ]
            pub fn p2ie4(&self) -> P2ie4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie4R { bits }
            }
            # [ doc = "Bit 5 - P2IE5" ]
            # [ inline ( always ) ]
            pub fn p2ie5(&self) -> P2ie5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie5R { bits }
            }
            # [ doc = "Bit 6 - P2IE6" ]
            # [ inline ( always ) ]
            pub fn p2ie6(&self) -> P2ie6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie6R { bits }
            }
            # [ doc = "Bit 7 - P2IE7" ]
            # [ inline ( always ) ]
            pub fn p2ie7(&self) -> P2ie7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ie7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2IE0" ]
            # [ inline ( always ) ]
            pub fn p2ie0(&mut self) -> _P2ie0W {
                _P2ie0W { w: self }
            }
            # [ doc = "Bit 1 - P2IE1" ]
            # [ inline ( always ) ]
            pub fn p2ie1(&mut self) -> _P2ie1W {
                _P2ie1W { w: self }
            }
            # [ doc = "Bit 2 - P2IE2" ]
            # [ inline ( always ) ]
            pub fn p2ie2(&mut self) -> _P2ie2W {
                _P2ie2W { w: self }
            }
            # [ doc = "Bit 3 - P2IE3" ]
            # [ inline ( always ) ]
            pub fn p2ie3(&mut self) -> _P2ie3W {
                _P2ie3W { w: self }
            }
            # [ doc = "Bit 4 - P2IE4" ]
            # [ inline ( always ) ]
            pub fn p2ie4(&mut self) -> _P2ie4W {
                _P2ie4W { w: self }
            }
            # [ doc = "Bit 5 - P2IE5" ]
            # [ inline ( always ) ]
            pub fn p2ie5(&mut self) -> _P2ie5W {
                _P2ie5W { w: self }
            }
            # [ doc = "Bit 6 - P2IE6" ]
            # [ inline ( always ) ]
            pub fn p2ie6(&mut self) -> _P2ie6W {
                _P2ie6W { w: self }
            }
            # [ doc = "Bit 7 - P2IE7" ]
            # [ inline ( always ) ]
            pub fn p2ie7(&mut self) -> _P2ie7W {
                _P2ie7W { w: self }
            }
        }
    }
    # [ doc = "Port 2 Interrupt Flag" ]
    pub struct P2ifg {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 2 Interrupt Flag" ]
    pub mod p2ifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2ifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg0R {
            bits: u8,
        }
        impl P2ifg0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg1R {
            bits: u8,
        }
        impl P2ifg1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg2R {
            bits: u8,
        }
        impl P2ifg2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg3R {
            bits: u8,
        }
        impl P2ifg3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg4R {
            bits: u8,
        }
        impl P2ifg4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg5R {
            bits: u8,
        }
        impl P2ifg5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg6R {
            bits: u8,
        }
        impl P2ifg6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P2ifg7R {
            bits: u8,
        }
        impl P2ifg7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P2ifg7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P2ifg7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P2IFG0" ]
            # [ inline ( always ) ]
            pub fn p2ifg0(&self) -> P2ifg0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg0R { bits }
            }
            # [ doc = "Bit 1 - P2IFG1" ]
            # [ inline ( always ) ]
            pub fn p2ifg1(&self) -> P2ifg1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg1R { bits }
            }
            # [ doc = "Bit 2 - P2IFG2" ]
            # [ inline ( always ) ]
            pub fn p2ifg2(&self) -> P2ifg2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg2R { bits }
            }
            # [ doc = "Bit 3 - P2IFG3" ]
            # [ inline ( always ) ]
            pub fn p2ifg3(&self) -> P2ifg3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg3R { bits }
            }
            # [ doc = "Bit 4 - P2IFG4" ]
            # [ inline ( always ) ]
            pub fn p2ifg4(&self) -> P2ifg4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg4R { bits }
            }
            # [ doc = "Bit 5 - P2IFG5" ]
            # [ inline ( always ) ]
            pub fn p2ifg5(&self) -> P2ifg5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg5R { bits }
            }
            # [ doc = "Bit 6 - P2IFG6" ]
            # [ inline ( always ) ]
            pub fn p2ifg6(&self) -> P2ifg6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg6R { bits }
            }
            # [ doc = "Bit 7 - P2IFG7" ]
            # [ inline ( always ) ]
            pub fn p2ifg7(&self) -> P2ifg7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P2ifg7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P2IFG0" ]
            # [ inline ( always ) ]
            pub fn p2ifg0(&mut self) -> _P2ifg0W {
                _P2ifg0W { w: self }
            }
            # [ doc = "Bit 1 - P2IFG1" ]
            # [ inline ( always ) ]
            pub fn p2ifg1(&mut self) -> _P2ifg1W {
                _P2ifg1W { w: self }
            }
            # [ doc = "Bit 2 - P2IFG2" ]
            # [ inline ( always ) ]
            pub fn p2ifg2(&mut self) -> _P2ifg2W {
                _P2ifg2W { w: self }
            }
            # [ doc = "Bit 3 - P2IFG3" ]
            # [ inline ( always ) ]
            pub fn p2ifg3(&mut self) -> _P2ifg3W {
                _P2ifg3W { w: self }
            }
            # [ doc = "Bit 4 - P2IFG4" ]
            # [ inline ( always ) ]
            pub fn p2ifg4(&mut self) -> _P2ifg4W {
                _P2ifg4W { w: self }
            }
            # [ doc = "Bit 5 - P2IFG5" ]
            # [ inline ( always ) ]
            pub fn p2ifg5(&mut self) -> _P2ifg5W {
                _P2ifg5W { w: self }
            }
            # [ doc = "Bit 6 - P2IFG6" ]
            # [ inline ( always ) ]
            pub fn p2ifg6(&mut self) -> _P2ifg6W {
                _P2ifg6W { w: self }
            }
            # [ doc = "Bit 7 - P2IFG7" ]
            # [ inline ( always ) ]
            pub fn p2ifg7(&mut self) -> _P2ifg7W {
                _P2ifg7W { w: self }
            }
        }
    }
}
# [ doc = "Port 1/2" ]
pub struct Port12 {
    register_block: port_1_2::RegisterBlock,
}
impl Deref for Port12 {
    type Target = port_1_2::RegisterBlock;
    fn deref(&self) -> &port_1_2::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port B" ]
pub const PORT_B: Peripheral<PortB> = unsafe { Peripheral::new(0) };
# [ doc = "Port B" ]
pub mod port_b {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 544usize],
        # [ doc = "0x220 - Port B Input" ]
        pub pbin: Pbin,
        # [ doc = "0x222 - Port B Output" ]
        pub pbout: Pbout,
        # [ doc = "0x224 - Port B Direction" ]
        pub pbdir: Pbdir,
        # [ doc = "0x226 - Port B Resistor Enable" ]
        pub pbren: Pbren,
        # [ doc = "0x228 - Port B Drive Strenght" ]
        pub pbds: Pbds,
        # [ doc = "0x22a - Port B Selection" ]
        pub pbsel: Pbsel,
    }
    # [ doc = "Port B Input" ]
    pub struct Pbin {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port B Input" ]
    pub mod pbin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pbin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin0R {
            bits: u8,
        }
        impl Pbin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin1R {
            bits: u8,
        }
        impl Pbin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin2R {
            bits: u8,
        }
        impl Pbin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin3R {
            bits: u8,
        }
        impl Pbin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin4R {
            bits: u8,
        }
        impl Pbin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin5R {
            bits: u8,
        }
        impl Pbin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin6R {
            bits: u8,
        }
        impl Pbin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin7R {
            bits: u8,
        }
        impl Pbin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin8R {
            bits: u8,
        }
        impl Pbin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin9R {
            bits: u8,
        }
        impl Pbin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin10R {
            bits: u8,
        }
        impl Pbin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin11R {
            bits: u8,
        }
        impl Pbin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin12R {
            bits: u8,
        }
        impl Pbin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin13R {
            bits: u8,
        }
        impl Pbin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin14R {
            bits: u8,
        }
        impl Pbin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbin15R {
            bits: u8,
        }
        impl Pbin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbin15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PBIN0" ]
            # [ inline ( always ) ]
            pub fn pbin0(&self) -> Pbin0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin0R { bits }
            }
            # [ doc = "Bit 1 - PBIN1" ]
            # [ inline ( always ) ]
            pub fn pbin1(&self) -> Pbin1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin1R { bits }
            }
            # [ doc = "Bit 2 - PBIN2" ]
            # [ inline ( always ) ]
            pub fn pbin2(&self) -> Pbin2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin2R { bits }
            }
            # [ doc = "Bit 3 - PBIN3" ]
            # [ inline ( always ) ]
            pub fn pbin3(&self) -> Pbin3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin3R { bits }
            }
            # [ doc = "Bit 4 - PBIN4" ]
            # [ inline ( always ) ]
            pub fn pbin4(&self) -> Pbin4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin4R { bits }
            }
            # [ doc = "Bit 5 - PBIN5" ]
            # [ inline ( always ) ]
            pub fn pbin5(&self) -> Pbin5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin5R { bits }
            }
            # [ doc = "Bit 6 - PBIN6" ]
            # [ inline ( always ) ]
            pub fn pbin6(&self) -> Pbin6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin6R { bits }
            }
            # [ doc = "Bit 7 - PBIN7" ]
            # [ inline ( always ) ]
            pub fn pbin7(&self) -> Pbin7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin7R { bits }
            }
            # [ doc = "Bit 8 - PBIN8" ]
            # [ inline ( always ) ]
            pub fn pbin8(&self) -> Pbin8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin8R { bits }
            }
            # [ doc = "Bit 9 - PBIN9" ]
            # [ inline ( always ) ]
            pub fn pbin9(&self) -> Pbin9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin9R { bits }
            }
            # [ doc = "Bit 10 - PBIN10" ]
            # [ inline ( always ) ]
            pub fn pbin10(&self) -> Pbin10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin10R { bits }
            }
            # [ doc = "Bit 11 - PBIN11" ]
            # [ inline ( always ) ]
            pub fn pbin11(&self) -> Pbin11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin11R { bits }
            }
            # [ doc = "Bit 12 - PBIN12" ]
            # [ inline ( always ) ]
            pub fn pbin12(&self) -> Pbin12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin12R { bits }
            }
            # [ doc = "Bit 13 - PBIN13" ]
            # [ inline ( always ) ]
            pub fn pbin13(&self) -> Pbin13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin13R { bits }
            }
            # [ doc = "Bit 14 - PBIN14" ]
            # [ inline ( always ) ]
            pub fn pbin14(&self) -> Pbin14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin14R { bits }
            }
            # [ doc = "Bit 15 - PBIN15" ]
            # [ inline ( always ) ]
            pub fn pbin15(&self) -> Pbin15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbin15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PBIN0" ]
            # [ inline ( always ) ]
            pub fn pbin0(&mut self) -> _Pbin0W {
                _Pbin0W { w: self }
            }
            # [ doc = "Bit 1 - PBIN1" ]
            # [ inline ( always ) ]
            pub fn pbin1(&mut self) -> _Pbin1W {
                _Pbin1W { w: self }
            }
            # [ doc = "Bit 2 - PBIN2" ]
            # [ inline ( always ) ]
            pub fn pbin2(&mut self) -> _Pbin2W {
                _Pbin2W { w: self }
            }
            # [ doc = "Bit 3 - PBIN3" ]
            # [ inline ( always ) ]
            pub fn pbin3(&mut self) -> _Pbin3W {
                _Pbin3W { w: self }
            }
            # [ doc = "Bit 4 - PBIN4" ]
            # [ inline ( always ) ]
            pub fn pbin4(&mut self) -> _Pbin4W {
                _Pbin4W { w: self }
            }
            # [ doc = "Bit 5 - PBIN5" ]
            # [ inline ( always ) ]
            pub fn pbin5(&mut self) -> _Pbin5W {
                _Pbin5W { w: self }
            }
            # [ doc = "Bit 6 - PBIN6" ]
            # [ inline ( always ) ]
            pub fn pbin6(&mut self) -> _Pbin6W {
                _Pbin6W { w: self }
            }
            # [ doc = "Bit 7 - PBIN7" ]
            # [ inline ( always ) ]
            pub fn pbin7(&mut self) -> _Pbin7W {
                _Pbin7W { w: self }
            }
            # [ doc = "Bit 8 - PBIN8" ]
            # [ inline ( always ) ]
            pub fn pbin8(&mut self) -> _Pbin8W {
                _Pbin8W { w: self }
            }
            # [ doc = "Bit 9 - PBIN9" ]
            # [ inline ( always ) ]
            pub fn pbin9(&mut self) -> _Pbin9W {
                _Pbin9W { w: self }
            }
            # [ doc = "Bit 10 - PBIN10" ]
            # [ inline ( always ) ]
            pub fn pbin10(&mut self) -> _Pbin10W {
                _Pbin10W { w: self }
            }
            # [ doc = "Bit 11 - PBIN11" ]
            # [ inline ( always ) ]
            pub fn pbin11(&mut self) -> _Pbin11W {
                _Pbin11W { w: self }
            }
            # [ doc = "Bit 12 - PBIN12" ]
            # [ inline ( always ) ]
            pub fn pbin12(&mut self) -> _Pbin12W {
                _Pbin12W { w: self }
            }
            # [ doc = "Bit 13 - PBIN13" ]
            # [ inline ( always ) ]
            pub fn pbin13(&mut self) -> _Pbin13W {
                _Pbin13W { w: self }
            }
            # [ doc = "Bit 14 - PBIN14" ]
            # [ inline ( always ) ]
            pub fn pbin14(&mut self) -> _Pbin14W {
                _Pbin14W { w: self }
            }
            # [ doc = "Bit 15 - PBIN15" ]
            # [ inline ( always ) ]
            pub fn pbin15(&mut self) -> _Pbin15W {
                _Pbin15W { w: self }
            }
        }
    }
    # [ doc = "Port B Output" ]
    pub struct Pbout {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port B Output" ]
    pub mod pbout {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pbout {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout0R {
            bits: u8,
        }
        impl Pbout0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout1R {
            bits: u8,
        }
        impl Pbout1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout2R {
            bits: u8,
        }
        impl Pbout2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout3R {
            bits: u8,
        }
        impl Pbout3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout4R {
            bits: u8,
        }
        impl Pbout4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout5R {
            bits: u8,
        }
        impl Pbout5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout6R {
            bits: u8,
        }
        impl Pbout6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout7R {
            bits: u8,
        }
        impl Pbout7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout8R {
            bits: u8,
        }
        impl Pbout8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout9R {
            bits: u8,
        }
        impl Pbout9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout10R {
            bits: u8,
        }
        impl Pbout10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout11R {
            bits: u8,
        }
        impl Pbout11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout12R {
            bits: u8,
        }
        impl Pbout12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout13R {
            bits: u8,
        }
        impl Pbout13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout14R {
            bits: u8,
        }
        impl Pbout14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbout15R {
            bits: u8,
        }
        impl Pbout15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbout15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbout15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PBOUT0" ]
            # [ inline ( always ) ]
            pub fn pbout0(&self) -> Pbout0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout0R { bits }
            }
            # [ doc = "Bit 1 - PBOUT1" ]
            # [ inline ( always ) ]
            pub fn pbout1(&self) -> Pbout1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout1R { bits }
            }
            # [ doc = "Bit 2 - PBOUT2" ]
            # [ inline ( always ) ]
            pub fn pbout2(&self) -> Pbout2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout2R { bits }
            }
            # [ doc = "Bit 3 - PBOUT3" ]
            # [ inline ( always ) ]
            pub fn pbout3(&self) -> Pbout3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout3R { bits }
            }
            # [ doc = "Bit 4 - PBOUT4" ]
            # [ inline ( always ) ]
            pub fn pbout4(&self) -> Pbout4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout4R { bits }
            }
            # [ doc = "Bit 5 - PBOUT5" ]
            # [ inline ( always ) ]
            pub fn pbout5(&self) -> Pbout5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout5R { bits }
            }
            # [ doc = "Bit 6 - PBOUT6" ]
            # [ inline ( always ) ]
            pub fn pbout6(&self) -> Pbout6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout6R { bits }
            }
            # [ doc = "Bit 7 - PBOUT7" ]
            # [ inline ( always ) ]
            pub fn pbout7(&self) -> Pbout7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout7R { bits }
            }
            # [ doc = "Bit 8 - PBOUT8" ]
            # [ inline ( always ) ]
            pub fn pbout8(&self) -> Pbout8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout8R { bits }
            }
            # [ doc = "Bit 9 - PBOUT9" ]
            # [ inline ( always ) ]
            pub fn pbout9(&self) -> Pbout9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout9R { bits }
            }
            # [ doc = "Bit 10 - PBOUT10" ]
            # [ inline ( always ) ]
            pub fn pbout10(&self) -> Pbout10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout10R { bits }
            }
            # [ doc = "Bit 11 - PBOUT11" ]
            # [ inline ( always ) ]
            pub fn pbout11(&self) -> Pbout11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout11R { bits }
            }
            # [ doc = "Bit 12 - PBOUT12" ]
            # [ inline ( always ) ]
            pub fn pbout12(&self) -> Pbout12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout12R { bits }
            }
            # [ doc = "Bit 13 - PBOUT13" ]
            # [ inline ( always ) ]
            pub fn pbout13(&self) -> Pbout13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout13R { bits }
            }
            # [ doc = "Bit 14 - PBOUT14" ]
            # [ inline ( always ) ]
            pub fn pbout14(&self) -> Pbout14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout14R { bits }
            }
            # [ doc = "Bit 15 - PBOUT15" ]
            # [ inline ( always ) ]
            pub fn pbout15(&self) -> Pbout15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbout15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PBOUT0" ]
            # [ inline ( always ) ]
            pub fn pbout0(&mut self) -> _Pbout0W {
                _Pbout0W { w: self }
            }
            # [ doc = "Bit 1 - PBOUT1" ]
            # [ inline ( always ) ]
            pub fn pbout1(&mut self) -> _Pbout1W {
                _Pbout1W { w: self }
            }
            # [ doc = "Bit 2 - PBOUT2" ]
            # [ inline ( always ) ]
            pub fn pbout2(&mut self) -> _Pbout2W {
                _Pbout2W { w: self }
            }
            # [ doc = "Bit 3 - PBOUT3" ]
            # [ inline ( always ) ]
            pub fn pbout3(&mut self) -> _Pbout3W {
                _Pbout3W { w: self }
            }
            # [ doc = "Bit 4 - PBOUT4" ]
            # [ inline ( always ) ]
            pub fn pbout4(&mut self) -> _Pbout4W {
                _Pbout4W { w: self }
            }
            # [ doc = "Bit 5 - PBOUT5" ]
            # [ inline ( always ) ]
            pub fn pbout5(&mut self) -> _Pbout5W {
                _Pbout5W { w: self }
            }
            # [ doc = "Bit 6 - PBOUT6" ]
            # [ inline ( always ) ]
            pub fn pbout6(&mut self) -> _Pbout6W {
                _Pbout6W { w: self }
            }
            # [ doc = "Bit 7 - PBOUT7" ]
            # [ inline ( always ) ]
            pub fn pbout7(&mut self) -> _Pbout7W {
                _Pbout7W { w: self }
            }
            # [ doc = "Bit 8 - PBOUT8" ]
            # [ inline ( always ) ]
            pub fn pbout8(&mut self) -> _Pbout8W {
                _Pbout8W { w: self }
            }
            # [ doc = "Bit 9 - PBOUT9" ]
            # [ inline ( always ) ]
            pub fn pbout9(&mut self) -> _Pbout9W {
                _Pbout9W { w: self }
            }
            # [ doc = "Bit 10 - PBOUT10" ]
            # [ inline ( always ) ]
            pub fn pbout10(&mut self) -> _Pbout10W {
                _Pbout10W { w: self }
            }
            # [ doc = "Bit 11 - PBOUT11" ]
            # [ inline ( always ) ]
            pub fn pbout11(&mut self) -> _Pbout11W {
                _Pbout11W { w: self }
            }
            # [ doc = "Bit 12 - PBOUT12" ]
            # [ inline ( always ) ]
            pub fn pbout12(&mut self) -> _Pbout12W {
                _Pbout12W { w: self }
            }
            # [ doc = "Bit 13 - PBOUT13" ]
            # [ inline ( always ) ]
            pub fn pbout13(&mut self) -> _Pbout13W {
                _Pbout13W { w: self }
            }
            # [ doc = "Bit 14 - PBOUT14" ]
            # [ inline ( always ) ]
            pub fn pbout14(&mut self) -> _Pbout14W {
                _Pbout14W { w: self }
            }
            # [ doc = "Bit 15 - PBOUT15" ]
            # [ inline ( always ) ]
            pub fn pbout15(&mut self) -> _Pbout15W {
                _Pbout15W { w: self }
            }
        }
    }
    # [ doc = "Port B Direction" ]
    pub struct Pbdir {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port B Direction" ]
    pub mod pbdir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pbdir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir0R {
            bits: u8,
        }
        impl Pbdir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir1R {
            bits: u8,
        }
        impl Pbdir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir2R {
            bits: u8,
        }
        impl Pbdir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir3R {
            bits: u8,
        }
        impl Pbdir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir4R {
            bits: u8,
        }
        impl Pbdir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir5R {
            bits: u8,
        }
        impl Pbdir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir6R {
            bits: u8,
        }
        impl Pbdir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir7R {
            bits: u8,
        }
        impl Pbdir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir8R {
            bits: u8,
        }
        impl Pbdir8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir9R {
            bits: u8,
        }
        impl Pbdir9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir10R {
            bits: u8,
        }
        impl Pbdir10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir11R {
            bits: u8,
        }
        impl Pbdir11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir12R {
            bits: u8,
        }
        impl Pbdir12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir13R {
            bits: u8,
        }
        impl Pbdir13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir14R {
            bits: u8,
        }
        impl Pbdir14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbdir15R {
            bits: u8,
        }
        impl Pbdir15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbdir15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbdir15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PBDIR0" ]
            # [ inline ( always ) ]
            pub fn pbdir0(&self) -> Pbdir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir0R { bits }
            }
            # [ doc = "Bit 1 - PBDIR1" ]
            # [ inline ( always ) ]
            pub fn pbdir1(&self) -> Pbdir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir1R { bits }
            }
            # [ doc = "Bit 2 - PBDIR2" ]
            # [ inline ( always ) ]
            pub fn pbdir2(&self) -> Pbdir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir2R { bits }
            }
            # [ doc = "Bit 3 - PBDIR3" ]
            # [ inline ( always ) ]
            pub fn pbdir3(&self) -> Pbdir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir3R { bits }
            }
            # [ doc = "Bit 4 - PBDIR4" ]
            # [ inline ( always ) ]
            pub fn pbdir4(&self) -> Pbdir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir4R { bits }
            }
            # [ doc = "Bit 5 - PBDIR5" ]
            # [ inline ( always ) ]
            pub fn pbdir5(&self) -> Pbdir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir5R { bits }
            }
            # [ doc = "Bit 6 - PBDIR6" ]
            # [ inline ( always ) ]
            pub fn pbdir6(&self) -> Pbdir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir6R { bits }
            }
            # [ doc = "Bit 7 - PBDIR7" ]
            # [ inline ( always ) ]
            pub fn pbdir7(&self) -> Pbdir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir7R { bits }
            }
            # [ doc = "Bit 8 - PBDIR8" ]
            # [ inline ( always ) ]
            pub fn pbdir8(&self) -> Pbdir8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir8R { bits }
            }
            # [ doc = "Bit 9 - PBDIR9" ]
            # [ inline ( always ) ]
            pub fn pbdir9(&self) -> Pbdir9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir9R { bits }
            }
            # [ doc = "Bit 10 - PBDIR10" ]
            # [ inline ( always ) ]
            pub fn pbdir10(&self) -> Pbdir10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir10R { bits }
            }
            # [ doc = "Bit 11 - PBDIR11" ]
            # [ inline ( always ) ]
            pub fn pbdir11(&self) -> Pbdir11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir11R { bits }
            }
            # [ doc = "Bit 12 - PBDIR12" ]
            # [ inline ( always ) ]
            pub fn pbdir12(&self) -> Pbdir12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir12R { bits }
            }
            # [ doc = "Bit 13 - PBDIR13" ]
            # [ inline ( always ) ]
            pub fn pbdir13(&self) -> Pbdir13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir13R { bits }
            }
            # [ doc = "Bit 14 - PBDIR14" ]
            # [ inline ( always ) ]
            pub fn pbdir14(&self) -> Pbdir14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir14R { bits }
            }
            # [ doc = "Bit 15 - PBDIR15" ]
            # [ inline ( always ) ]
            pub fn pbdir15(&self) -> Pbdir15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbdir15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PBDIR0" ]
            # [ inline ( always ) ]
            pub fn pbdir0(&mut self) -> _Pbdir0W {
                _Pbdir0W { w: self }
            }
            # [ doc = "Bit 1 - PBDIR1" ]
            # [ inline ( always ) ]
            pub fn pbdir1(&mut self) -> _Pbdir1W {
                _Pbdir1W { w: self }
            }
            # [ doc = "Bit 2 - PBDIR2" ]
            # [ inline ( always ) ]
            pub fn pbdir2(&mut self) -> _Pbdir2W {
                _Pbdir2W { w: self }
            }
            # [ doc = "Bit 3 - PBDIR3" ]
            # [ inline ( always ) ]
            pub fn pbdir3(&mut self) -> _Pbdir3W {
                _Pbdir3W { w: self }
            }
            # [ doc = "Bit 4 - PBDIR4" ]
            # [ inline ( always ) ]
            pub fn pbdir4(&mut self) -> _Pbdir4W {
                _Pbdir4W { w: self }
            }
            # [ doc = "Bit 5 - PBDIR5" ]
            # [ inline ( always ) ]
            pub fn pbdir5(&mut self) -> _Pbdir5W {
                _Pbdir5W { w: self }
            }
            # [ doc = "Bit 6 - PBDIR6" ]
            # [ inline ( always ) ]
            pub fn pbdir6(&mut self) -> _Pbdir6W {
                _Pbdir6W { w: self }
            }
            # [ doc = "Bit 7 - PBDIR7" ]
            # [ inline ( always ) ]
            pub fn pbdir7(&mut self) -> _Pbdir7W {
                _Pbdir7W { w: self }
            }
            # [ doc = "Bit 8 - PBDIR8" ]
            # [ inline ( always ) ]
            pub fn pbdir8(&mut self) -> _Pbdir8W {
                _Pbdir8W { w: self }
            }
            # [ doc = "Bit 9 - PBDIR9" ]
            # [ inline ( always ) ]
            pub fn pbdir9(&mut self) -> _Pbdir9W {
                _Pbdir9W { w: self }
            }
            # [ doc = "Bit 10 - PBDIR10" ]
            # [ inline ( always ) ]
            pub fn pbdir10(&mut self) -> _Pbdir10W {
                _Pbdir10W { w: self }
            }
            # [ doc = "Bit 11 - PBDIR11" ]
            # [ inline ( always ) ]
            pub fn pbdir11(&mut self) -> _Pbdir11W {
                _Pbdir11W { w: self }
            }
            # [ doc = "Bit 12 - PBDIR12" ]
            # [ inline ( always ) ]
            pub fn pbdir12(&mut self) -> _Pbdir12W {
                _Pbdir12W { w: self }
            }
            # [ doc = "Bit 13 - PBDIR13" ]
            # [ inline ( always ) ]
            pub fn pbdir13(&mut self) -> _Pbdir13W {
                _Pbdir13W { w: self }
            }
            # [ doc = "Bit 14 - PBDIR14" ]
            # [ inline ( always ) ]
            pub fn pbdir14(&mut self) -> _Pbdir14W {
                _Pbdir14W { w: self }
            }
            # [ doc = "Bit 15 - PBDIR15" ]
            # [ inline ( always ) ]
            pub fn pbdir15(&mut self) -> _Pbdir15W {
                _Pbdir15W { w: self }
            }
        }
    }
    # [ doc = "Port B Resistor Enable" ]
    pub struct Pbren {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port B Resistor Enable" ]
    pub mod pbren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pbren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren0R {
            bits: u8,
        }
        impl Pbren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren1R {
            bits: u8,
        }
        impl Pbren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren2R {
            bits: u8,
        }
        impl Pbren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren3R {
            bits: u8,
        }
        impl Pbren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren4R {
            bits: u8,
        }
        impl Pbren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren5R {
            bits: u8,
        }
        impl Pbren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren6R {
            bits: u8,
        }
        impl Pbren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren7R {
            bits: u8,
        }
        impl Pbren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren8R {
            bits: u8,
        }
        impl Pbren8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren9R {
            bits: u8,
        }
        impl Pbren9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren10R {
            bits: u8,
        }
        impl Pbren10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren11R {
            bits: u8,
        }
        impl Pbren11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren12R {
            bits: u8,
        }
        impl Pbren12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren13R {
            bits: u8,
        }
        impl Pbren13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren14R {
            bits: u8,
        }
        impl Pbren14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbren15R {
            bits: u8,
        }
        impl Pbren15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbren15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbren15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PBREN0" ]
            # [ inline ( always ) ]
            pub fn pbren0(&self) -> Pbren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren0R { bits }
            }
            # [ doc = "Bit 1 - PBREN1" ]
            # [ inline ( always ) ]
            pub fn pbren1(&self) -> Pbren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren1R { bits }
            }
            # [ doc = "Bit 2 - PBREN2" ]
            # [ inline ( always ) ]
            pub fn pbren2(&self) -> Pbren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren2R { bits }
            }
            # [ doc = "Bit 3 - PBREN3" ]
            # [ inline ( always ) ]
            pub fn pbren3(&self) -> Pbren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren3R { bits }
            }
            # [ doc = "Bit 4 - PBREN4" ]
            # [ inline ( always ) ]
            pub fn pbren4(&self) -> Pbren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren4R { bits }
            }
            # [ doc = "Bit 5 - PBREN5" ]
            # [ inline ( always ) ]
            pub fn pbren5(&self) -> Pbren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren5R { bits }
            }
            # [ doc = "Bit 6 - PBREN6" ]
            # [ inline ( always ) ]
            pub fn pbren6(&self) -> Pbren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren6R { bits }
            }
            # [ doc = "Bit 7 - PBREN7" ]
            # [ inline ( always ) ]
            pub fn pbren7(&self) -> Pbren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren7R { bits }
            }
            # [ doc = "Bit 8 - PBREN8" ]
            # [ inline ( always ) ]
            pub fn pbren8(&self) -> Pbren8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren8R { bits }
            }
            # [ doc = "Bit 9 - PBREN9" ]
            # [ inline ( always ) ]
            pub fn pbren9(&self) -> Pbren9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren9R { bits }
            }
            # [ doc = "Bit 10 - PBREN10" ]
            # [ inline ( always ) ]
            pub fn pbren10(&self) -> Pbren10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren10R { bits }
            }
            # [ doc = "Bit 11 - PBREN11" ]
            # [ inline ( always ) ]
            pub fn pbren11(&self) -> Pbren11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren11R { bits }
            }
            # [ doc = "Bit 12 - PBREN12" ]
            # [ inline ( always ) ]
            pub fn pbren12(&self) -> Pbren12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren12R { bits }
            }
            # [ doc = "Bit 13 - PBREN13" ]
            # [ inline ( always ) ]
            pub fn pbren13(&self) -> Pbren13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren13R { bits }
            }
            # [ doc = "Bit 14 - PBREN14" ]
            # [ inline ( always ) ]
            pub fn pbren14(&self) -> Pbren14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren14R { bits }
            }
            # [ doc = "Bit 15 - PBREN15" ]
            # [ inline ( always ) ]
            pub fn pbren15(&self) -> Pbren15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbren15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PBREN0" ]
            # [ inline ( always ) ]
            pub fn pbren0(&mut self) -> _Pbren0W {
                _Pbren0W { w: self }
            }
            # [ doc = "Bit 1 - PBREN1" ]
            # [ inline ( always ) ]
            pub fn pbren1(&mut self) -> _Pbren1W {
                _Pbren1W { w: self }
            }
            # [ doc = "Bit 2 - PBREN2" ]
            # [ inline ( always ) ]
            pub fn pbren2(&mut self) -> _Pbren2W {
                _Pbren2W { w: self }
            }
            # [ doc = "Bit 3 - PBREN3" ]
            # [ inline ( always ) ]
            pub fn pbren3(&mut self) -> _Pbren3W {
                _Pbren3W { w: self }
            }
            # [ doc = "Bit 4 - PBREN4" ]
            # [ inline ( always ) ]
            pub fn pbren4(&mut self) -> _Pbren4W {
                _Pbren4W { w: self }
            }
            # [ doc = "Bit 5 - PBREN5" ]
            # [ inline ( always ) ]
            pub fn pbren5(&mut self) -> _Pbren5W {
                _Pbren5W { w: self }
            }
            # [ doc = "Bit 6 - PBREN6" ]
            # [ inline ( always ) ]
            pub fn pbren6(&mut self) -> _Pbren6W {
                _Pbren6W { w: self }
            }
            # [ doc = "Bit 7 - PBREN7" ]
            # [ inline ( always ) ]
            pub fn pbren7(&mut self) -> _Pbren7W {
                _Pbren7W { w: self }
            }
            # [ doc = "Bit 8 - PBREN8" ]
            # [ inline ( always ) ]
            pub fn pbren8(&mut self) -> _Pbren8W {
                _Pbren8W { w: self }
            }
            # [ doc = "Bit 9 - PBREN9" ]
            # [ inline ( always ) ]
            pub fn pbren9(&mut self) -> _Pbren9W {
                _Pbren9W { w: self }
            }
            # [ doc = "Bit 10 - PBREN10" ]
            # [ inline ( always ) ]
            pub fn pbren10(&mut self) -> _Pbren10W {
                _Pbren10W { w: self }
            }
            # [ doc = "Bit 11 - PBREN11" ]
            # [ inline ( always ) ]
            pub fn pbren11(&mut self) -> _Pbren11W {
                _Pbren11W { w: self }
            }
            # [ doc = "Bit 12 - PBREN12" ]
            # [ inline ( always ) ]
            pub fn pbren12(&mut self) -> _Pbren12W {
                _Pbren12W { w: self }
            }
            # [ doc = "Bit 13 - PBREN13" ]
            # [ inline ( always ) ]
            pub fn pbren13(&mut self) -> _Pbren13W {
                _Pbren13W { w: self }
            }
            # [ doc = "Bit 14 - PBREN14" ]
            # [ inline ( always ) ]
            pub fn pbren14(&mut self) -> _Pbren14W {
                _Pbren14W { w: self }
            }
            # [ doc = "Bit 15 - PBREN15" ]
            # [ inline ( always ) ]
            pub fn pbren15(&mut self) -> _Pbren15W {
                _Pbren15W { w: self }
            }
        }
    }
    # [ doc = "Port B Drive Strenght" ]
    pub struct Pbds {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port B Drive Strenght" ]
    pub mod pbds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pbds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds0R {
            bits: u8,
        }
        impl Pbds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds1R {
            bits: u8,
        }
        impl Pbds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds2R {
            bits: u8,
        }
        impl Pbds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds3R {
            bits: u8,
        }
        impl Pbds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds4R {
            bits: u8,
        }
        impl Pbds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds5R {
            bits: u8,
        }
        impl Pbds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds6R {
            bits: u8,
        }
        impl Pbds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds7R {
            bits: u8,
        }
        impl Pbds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds8R {
            bits: u8,
        }
        impl Pbds8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds9R {
            bits: u8,
        }
        impl Pbds9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds10R {
            bits: u8,
        }
        impl Pbds10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds11R {
            bits: u8,
        }
        impl Pbds11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds12R {
            bits: u8,
        }
        impl Pbds12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds13R {
            bits: u8,
        }
        impl Pbds13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds14R {
            bits: u8,
        }
        impl Pbds14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbds15R {
            bits: u8,
        }
        impl Pbds15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbds15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbds15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PBDS0" ]
            # [ inline ( always ) ]
            pub fn pbds0(&self) -> Pbds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds0R { bits }
            }
            # [ doc = "Bit 1 - PBDS1" ]
            # [ inline ( always ) ]
            pub fn pbds1(&self) -> Pbds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds1R { bits }
            }
            # [ doc = "Bit 2 - PBDS2" ]
            # [ inline ( always ) ]
            pub fn pbds2(&self) -> Pbds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds2R { bits }
            }
            # [ doc = "Bit 3 - PBDS3" ]
            # [ inline ( always ) ]
            pub fn pbds3(&self) -> Pbds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds3R { bits }
            }
            # [ doc = "Bit 4 - PBDS4" ]
            # [ inline ( always ) ]
            pub fn pbds4(&self) -> Pbds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds4R { bits }
            }
            # [ doc = "Bit 5 - PBDS5" ]
            # [ inline ( always ) ]
            pub fn pbds5(&self) -> Pbds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds5R { bits }
            }
            # [ doc = "Bit 6 - PBDS6" ]
            # [ inline ( always ) ]
            pub fn pbds6(&self) -> Pbds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds6R { bits }
            }
            # [ doc = "Bit 7 - PBDS7" ]
            # [ inline ( always ) ]
            pub fn pbds7(&self) -> Pbds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds7R { bits }
            }
            # [ doc = "Bit 8 - PBDS8" ]
            # [ inline ( always ) ]
            pub fn pbds8(&self) -> Pbds8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds8R { bits }
            }
            # [ doc = "Bit 9 - PBDS9" ]
            # [ inline ( always ) ]
            pub fn pbds9(&self) -> Pbds9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds9R { bits }
            }
            # [ doc = "Bit 10 - PBDS10" ]
            # [ inline ( always ) ]
            pub fn pbds10(&self) -> Pbds10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds10R { bits }
            }
            # [ doc = "Bit 11 - PBDS11" ]
            # [ inline ( always ) ]
            pub fn pbds11(&self) -> Pbds11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds11R { bits }
            }
            # [ doc = "Bit 12 - PBDS12" ]
            # [ inline ( always ) ]
            pub fn pbds12(&self) -> Pbds12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds12R { bits }
            }
            # [ doc = "Bit 13 - PBDS13" ]
            # [ inline ( always ) ]
            pub fn pbds13(&self) -> Pbds13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds13R { bits }
            }
            # [ doc = "Bit 14 - PBDS14" ]
            # [ inline ( always ) ]
            pub fn pbds14(&self) -> Pbds14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds14R { bits }
            }
            # [ doc = "Bit 15 - PBDS15" ]
            # [ inline ( always ) ]
            pub fn pbds15(&self) -> Pbds15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbds15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PBDS0" ]
            # [ inline ( always ) ]
            pub fn pbds0(&mut self) -> _Pbds0W {
                _Pbds0W { w: self }
            }
            # [ doc = "Bit 1 - PBDS1" ]
            # [ inline ( always ) ]
            pub fn pbds1(&mut self) -> _Pbds1W {
                _Pbds1W { w: self }
            }
            # [ doc = "Bit 2 - PBDS2" ]
            # [ inline ( always ) ]
            pub fn pbds2(&mut self) -> _Pbds2W {
                _Pbds2W { w: self }
            }
            # [ doc = "Bit 3 - PBDS3" ]
            # [ inline ( always ) ]
            pub fn pbds3(&mut self) -> _Pbds3W {
                _Pbds3W { w: self }
            }
            # [ doc = "Bit 4 - PBDS4" ]
            # [ inline ( always ) ]
            pub fn pbds4(&mut self) -> _Pbds4W {
                _Pbds4W { w: self }
            }
            # [ doc = "Bit 5 - PBDS5" ]
            # [ inline ( always ) ]
            pub fn pbds5(&mut self) -> _Pbds5W {
                _Pbds5W { w: self }
            }
            # [ doc = "Bit 6 - PBDS6" ]
            # [ inline ( always ) ]
            pub fn pbds6(&mut self) -> _Pbds6W {
                _Pbds6W { w: self }
            }
            # [ doc = "Bit 7 - PBDS7" ]
            # [ inline ( always ) ]
            pub fn pbds7(&mut self) -> _Pbds7W {
                _Pbds7W { w: self }
            }
            # [ doc = "Bit 8 - PBDS8" ]
            # [ inline ( always ) ]
            pub fn pbds8(&mut self) -> _Pbds8W {
                _Pbds8W { w: self }
            }
            # [ doc = "Bit 9 - PBDS9" ]
            # [ inline ( always ) ]
            pub fn pbds9(&mut self) -> _Pbds9W {
                _Pbds9W { w: self }
            }
            # [ doc = "Bit 10 - PBDS10" ]
            # [ inline ( always ) ]
            pub fn pbds10(&mut self) -> _Pbds10W {
                _Pbds10W { w: self }
            }
            # [ doc = "Bit 11 - PBDS11" ]
            # [ inline ( always ) ]
            pub fn pbds11(&mut self) -> _Pbds11W {
                _Pbds11W { w: self }
            }
            # [ doc = "Bit 12 - PBDS12" ]
            # [ inline ( always ) ]
            pub fn pbds12(&mut self) -> _Pbds12W {
                _Pbds12W { w: self }
            }
            # [ doc = "Bit 13 - PBDS13" ]
            # [ inline ( always ) ]
            pub fn pbds13(&mut self) -> _Pbds13W {
                _Pbds13W { w: self }
            }
            # [ doc = "Bit 14 - PBDS14" ]
            # [ inline ( always ) ]
            pub fn pbds14(&mut self) -> _Pbds14W {
                _Pbds14W { w: self }
            }
            # [ doc = "Bit 15 - PBDS15" ]
            # [ inline ( always ) ]
            pub fn pbds15(&mut self) -> _Pbds15W {
                _Pbds15W { w: self }
            }
        }
    }
    # [ doc = "Port B Selection" ]
    pub struct Pbsel {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port B Selection" ]
    pub mod pbsel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pbsel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel0R {
            bits: u8,
        }
        impl Pbsel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel1R {
            bits: u8,
        }
        impl Pbsel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel2R {
            bits: u8,
        }
        impl Pbsel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel3R {
            bits: u8,
        }
        impl Pbsel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel4R {
            bits: u8,
        }
        impl Pbsel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel5R {
            bits: u8,
        }
        impl Pbsel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel6R {
            bits: u8,
        }
        impl Pbsel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel7R {
            bits: u8,
        }
        impl Pbsel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel8R {
            bits: u8,
        }
        impl Pbsel8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel9R {
            bits: u8,
        }
        impl Pbsel9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel10R {
            bits: u8,
        }
        impl Pbsel10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel11R {
            bits: u8,
        }
        impl Pbsel11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel12R {
            bits: u8,
        }
        impl Pbsel12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel13R {
            bits: u8,
        }
        impl Pbsel13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel14R {
            bits: u8,
        }
        impl Pbsel14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pbsel15R {
            bits: u8,
        }
        impl Pbsel15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pbsel15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pbsel15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PBSEL0" ]
            # [ inline ( always ) ]
            pub fn pbsel0(&self) -> Pbsel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel0R { bits }
            }
            # [ doc = "Bit 1 - PBSEL1" ]
            # [ inline ( always ) ]
            pub fn pbsel1(&self) -> Pbsel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel1R { bits }
            }
            # [ doc = "Bit 2 - PBSEL2" ]
            # [ inline ( always ) ]
            pub fn pbsel2(&self) -> Pbsel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel2R { bits }
            }
            # [ doc = "Bit 3 - PBSEL3" ]
            # [ inline ( always ) ]
            pub fn pbsel3(&self) -> Pbsel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel3R { bits }
            }
            # [ doc = "Bit 4 - PBSEL4" ]
            # [ inline ( always ) ]
            pub fn pbsel4(&self) -> Pbsel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel4R { bits }
            }
            # [ doc = "Bit 5 - PBSEL5" ]
            # [ inline ( always ) ]
            pub fn pbsel5(&self) -> Pbsel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel5R { bits }
            }
            # [ doc = "Bit 6 - PBSEL6" ]
            # [ inline ( always ) ]
            pub fn pbsel6(&self) -> Pbsel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel6R { bits }
            }
            # [ doc = "Bit 7 - PBSEL7" ]
            # [ inline ( always ) ]
            pub fn pbsel7(&self) -> Pbsel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel7R { bits }
            }
            # [ doc = "Bit 8 - PBSEL8" ]
            # [ inline ( always ) ]
            pub fn pbsel8(&self) -> Pbsel8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel8R { bits }
            }
            # [ doc = "Bit 9 - PBSEL9" ]
            # [ inline ( always ) ]
            pub fn pbsel9(&self) -> Pbsel9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel9R { bits }
            }
            # [ doc = "Bit 10 - PBSEL10" ]
            # [ inline ( always ) ]
            pub fn pbsel10(&self) -> Pbsel10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel10R { bits }
            }
            # [ doc = "Bit 11 - PBSEL11" ]
            # [ inline ( always ) ]
            pub fn pbsel11(&self) -> Pbsel11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel11R { bits }
            }
            # [ doc = "Bit 12 - PBSEL12" ]
            # [ inline ( always ) ]
            pub fn pbsel12(&self) -> Pbsel12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel12R { bits }
            }
            # [ doc = "Bit 13 - PBSEL13" ]
            # [ inline ( always ) ]
            pub fn pbsel13(&self) -> Pbsel13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel13R { bits }
            }
            # [ doc = "Bit 14 - PBSEL14" ]
            # [ inline ( always ) ]
            pub fn pbsel14(&self) -> Pbsel14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel14R { bits }
            }
            # [ doc = "Bit 15 - PBSEL15" ]
            # [ inline ( always ) ]
            pub fn pbsel15(&self) -> Pbsel15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pbsel15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PBSEL0" ]
            # [ inline ( always ) ]
            pub fn pbsel0(&mut self) -> _Pbsel0W {
                _Pbsel0W { w: self }
            }
            # [ doc = "Bit 1 - PBSEL1" ]
            # [ inline ( always ) ]
            pub fn pbsel1(&mut self) -> _Pbsel1W {
                _Pbsel1W { w: self }
            }
            # [ doc = "Bit 2 - PBSEL2" ]
            # [ inline ( always ) ]
            pub fn pbsel2(&mut self) -> _Pbsel2W {
                _Pbsel2W { w: self }
            }
            # [ doc = "Bit 3 - PBSEL3" ]
            # [ inline ( always ) ]
            pub fn pbsel3(&mut self) -> _Pbsel3W {
                _Pbsel3W { w: self }
            }
            # [ doc = "Bit 4 - PBSEL4" ]
            # [ inline ( always ) ]
            pub fn pbsel4(&mut self) -> _Pbsel4W {
                _Pbsel4W { w: self }
            }
            # [ doc = "Bit 5 - PBSEL5" ]
            # [ inline ( always ) ]
            pub fn pbsel5(&mut self) -> _Pbsel5W {
                _Pbsel5W { w: self }
            }
            # [ doc = "Bit 6 - PBSEL6" ]
            # [ inline ( always ) ]
            pub fn pbsel6(&mut self) -> _Pbsel6W {
                _Pbsel6W { w: self }
            }
            # [ doc = "Bit 7 - PBSEL7" ]
            # [ inline ( always ) ]
            pub fn pbsel7(&mut self) -> _Pbsel7W {
                _Pbsel7W { w: self }
            }
            # [ doc = "Bit 8 - PBSEL8" ]
            # [ inline ( always ) ]
            pub fn pbsel8(&mut self) -> _Pbsel8W {
                _Pbsel8W { w: self }
            }
            # [ doc = "Bit 9 - PBSEL9" ]
            # [ inline ( always ) ]
            pub fn pbsel9(&mut self) -> _Pbsel9W {
                _Pbsel9W { w: self }
            }
            # [ doc = "Bit 10 - PBSEL10" ]
            # [ inline ( always ) ]
            pub fn pbsel10(&mut self) -> _Pbsel10W {
                _Pbsel10W { w: self }
            }
            # [ doc = "Bit 11 - PBSEL11" ]
            # [ inline ( always ) ]
            pub fn pbsel11(&mut self) -> _Pbsel11W {
                _Pbsel11W { w: self }
            }
            # [ doc = "Bit 12 - PBSEL12" ]
            # [ inline ( always ) ]
            pub fn pbsel12(&mut self) -> _Pbsel12W {
                _Pbsel12W { w: self }
            }
            # [ doc = "Bit 13 - PBSEL13" ]
            # [ inline ( always ) ]
            pub fn pbsel13(&mut self) -> _Pbsel13W {
                _Pbsel13W { w: self }
            }
            # [ doc = "Bit 14 - PBSEL14" ]
            # [ inline ( always ) ]
            pub fn pbsel14(&mut self) -> _Pbsel14W {
                _Pbsel14W { w: self }
            }
            # [ doc = "Bit 15 - PBSEL15" ]
            # [ inline ( always ) ]
            pub fn pbsel15(&mut self) -> _Pbsel15W {
                _Pbsel15W { w: self }
            }
        }
    }
}
# [ doc = "Port B" ]
pub struct PortB {
    register_block: port_b::RegisterBlock,
}
impl Deref for PortB {
    type Target = port_b::RegisterBlock;
    fn deref(&self) -> &port_b::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port 3/4" ]
pub const PORT_3_4: Peripheral<Port34> = unsafe { Peripheral::new(0) };
# [ doc = "Port 3/4" ]
pub mod port_3_4 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 544usize],
        # [ doc = "0x220 - Port 3 Input" ]
        pub p3in: P3in,
        # [ doc = "0x221 - Port 4 Input" ]
        pub p4in: P4in,
        # [ doc = "0x222 - Port 3 Output" ]
        pub p3out: P3out,
        # [ doc = "0x223 - Port 4 Output" ]
        pub p4out: P4out,
        # [ doc = "0x224 - Port 3 Direction" ]
        pub p3dir: P3dir,
        # [ doc = "0x225 - Port 4 Direction" ]
        pub p4dir: P4dir,
        # [ doc = "0x226 - Port 3 Resistor Enable" ]
        pub p3ren: P3ren,
        # [ doc = "0x227 - Port 4 Resistor Enable" ]
        pub p4ren: P4ren,
        # [ doc = "0x228 - Port 3 Drive Strenght" ]
        pub p3ds: P3ds,
        # [ doc = "0x229 - Port 4 Drive Strenght" ]
        pub p4ds: P4ds,
        # [ doc = "0x22a - Port 3 Selection" ]
        pub p3sel: P3sel,
        # [ doc = "0x22b - Port 4 Selection" ]
        pub p4sel: P4sel,
    }
    # [ doc = "Port 3 Input" ]
    pub struct P3in {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 3 Input" ]
    pub mod p3in {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3in {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in0R {
            bits: u8,
        }
        impl P3in0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in1R {
            bits: u8,
        }
        impl P3in1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in2R {
            bits: u8,
        }
        impl P3in2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in3R {
            bits: u8,
        }
        impl P3in3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in4R {
            bits: u8,
        }
        impl P3in4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in5R {
            bits: u8,
        }
        impl P3in5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in6R {
            bits: u8,
        }
        impl P3in6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3in7R {
            bits: u8,
        }
        impl P3in7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3in7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3in7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P3IN0" ]
            # [ inline ( always ) ]
            pub fn p3in0(&self) -> P3in0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in0R { bits }
            }
            # [ doc = "Bit 1 - P3IN1" ]
            # [ inline ( always ) ]
            pub fn p3in1(&self) -> P3in1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in1R { bits }
            }
            # [ doc = "Bit 2 - P3IN2" ]
            # [ inline ( always ) ]
            pub fn p3in2(&self) -> P3in2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in2R { bits }
            }
            # [ doc = "Bit 3 - P3IN3" ]
            # [ inline ( always ) ]
            pub fn p3in3(&self) -> P3in3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in3R { bits }
            }
            # [ doc = "Bit 4 - P3IN4" ]
            # [ inline ( always ) ]
            pub fn p3in4(&self) -> P3in4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in4R { bits }
            }
            # [ doc = "Bit 5 - P3IN5" ]
            # [ inline ( always ) ]
            pub fn p3in5(&self) -> P3in5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in5R { bits }
            }
            # [ doc = "Bit 6 - P3IN6" ]
            # [ inline ( always ) ]
            pub fn p3in6(&self) -> P3in6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in6R { bits }
            }
            # [ doc = "Bit 7 - P3IN7" ]
            # [ inline ( always ) ]
            pub fn p3in7(&self) -> P3in7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3in7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P3IN0" ]
            # [ inline ( always ) ]
            pub fn p3in0(&mut self) -> _P3in0W {
                _P3in0W { w: self }
            }
            # [ doc = "Bit 1 - P3IN1" ]
            # [ inline ( always ) ]
            pub fn p3in1(&mut self) -> _P3in1W {
                _P3in1W { w: self }
            }
            # [ doc = "Bit 2 - P3IN2" ]
            # [ inline ( always ) ]
            pub fn p3in2(&mut self) -> _P3in2W {
                _P3in2W { w: self }
            }
            # [ doc = "Bit 3 - P3IN3" ]
            # [ inline ( always ) ]
            pub fn p3in3(&mut self) -> _P3in3W {
                _P3in3W { w: self }
            }
            # [ doc = "Bit 4 - P3IN4" ]
            # [ inline ( always ) ]
            pub fn p3in4(&mut self) -> _P3in4W {
                _P3in4W { w: self }
            }
            # [ doc = "Bit 5 - P3IN5" ]
            # [ inline ( always ) ]
            pub fn p3in5(&mut self) -> _P3in5W {
                _P3in5W { w: self }
            }
            # [ doc = "Bit 6 - P3IN6" ]
            # [ inline ( always ) ]
            pub fn p3in6(&mut self) -> _P3in6W {
                _P3in6W { w: self }
            }
            # [ doc = "Bit 7 - P3IN7" ]
            # [ inline ( always ) ]
            pub fn p3in7(&mut self) -> _P3in7W {
                _P3in7W { w: self }
            }
        }
    }
    # [ doc = "Port 3 Output" ]
    pub struct P3out {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 3 Output" ]
    pub mod p3out {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3out {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out0R {
            bits: u8,
        }
        impl P3out0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out1R {
            bits: u8,
        }
        impl P3out1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out2R {
            bits: u8,
        }
        impl P3out2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out3R {
            bits: u8,
        }
        impl P3out3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out4R {
            bits: u8,
        }
        impl P3out4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out5R {
            bits: u8,
        }
        impl P3out5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out6R {
            bits: u8,
        }
        impl P3out6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3out7R {
            bits: u8,
        }
        impl P3out7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3out7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3out7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P3OUT0" ]
            # [ inline ( always ) ]
            pub fn p3out0(&self) -> P3out0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out0R { bits }
            }
            # [ doc = "Bit 1 - P3OUT1" ]
            # [ inline ( always ) ]
            pub fn p3out1(&self) -> P3out1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out1R { bits }
            }
            # [ doc = "Bit 2 - P3OUT2" ]
            # [ inline ( always ) ]
            pub fn p3out2(&self) -> P3out2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out2R { bits }
            }
            # [ doc = "Bit 3 - P3OUT3" ]
            # [ inline ( always ) ]
            pub fn p3out3(&self) -> P3out3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out3R { bits }
            }
            # [ doc = "Bit 4 - P3OUT4" ]
            # [ inline ( always ) ]
            pub fn p3out4(&self) -> P3out4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out4R { bits }
            }
            # [ doc = "Bit 5 - P3OUT5" ]
            # [ inline ( always ) ]
            pub fn p3out5(&self) -> P3out5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out5R { bits }
            }
            # [ doc = "Bit 6 - P3OUT6" ]
            # [ inline ( always ) ]
            pub fn p3out6(&self) -> P3out6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out6R { bits }
            }
            # [ doc = "Bit 7 - P3OUT7" ]
            # [ inline ( always ) ]
            pub fn p3out7(&self) -> P3out7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3out7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P3OUT0" ]
            # [ inline ( always ) ]
            pub fn p3out0(&mut self) -> _P3out0W {
                _P3out0W { w: self }
            }
            # [ doc = "Bit 1 - P3OUT1" ]
            # [ inline ( always ) ]
            pub fn p3out1(&mut self) -> _P3out1W {
                _P3out1W { w: self }
            }
            # [ doc = "Bit 2 - P3OUT2" ]
            # [ inline ( always ) ]
            pub fn p3out2(&mut self) -> _P3out2W {
                _P3out2W { w: self }
            }
            # [ doc = "Bit 3 - P3OUT3" ]
            # [ inline ( always ) ]
            pub fn p3out3(&mut self) -> _P3out3W {
                _P3out3W { w: self }
            }
            # [ doc = "Bit 4 - P3OUT4" ]
            # [ inline ( always ) ]
            pub fn p3out4(&mut self) -> _P3out4W {
                _P3out4W { w: self }
            }
            # [ doc = "Bit 5 - P3OUT5" ]
            # [ inline ( always ) ]
            pub fn p3out5(&mut self) -> _P3out5W {
                _P3out5W { w: self }
            }
            # [ doc = "Bit 6 - P3OUT6" ]
            # [ inline ( always ) ]
            pub fn p3out6(&mut self) -> _P3out6W {
                _P3out6W { w: self }
            }
            # [ doc = "Bit 7 - P3OUT7" ]
            # [ inline ( always ) ]
            pub fn p3out7(&mut self) -> _P3out7W {
                _P3out7W { w: self }
            }
        }
    }
    # [ doc = "Port 3 Direction" ]
    pub struct P3dir {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 3 Direction" ]
    pub mod p3dir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3dir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir0R {
            bits: u8,
        }
        impl P3dir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir1R {
            bits: u8,
        }
        impl P3dir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir2R {
            bits: u8,
        }
        impl P3dir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir3R {
            bits: u8,
        }
        impl P3dir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir4R {
            bits: u8,
        }
        impl P3dir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir5R {
            bits: u8,
        }
        impl P3dir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir6R {
            bits: u8,
        }
        impl P3dir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3dir7R {
            bits: u8,
        }
        impl P3dir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3dir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3dir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P3DIR0" ]
            # [ inline ( always ) ]
            pub fn p3dir0(&self) -> P3dir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir0R { bits }
            }
            # [ doc = "Bit 1 - P3DIR1" ]
            # [ inline ( always ) ]
            pub fn p3dir1(&self) -> P3dir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir1R { bits }
            }
            # [ doc = "Bit 2 - P3DIR2" ]
            # [ inline ( always ) ]
            pub fn p3dir2(&self) -> P3dir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir2R { bits }
            }
            # [ doc = "Bit 3 - P3DIR3" ]
            # [ inline ( always ) ]
            pub fn p3dir3(&self) -> P3dir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir3R { bits }
            }
            # [ doc = "Bit 4 - P3DIR4" ]
            # [ inline ( always ) ]
            pub fn p3dir4(&self) -> P3dir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir4R { bits }
            }
            # [ doc = "Bit 5 - P3DIR5" ]
            # [ inline ( always ) ]
            pub fn p3dir5(&self) -> P3dir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir5R { bits }
            }
            # [ doc = "Bit 6 - P3DIR6" ]
            # [ inline ( always ) ]
            pub fn p3dir6(&self) -> P3dir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir6R { bits }
            }
            # [ doc = "Bit 7 - P3DIR7" ]
            # [ inline ( always ) ]
            pub fn p3dir7(&self) -> P3dir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3dir7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P3DIR0" ]
            # [ inline ( always ) ]
            pub fn p3dir0(&mut self) -> _P3dir0W {
                _P3dir0W { w: self }
            }
            # [ doc = "Bit 1 - P3DIR1" ]
            # [ inline ( always ) ]
            pub fn p3dir1(&mut self) -> _P3dir1W {
                _P3dir1W { w: self }
            }
            # [ doc = "Bit 2 - P3DIR2" ]
            # [ inline ( always ) ]
            pub fn p3dir2(&mut self) -> _P3dir2W {
                _P3dir2W { w: self }
            }
            # [ doc = "Bit 3 - P3DIR3" ]
            # [ inline ( always ) ]
            pub fn p3dir3(&mut self) -> _P3dir3W {
                _P3dir3W { w: self }
            }
            # [ doc = "Bit 4 - P3DIR4" ]
            # [ inline ( always ) ]
            pub fn p3dir4(&mut self) -> _P3dir4W {
                _P3dir4W { w: self }
            }
            # [ doc = "Bit 5 - P3DIR5" ]
            # [ inline ( always ) ]
            pub fn p3dir5(&mut self) -> _P3dir5W {
                _P3dir5W { w: self }
            }
            # [ doc = "Bit 6 - P3DIR6" ]
            # [ inline ( always ) ]
            pub fn p3dir6(&mut self) -> _P3dir6W {
                _P3dir6W { w: self }
            }
            # [ doc = "Bit 7 - P3DIR7" ]
            # [ inline ( always ) ]
            pub fn p3dir7(&mut self) -> _P3dir7W {
                _P3dir7W { w: self }
            }
        }
    }
    # [ doc = "Port 3 Resistor Enable" ]
    pub struct P3ren {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 3 Resistor Enable" ]
    pub mod p3ren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3ren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren0R {
            bits: u8,
        }
        impl P3ren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren1R {
            bits: u8,
        }
        impl P3ren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren2R {
            bits: u8,
        }
        impl P3ren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren3R {
            bits: u8,
        }
        impl P3ren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren4R {
            bits: u8,
        }
        impl P3ren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren5R {
            bits: u8,
        }
        impl P3ren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren6R {
            bits: u8,
        }
        impl P3ren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ren7R {
            bits: u8,
        }
        impl P3ren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P3REN0" ]
            # [ inline ( always ) ]
            pub fn p3ren0(&self) -> P3ren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren0R { bits }
            }
            # [ doc = "Bit 1 - P3REN1" ]
            # [ inline ( always ) ]
            pub fn p3ren1(&self) -> P3ren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren1R { bits }
            }
            # [ doc = "Bit 2 - P3REN2" ]
            # [ inline ( always ) ]
            pub fn p3ren2(&self) -> P3ren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren2R { bits }
            }
            # [ doc = "Bit 3 - P3REN3" ]
            # [ inline ( always ) ]
            pub fn p3ren3(&self) -> P3ren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren3R { bits }
            }
            # [ doc = "Bit 4 - P3REN4" ]
            # [ inline ( always ) ]
            pub fn p3ren4(&self) -> P3ren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren4R { bits }
            }
            # [ doc = "Bit 5 - P3REN5" ]
            # [ inline ( always ) ]
            pub fn p3ren5(&self) -> P3ren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren5R { bits }
            }
            # [ doc = "Bit 6 - P3REN6" ]
            # [ inline ( always ) ]
            pub fn p3ren6(&self) -> P3ren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren6R { bits }
            }
            # [ doc = "Bit 7 - P3REN7" ]
            # [ inline ( always ) ]
            pub fn p3ren7(&self) -> P3ren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ren7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P3REN0" ]
            # [ inline ( always ) ]
            pub fn p3ren0(&mut self) -> _P3ren0W {
                _P3ren0W { w: self }
            }
            # [ doc = "Bit 1 - P3REN1" ]
            # [ inline ( always ) ]
            pub fn p3ren1(&mut self) -> _P3ren1W {
                _P3ren1W { w: self }
            }
            # [ doc = "Bit 2 - P3REN2" ]
            # [ inline ( always ) ]
            pub fn p3ren2(&mut self) -> _P3ren2W {
                _P3ren2W { w: self }
            }
            # [ doc = "Bit 3 - P3REN3" ]
            # [ inline ( always ) ]
            pub fn p3ren3(&mut self) -> _P3ren3W {
                _P3ren3W { w: self }
            }
            # [ doc = "Bit 4 - P3REN4" ]
            # [ inline ( always ) ]
            pub fn p3ren4(&mut self) -> _P3ren4W {
                _P3ren4W { w: self }
            }
            # [ doc = "Bit 5 - P3REN5" ]
            # [ inline ( always ) ]
            pub fn p3ren5(&mut self) -> _P3ren5W {
                _P3ren5W { w: self }
            }
            # [ doc = "Bit 6 - P3REN6" ]
            # [ inline ( always ) ]
            pub fn p3ren6(&mut self) -> _P3ren6W {
                _P3ren6W { w: self }
            }
            # [ doc = "Bit 7 - P3REN7" ]
            # [ inline ( always ) ]
            pub fn p3ren7(&mut self) -> _P3ren7W {
                _P3ren7W { w: self }
            }
        }
    }
    # [ doc = "Port 3 Drive Strenght" ]
    pub struct P3ds {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 3 Drive Strenght" ]
    pub mod p3ds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3ds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds0R {
            bits: u8,
        }
        impl P3ds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds1R {
            bits: u8,
        }
        impl P3ds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds2R {
            bits: u8,
        }
        impl P3ds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds3R {
            bits: u8,
        }
        impl P3ds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds4R {
            bits: u8,
        }
        impl P3ds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds5R {
            bits: u8,
        }
        impl P3ds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds6R {
            bits: u8,
        }
        impl P3ds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3ds7R {
            bits: u8,
        }
        impl P3ds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3ds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3ds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P3DS0" ]
            # [ inline ( always ) ]
            pub fn p3ds0(&self) -> P3ds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds0R { bits }
            }
            # [ doc = "Bit 1 - P3DS1" ]
            # [ inline ( always ) ]
            pub fn p3ds1(&self) -> P3ds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds1R { bits }
            }
            # [ doc = "Bit 2 - P3DS2" ]
            # [ inline ( always ) ]
            pub fn p3ds2(&self) -> P3ds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds2R { bits }
            }
            # [ doc = "Bit 3 - P3DS3" ]
            # [ inline ( always ) ]
            pub fn p3ds3(&self) -> P3ds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds3R { bits }
            }
            # [ doc = "Bit 4 - P3DS4" ]
            # [ inline ( always ) ]
            pub fn p3ds4(&self) -> P3ds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds4R { bits }
            }
            # [ doc = "Bit 5 - P3DS5" ]
            # [ inline ( always ) ]
            pub fn p3ds5(&self) -> P3ds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds5R { bits }
            }
            # [ doc = "Bit 6 - P3DS6" ]
            # [ inline ( always ) ]
            pub fn p3ds6(&self) -> P3ds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds6R { bits }
            }
            # [ doc = "Bit 7 - P3DS7" ]
            # [ inline ( always ) ]
            pub fn p3ds7(&self) -> P3ds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3ds7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P3DS0" ]
            # [ inline ( always ) ]
            pub fn p3ds0(&mut self) -> _P3ds0W {
                _P3ds0W { w: self }
            }
            # [ doc = "Bit 1 - P3DS1" ]
            # [ inline ( always ) ]
            pub fn p3ds1(&mut self) -> _P3ds1W {
                _P3ds1W { w: self }
            }
            # [ doc = "Bit 2 - P3DS2" ]
            # [ inline ( always ) ]
            pub fn p3ds2(&mut self) -> _P3ds2W {
                _P3ds2W { w: self }
            }
            # [ doc = "Bit 3 - P3DS3" ]
            # [ inline ( always ) ]
            pub fn p3ds3(&mut self) -> _P3ds3W {
                _P3ds3W { w: self }
            }
            # [ doc = "Bit 4 - P3DS4" ]
            # [ inline ( always ) ]
            pub fn p3ds4(&mut self) -> _P3ds4W {
                _P3ds4W { w: self }
            }
            # [ doc = "Bit 5 - P3DS5" ]
            # [ inline ( always ) ]
            pub fn p3ds5(&mut self) -> _P3ds5W {
                _P3ds5W { w: self }
            }
            # [ doc = "Bit 6 - P3DS6" ]
            # [ inline ( always ) ]
            pub fn p3ds6(&mut self) -> _P3ds6W {
                _P3ds6W { w: self }
            }
            # [ doc = "Bit 7 - P3DS7" ]
            # [ inline ( always ) ]
            pub fn p3ds7(&mut self) -> _P3ds7W {
                _P3ds7W { w: self }
            }
        }
    }
    # [ doc = "Port 3 Selection" ]
    pub struct P3sel {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 3 Selection" ]
    pub mod p3sel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3sel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel0R {
            bits: u8,
        }
        impl P3sel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel1R {
            bits: u8,
        }
        impl P3sel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel2R {
            bits: u8,
        }
        impl P3sel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel3R {
            bits: u8,
        }
        impl P3sel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel4R {
            bits: u8,
        }
        impl P3sel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel5R {
            bits: u8,
        }
        impl P3sel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel6R {
            bits: u8,
        }
        impl P3sel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P3sel7R {
            bits: u8,
        }
        impl P3sel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P3sel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P3sel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P3SEL0" ]
            # [ inline ( always ) ]
            pub fn p3sel0(&self) -> P3sel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel0R { bits }
            }
            # [ doc = "Bit 1 - P3SEL1" ]
            # [ inline ( always ) ]
            pub fn p3sel1(&self) -> P3sel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel1R { bits }
            }
            # [ doc = "Bit 2 - P3SEL2" ]
            # [ inline ( always ) ]
            pub fn p3sel2(&self) -> P3sel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel2R { bits }
            }
            # [ doc = "Bit 3 - P3SEL3" ]
            # [ inline ( always ) ]
            pub fn p3sel3(&self) -> P3sel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel3R { bits }
            }
            # [ doc = "Bit 4 - P3SEL4" ]
            # [ inline ( always ) ]
            pub fn p3sel4(&self) -> P3sel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel4R { bits }
            }
            # [ doc = "Bit 5 - P3SEL5" ]
            # [ inline ( always ) ]
            pub fn p3sel5(&self) -> P3sel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel5R { bits }
            }
            # [ doc = "Bit 6 - P3SEL6" ]
            # [ inline ( always ) ]
            pub fn p3sel6(&self) -> P3sel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel6R { bits }
            }
            # [ doc = "Bit 7 - P3SEL7" ]
            # [ inline ( always ) ]
            pub fn p3sel7(&self) -> P3sel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P3sel7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P3SEL0" ]
            # [ inline ( always ) ]
            pub fn p3sel0(&mut self) -> _P3sel0W {
                _P3sel0W { w: self }
            }
            # [ doc = "Bit 1 - P3SEL1" ]
            # [ inline ( always ) ]
            pub fn p3sel1(&mut self) -> _P3sel1W {
                _P3sel1W { w: self }
            }
            # [ doc = "Bit 2 - P3SEL2" ]
            # [ inline ( always ) ]
            pub fn p3sel2(&mut self) -> _P3sel2W {
                _P3sel2W { w: self }
            }
            # [ doc = "Bit 3 - P3SEL3" ]
            # [ inline ( always ) ]
            pub fn p3sel3(&mut self) -> _P3sel3W {
                _P3sel3W { w: self }
            }
            # [ doc = "Bit 4 - P3SEL4" ]
            # [ inline ( always ) ]
            pub fn p3sel4(&mut self) -> _P3sel4W {
                _P3sel4W { w: self }
            }
            # [ doc = "Bit 5 - P3SEL5" ]
            # [ inline ( always ) ]
            pub fn p3sel5(&mut self) -> _P3sel5W {
                _P3sel5W { w: self }
            }
            # [ doc = "Bit 6 - P3SEL6" ]
            # [ inline ( always ) ]
            pub fn p3sel6(&mut self) -> _P3sel6W {
                _P3sel6W { w: self }
            }
            # [ doc = "Bit 7 - P3SEL7" ]
            # [ inline ( always ) ]
            pub fn p3sel7(&mut self) -> _P3sel7W {
                _P3sel7W { w: self }
            }
        }
    }
    # [ doc = "Port 4 Input" ]
    pub struct P4in {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 4 Input" ]
    pub mod p4in {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P4in {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in0R {
            bits: u8,
        }
        impl P4in0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in1R {
            bits: u8,
        }
        impl P4in1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in2R {
            bits: u8,
        }
        impl P4in2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in3R {
            bits: u8,
        }
        impl P4in3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in4R {
            bits: u8,
        }
        impl P4in4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in5R {
            bits: u8,
        }
        impl P4in5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in6R {
            bits: u8,
        }
        impl P4in6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4in7R {
            bits: u8,
        }
        impl P4in7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4in7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4in7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P4IN0" ]
            # [ inline ( always ) ]
            pub fn p4in0(&self) -> P4in0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in0R { bits }
            }
            # [ doc = "Bit 1 - P4IN1" ]
            # [ inline ( always ) ]
            pub fn p4in1(&self) -> P4in1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in1R { bits }
            }
            # [ doc = "Bit 2 - P4IN2" ]
            # [ inline ( always ) ]
            pub fn p4in2(&self) -> P4in2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in2R { bits }
            }
            # [ doc = "Bit 3 - P4IN3" ]
            # [ inline ( always ) ]
            pub fn p4in3(&self) -> P4in3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in3R { bits }
            }
            # [ doc = "Bit 4 - P4IN4" ]
            # [ inline ( always ) ]
            pub fn p4in4(&self) -> P4in4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in4R { bits }
            }
            # [ doc = "Bit 5 - P4IN5" ]
            # [ inline ( always ) ]
            pub fn p4in5(&self) -> P4in5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in5R { bits }
            }
            # [ doc = "Bit 6 - P4IN6" ]
            # [ inline ( always ) ]
            pub fn p4in6(&self) -> P4in6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in6R { bits }
            }
            # [ doc = "Bit 7 - P4IN7" ]
            # [ inline ( always ) ]
            pub fn p4in7(&self) -> P4in7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4in7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P4IN0" ]
            # [ inline ( always ) ]
            pub fn p4in0(&mut self) -> _P4in0W {
                _P4in0W { w: self }
            }
            # [ doc = "Bit 1 - P4IN1" ]
            # [ inline ( always ) ]
            pub fn p4in1(&mut self) -> _P4in1W {
                _P4in1W { w: self }
            }
            # [ doc = "Bit 2 - P4IN2" ]
            # [ inline ( always ) ]
            pub fn p4in2(&mut self) -> _P4in2W {
                _P4in2W { w: self }
            }
            # [ doc = "Bit 3 - P4IN3" ]
            # [ inline ( always ) ]
            pub fn p4in3(&mut self) -> _P4in3W {
                _P4in3W { w: self }
            }
            # [ doc = "Bit 4 - P4IN4" ]
            # [ inline ( always ) ]
            pub fn p4in4(&mut self) -> _P4in4W {
                _P4in4W { w: self }
            }
            # [ doc = "Bit 5 - P4IN5" ]
            # [ inline ( always ) ]
            pub fn p4in5(&mut self) -> _P4in5W {
                _P4in5W { w: self }
            }
            # [ doc = "Bit 6 - P4IN6" ]
            # [ inline ( always ) ]
            pub fn p4in6(&mut self) -> _P4in6W {
                _P4in6W { w: self }
            }
            # [ doc = "Bit 7 - P4IN7" ]
            # [ inline ( always ) ]
            pub fn p4in7(&mut self) -> _P4in7W {
                _P4in7W { w: self }
            }
        }
    }
    # [ doc = "Port 4 Output" ]
    pub struct P4out {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 4 Output" ]
    pub mod p4out {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P4out {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out0R {
            bits: u8,
        }
        impl P4out0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out1R {
            bits: u8,
        }
        impl P4out1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out2R {
            bits: u8,
        }
        impl P4out2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out3R {
            bits: u8,
        }
        impl P4out3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out4R {
            bits: u8,
        }
        impl P4out4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out5R {
            bits: u8,
        }
        impl P4out5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out6R {
            bits: u8,
        }
        impl P4out6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4out7R {
            bits: u8,
        }
        impl P4out7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4out7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4out7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P4OUT0" ]
            # [ inline ( always ) ]
            pub fn p4out0(&self) -> P4out0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out0R { bits }
            }
            # [ doc = "Bit 1 - P4OUT1" ]
            # [ inline ( always ) ]
            pub fn p4out1(&self) -> P4out1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out1R { bits }
            }
            # [ doc = "Bit 2 - P4OUT2" ]
            # [ inline ( always ) ]
            pub fn p4out2(&self) -> P4out2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out2R { bits }
            }
            # [ doc = "Bit 3 - P4OUT3" ]
            # [ inline ( always ) ]
            pub fn p4out3(&self) -> P4out3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out3R { bits }
            }
            # [ doc = "Bit 4 - P4OUT4" ]
            # [ inline ( always ) ]
            pub fn p4out4(&self) -> P4out4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out4R { bits }
            }
            # [ doc = "Bit 5 - P4OUT5" ]
            # [ inline ( always ) ]
            pub fn p4out5(&self) -> P4out5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out5R { bits }
            }
            # [ doc = "Bit 6 - P4OUT6" ]
            # [ inline ( always ) ]
            pub fn p4out6(&self) -> P4out6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out6R { bits }
            }
            # [ doc = "Bit 7 - P4OUT7" ]
            # [ inline ( always ) ]
            pub fn p4out7(&self) -> P4out7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4out7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P4OUT0" ]
            # [ inline ( always ) ]
            pub fn p4out0(&mut self) -> _P4out0W {
                _P4out0W { w: self }
            }
            # [ doc = "Bit 1 - P4OUT1" ]
            # [ inline ( always ) ]
            pub fn p4out1(&mut self) -> _P4out1W {
                _P4out1W { w: self }
            }
            # [ doc = "Bit 2 - P4OUT2" ]
            # [ inline ( always ) ]
            pub fn p4out2(&mut self) -> _P4out2W {
                _P4out2W { w: self }
            }
            # [ doc = "Bit 3 - P4OUT3" ]
            # [ inline ( always ) ]
            pub fn p4out3(&mut self) -> _P4out3W {
                _P4out3W { w: self }
            }
            # [ doc = "Bit 4 - P4OUT4" ]
            # [ inline ( always ) ]
            pub fn p4out4(&mut self) -> _P4out4W {
                _P4out4W { w: self }
            }
            # [ doc = "Bit 5 - P4OUT5" ]
            # [ inline ( always ) ]
            pub fn p4out5(&mut self) -> _P4out5W {
                _P4out5W { w: self }
            }
            # [ doc = "Bit 6 - P4OUT6" ]
            # [ inline ( always ) ]
            pub fn p4out6(&mut self) -> _P4out6W {
                _P4out6W { w: self }
            }
            # [ doc = "Bit 7 - P4OUT7" ]
            # [ inline ( always ) ]
            pub fn p4out7(&mut self) -> _P4out7W {
                _P4out7W { w: self }
            }
        }
    }
    # [ doc = "Port 4 Direction" ]
    pub struct P4dir {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 4 Direction" ]
    pub mod p4dir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P4dir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir0R {
            bits: u8,
        }
        impl P4dir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir1R {
            bits: u8,
        }
        impl P4dir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir2R {
            bits: u8,
        }
        impl P4dir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir3R {
            bits: u8,
        }
        impl P4dir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir4R {
            bits: u8,
        }
        impl P4dir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir5R {
            bits: u8,
        }
        impl P4dir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir6R {
            bits: u8,
        }
        impl P4dir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4dir7R {
            bits: u8,
        }
        impl P4dir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4dir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4dir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P4DIR0" ]
            # [ inline ( always ) ]
            pub fn p4dir0(&self) -> P4dir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir0R { bits }
            }
            # [ doc = "Bit 1 - P4DIR1" ]
            # [ inline ( always ) ]
            pub fn p4dir1(&self) -> P4dir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir1R { bits }
            }
            # [ doc = "Bit 2 - P4DIR2" ]
            # [ inline ( always ) ]
            pub fn p4dir2(&self) -> P4dir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir2R { bits }
            }
            # [ doc = "Bit 3 - P4DIR3" ]
            # [ inline ( always ) ]
            pub fn p4dir3(&self) -> P4dir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir3R { bits }
            }
            # [ doc = "Bit 4 - P4DIR4" ]
            # [ inline ( always ) ]
            pub fn p4dir4(&self) -> P4dir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir4R { bits }
            }
            # [ doc = "Bit 5 - P4DIR5" ]
            # [ inline ( always ) ]
            pub fn p4dir5(&self) -> P4dir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir5R { bits }
            }
            # [ doc = "Bit 6 - P4DIR6" ]
            # [ inline ( always ) ]
            pub fn p4dir6(&self) -> P4dir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir6R { bits }
            }
            # [ doc = "Bit 7 - P4DIR7" ]
            # [ inline ( always ) ]
            pub fn p4dir7(&self) -> P4dir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4dir7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P4DIR0" ]
            # [ inline ( always ) ]
            pub fn p4dir0(&mut self) -> _P4dir0W {
                _P4dir0W { w: self }
            }
            # [ doc = "Bit 1 - P4DIR1" ]
            # [ inline ( always ) ]
            pub fn p4dir1(&mut self) -> _P4dir1W {
                _P4dir1W { w: self }
            }
            # [ doc = "Bit 2 - P4DIR2" ]
            # [ inline ( always ) ]
            pub fn p4dir2(&mut self) -> _P4dir2W {
                _P4dir2W { w: self }
            }
            # [ doc = "Bit 3 - P4DIR3" ]
            # [ inline ( always ) ]
            pub fn p4dir3(&mut self) -> _P4dir3W {
                _P4dir3W { w: self }
            }
            # [ doc = "Bit 4 - P4DIR4" ]
            # [ inline ( always ) ]
            pub fn p4dir4(&mut self) -> _P4dir4W {
                _P4dir4W { w: self }
            }
            # [ doc = "Bit 5 - P4DIR5" ]
            # [ inline ( always ) ]
            pub fn p4dir5(&mut self) -> _P4dir5W {
                _P4dir5W { w: self }
            }
            # [ doc = "Bit 6 - P4DIR6" ]
            # [ inline ( always ) ]
            pub fn p4dir6(&mut self) -> _P4dir6W {
                _P4dir6W { w: self }
            }
            # [ doc = "Bit 7 - P4DIR7" ]
            # [ inline ( always ) ]
            pub fn p4dir7(&mut self) -> _P4dir7W {
                _P4dir7W { w: self }
            }
        }
    }
    # [ doc = "Port 4 Resistor Enable" ]
    pub struct P4ren {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 4 Resistor Enable" ]
    pub mod p4ren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P4ren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren0R {
            bits: u8,
        }
        impl P4ren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren1R {
            bits: u8,
        }
        impl P4ren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren2R {
            bits: u8,
        }
        impl P4ren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren3R {
            bits: u8,
        }
        impl P4ren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren4R {
            bits: u8,
        }
        impl P4ren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren5R {
            bits: u8,
        }
        impl P4ren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren6R {
            bits: u8,
        }
        impl P4ren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ren7R {
            bits: u8,
        }
        impl P4ren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P4REN0" ]
            # [ inline ( always ) ]
            pub fn p4ren0(&self) -> P4ren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren0R { bits }
            }
            # [ doc = "Bit 1 - P4REN1" ]
            # [ inline ( always ) ]
            pub fn p4ren1(&self) -> P4ren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren1R { bits }
            }
            # [ doc = "Bit 2 - P4REN2" ]
            # [ inline ( always ) ]
            pub fn p4ren2(&self) -> P4ren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren2R { bits }
            }
            # [ doc = "Bit 3 - P4REN3" ]
            # [ inline ( always ) ]
            pub fn p4ren3(&self) -> P4ren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren3R { bits }
            }
            # [ doc = "Bit 4 - P4REN4" ]
            # [ inline ( always ) ]
            pub fn p4ren4(&self) -> P4ren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren4R { bits }
            }
            # [ doc = "Bit 5 - P4REN5" ]
            # [ inline ( always ) ]
            pub fn p4ren5(&self) -> P4ren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren5R { bits }
            }
            # [ doc = "Bit 6 - P4REN6" ]
            # [ inline ( always ) ]
            pub fn p4ren6(&self) -> P4ren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren6R { bits }
            }
            # [ doc = "Bit 7 - P4REN7" ]
            # [ inline ( always ) ]
            pub fn p4ren7(&self) -> P4ren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ren7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P4REN0" ]
            # [ inline ( always ) ]
            pub fn p4ren0(&mut self) -> _P4ren0W {
                _P4ren0W { w: self }
            }
            # [ doc = "Bit 1 - P4REN1" ]
            # [ inline ( always ) ]
            pub fn p4ren1(&mut self) -> _P4ren1W {
                _P4ren1W { w: self }
            }
            # [ doc = "Bit 2 - P4REN2" ]
            # [ inline ( always ) ]
            pub fn p4ren2(&mut self) -> _P4ren2W {
                _P4ren2W { w: self }
            }
            # [ doc = "Bit 3 - P4REN3" ]
            # [ inline ( always ) ]
            pub fn p4ren3(&mut self) -> _P4ren3W {
                _P4ren3W { w: self }
            }
            # [ doc = "Bit 4 - P4REN4" ]
            # [ inline ( always ) ]
            pub fn p4ren4(&mut self) -> _P4ren4W {
                _P4ren4W { w: self }
            }
            # [ doc = "Bit 5 - P4REN5" ]
            # [ inline ( always ) ]
            pub fn p4ren5(&mut self) -> _P4ren5W {
                _P4ren5W { w: self }
            }
            # [ doc = "Bit 6 - P4REN6" ]
            # [ inline ( always ) ]
            pub fn p4ren6(&mut self) -> _P4ren6W {
                _P4ren6W { w: self }
            }
            # [ doc = "Bit 7 - P4REN7" ]
            # [ inline ( always ) ]
            pub fn p4ren7(&mut self) -> _P4ren7W {
                _P4ren7W { w: self }
            }
        }
    }
    # [ doc = "Port 4 Drive Strenght" ]
    pub struct P4ds {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 4 Drive Strenght" ]
    pub mod p4ds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P4ds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds0R {
            bits: u8,
        }
        impl P4ds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds1R {
            bits: u8,
        }
        impl P4ds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds2R {
            bits: u8,
        }
        impl P4ds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds3R {
            bits: u8,
        }
        impl P4ds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds4R {
            bits: u8,
        }
        impl P4ds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds5R {
            bits: u8,
        }
        impl P4ds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds6R {
            bits: u8,
        }
        impl P4ds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4ds7R {
            bits: u8,
        }
        impl P4ds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4ds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4ds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P4DS0" ]
            # [ inline ( always ) ]
            pub fn p4ds0(&self) -> P4ds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds0R { bits }
            }
            # [ doc = "Bit 1 - P4DS1" ]
            # [ inline ( always ) ]
            pub fn p4ds1(&self) -> P4ds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds1R { bits }
            }
            # [ doc = "Bit 2 - P4DS2" ]
            # [ inline ( always ) ]
            pub fn p4ds2(&self) -> P4ds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds2R { bits }
            }
            # [ doc = "Bit 3 - P4DS3" ]
            # [ inline ( always ) ]
            pub fn p4ds3(&self) -> P4ds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds3R { bits }
            }
            # [ doc = "Bit 4 - P4DS4" ]
            # [ inline ( always ) ]
            pub fn p4ds4(&self) -> P4ds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds4R { bits }
            }
            # [ doc = "Bit 5 - P4DS5" ]
            # [ inline ( always ) ]
            pub fn p4ds5(&self) -> P4ds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds5R { bits }
            }
            # [ doc = "Bit 6 - P4DS6" ]
            # [ inline ( always ) ]
            pub fn p4ds6(&self) -> P4ds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds6R { bits }
            }
            # [ doc = "Bit 7 - P4DS7" ]
            # [ inline ( always ) ]
            pub fn p4ds7(&self) -> P4ds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4ds7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P4DS0" ]
            # [ inline ( always ) ]
            pub fn p4ds0(&mut self) -> _P4ds0W {
                _P4ds0W { w: self }
            }
            # [ doc = "Bit 1 - P4DS1" ]
            # [ inline ( always ) ]
            pub fn p4ds1(&mut self) -> _P4ds1W {
                _P4ds1W { w: self }
            }
            # [ doc = "Bit 2 - P4DS2" ]
            # [ inline ( always ) ]
            pub fn p4ds2(&mut self) -> _P4ds2W {
                _P4ds2W { w: self }
            }
            # [ doc = "Bit 3 - P4DS3" ]
            # [ inline ( always ) ]
            pub fn p4ds3(&mut self) -> _P4ds3W {
                _P4ds3W { w: self }
            }
            # [ doc = "Bit 4 - P4DS4" ]
            # [ inline ( always ) ]
            pub fn p4ds4(&mut self) -> _P4ds4W {
                _P4ds4W { w: self }
            }
            # [ doc = "Bit 5 - P4DS5" ]
            # [ inline ( always ) ]
            pub fn p4ds5(&mut self) -> _P4ds5W {
                _P4ds5W { w: self }
            }
            # [ doc = "Bit 6 - P4DS6" ]
            # [ inline ( always ) ]
            pub fn p4ds6(&mut self) -> _P4ds6W {
                _P4ds6W { w: self }
            }
            # [ doc = "Bit 7 - P4DS7" ]
            # [ inline ( always ) ]
            pub fn p4ds7(&mut self) -> _P4ds7W {
                _P4ds7W { w: self }
            }
        }
    }
    # [ doc = "Port 4 Selection" ]
    pub struct P4sel {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 4 Selection" ]
    pub mod p4sel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P4sel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel0R {
            bits: u8,
        }
        impl P4sel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel1R {
            bits: u8,
        }
        impl P4sel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel2R {
            bits: u8,
        }
        impl P4sel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel3R {
            bits: u8,
        }
        impl P4sel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel4R {
            bits: u8,
        }
        impl P4sel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel5R {
            bits: u8,
        }
        impl P4sel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel6R {
            bits: u8,
        }
        impl P4sel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P4sel7R {
            bits: u8,
        }
        impl P4sel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P4sel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P4sel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P4SEL0" ]
            # [ inline ( always ) ]
            pub fn p4sel0(&self) -> P4sel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel0R { bits }
            }
            # [ doc = "Bit 1 - P4SEL1" ]
            # [ inline ( always ) ]
            pub fn p4sel1(&self) -> P4sel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel1R { bits }
            }
            # [ doc = "Bit 2 - P4SEL2" ]
            # [ inline ( always ) ]
            pub fn p4sel2(&self) -> P4sel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel2R { bits }
            }
            # [ doc = "Bit 3 - P4SEL3" ]
            # [ inline ( always ) ]
            pub fn p4sel3(&self) -> P4sel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel3R { bits }
            }
            # [ doc = "Bit 4 - P4SEL4" ]
            # [ inline ( always ) ]
            pub fn p4sel4(&self) -> P4sel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel4R { bits }
            }
            # [ doc = "Bit 5 - P4SEL5" ]
            # [ inline ( always ) ]
            pub fn p4sel5(&self) -> P4sel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel5R { bits }
            }
            # [ doc = "Bit 6 - P4SEL6" ]
            # [ inline ( always ) ]
            pub fn p4sel6(&self) -> P4sel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel6R { bits }
            }
            # [ doc = "Bit 7 - P4SEL7" ]
            # [ inline ( always ) ]
            pub fn p4sel7(&self) -> P4sel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P4sel7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P4SEL0" ]
            # [ inline ( always ) ]
            pub fn p4sel0(&mut self) -> _P4sel0W {
                _P4sel0W { w: self }
            }
            # [ doc = "Bit 1 - P4SEL1" ]
            # [ inline ( always ) ]
            pub fn p4sel1(&mut self) -> _P4sel1W {
                _P4sel1W { w: self }
            }
            # [ doc = "Bit 2 - P4SEL2" ]
            # [ inline ( always ) ]
            pub fn p4sel2(&mut self) -> _P4sel2W {
                _P4sel2W { w: self }
            }
            # [ doc = "Bit 3 - P4SEL3" ]
            # [ inline ( always ) ]
            pub fn p4sel3(&mut self) -> _P4sel3W {
                _P4sel3W { w: self }
            }
            # [ doc = "Bit 4 - P4SEL4" ]
            # [ inline ( always ) ]
            pub fn p4sel4(&mut self) -> _P4sel4W {
                _P4sel4W { w: self }
            }
            # [ doc = "Bit 5 - P4SEL5" ]
            # [ inline ( always ) ]
            pub fn p4sel5(&mut self) -> _P4sel5W {
                _P4sel5W { w: self }
            }
            # [ doc = "Bit 6 - P4SEL6" ]
            # [ inline ( always ) ]
            pub fn p4sel6(&mut self) -> _P4sel6W {
                _P4sel6W { w: self }
            }
            # [ doc = "Bit 7 - P4SEL7" ]
            # [ inline ( always ) ]
            pub fn p4sel7(&mut self) -> _P4sel7W {
                _P4sel7W { w: self }
            }
        }
    }
}
# [ doc = "Port 3/4" ]
pub struct Port34 {
    register_block: port_3_4::RegisterBlock,
}
impl Deref for Port34 {
    type Target = port_3_4::RegisterBlock;
    fn deref(&self) -> &port_3_4::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port C" ]
pub const PORT_C: Peripheral<PortC> = unsafe { Peripheral::new(0) };
# [ doc = "Port C" ]
pub mod port_c {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 576usize],
        # [ doc = "0x240 - Port C Input" ]
        pub pcin: Pcin,
        # [ doc = "0x242 - Port C Output" ]
        pub pcout: Pcout,
        # [ doc = "0x244 - Port C Direction" ]
        pub pcdir: Pcdir,
        # [ doc = "0x246 - Port C Resistor Enable" ]
        pub pcren: Pcren,
        # [ doc = "0x248 - Port C Drive Strenght" ]
        pub pcds: Pcds,
        # [ doc = "0x24a - Port C Selection" ]
        pub pcsel: Pcsel,
    }
    # [ doc = "Port C Input" ]
    pub struct Pcin {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port C Input" ]
    pub mod pcin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pcin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin0R {
            bits: u8,
        }
        impl Pcin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin1R {
            bits: u8,
        }
        impl Pcin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin2R {
            bits: u8,
        }
        impl Pcin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin3R {
            bits: u8,
        }
        impl Pcin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin4R {
            bits: u8,
        }
        impl Pcin4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin5R {
            bits: u8,
        }
        impl Pcin5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin6R {
            bits: u8,
        }
        impl Pcin6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin7R {
            bits: u8,
        }
        impl Pcin7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin8R {
            bits: u8,
        }
        impl Pcin8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin9R {
            bits: u8,
        }
        impl Pcin9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin10R {
            bits: u8,
        }
        impl Pcin10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin11R {
            bits: u8,
        }
        impl Pcin11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin12R {
            bits: u8,
        }
        impl Pcin12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin13R {
            bits: u8,
        }
        impl Pcin13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin14R {
            bits: u8,
        }
        impl Pcin14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcin15R {
            bits: u8,
        }
        impl Pcin15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcin15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcin15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PCIN0" ]
            # [ inline ( always ) ]
            pub fn pcin0(&self) -> Pcin0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin0R { bits }
            }
            # [ doc = "Bit 1 - PCIN1" ]
            # [ inline ( always ) ]
            pub fn pcin1(&self) -> Pcin1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin1R { bits }
            }
            # [ doc = "Bit 2 - PCIN2" ]
            # [ inline ( always ) ]
            pub fn pcin2(&self) -> Pcin2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin2R { bits }
            }
            # [ doc = "Bit 3 - PCIN3" ]
            # [ inline ( always ) ]
            pub fn pcin3(&self) -> Pcin3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin3R { bits }
            }
            # [ doc = "Bit 4 - PCIN4" ]
            # [ inline ( always ) ]
            pub fn pcin4(&self) -> Pcin4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin4R { bits }
            }
            # [ doc = "Bit 5 - PCIN5" ]
            # [ inline ( always ) ]
            pub fn pcin5(&self) -> Pcin5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin5R { bits }
            }
            # [ doc = "Bit 6 - PCIN6" ]
            # [ inline ( always ) ]
            pub fn pcin6(&self) -> Pcin6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin6R { bits }
            }
            # [ doc = "Bit 7 - PCIN7" ]
            # [ inline ( always ) ]
            pub fn pcin7(&self) -> Pcin7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin7R { bits }
            }
            # [ doc = "Bit 8 - PCIN8" ]
            # [ inline ( always ) ]
            pub fn pcin8(&self) -> Pcin8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin8R { bits }
            }
            # [ doc = "Bit 9 - PCIN9" ]
            # [ inline ( always ) ]
            pub fn pcin9(&self) -> Pcin9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin9R { bits }
            }
            # [ doc = "Bit 10 - PCIN10" ]
            # [ inline ( always ) ]
            pub fn pcin10(&self) -> Pcin10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin10R { bits }
            }
            # [ doc = "Bit 11 - PCIN11" ]
            # [ inline ( always ) ]
            pub fn pcin11(&self) -> Pcin11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin11R { bits }
            }
            # [ doc = "Bit 12 - PCIN12" ]
            # [ inline ( always ) ]
            pub fn pcin12(&self) -> Pcin12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin12R { bits }
            }
            # [ doc = "Bit 13 - PCIN13" ]
            # [ inline ( always ) ]
            pub fn pcin13(&self) -> Pcin13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin13R { bits }
            }
            # [ doc = "Bit 14 - PCIN14" ]
            # [ inline ( always ) ]
            pub fn pcin14(&self) -> Pcin14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin14R { bits }
            }
            # [ doc = "Bit 15 - PCIN15" ]
            # [ inline ( always ) ]
            pub fn pcin15(&self) -> Pcin15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcin15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PCIN0" ]
            # [ inline ( always ) ]
            pub fn pcin0(&mut self) -> _Pcin0W {
                _Pcin0W { w: self }
            }
            # [ doc = "Bit 1 - PCIN1" ]
            # [ inline ( always ) ]
            pub fn pcin1(&mut self) -> _Pcin1W {
                _Pcin1W { w: self }
            }
            # [ doc = "Bit 2 - PCIN2" ]
            # [ inline ( always ) ]
            pub fn pcin2(&mut self) -> _Pcin2W {
                _Pcin2W { w: self }
            }
            # [ doc = "Bit 3 - PCIN3" ]
            # [ inline ( always ) ]
            pub fn pcin3(&mut self) -> _Pcin3W {
                _Pcin3W { w: self }
            }
            # [ doc = "Bit 4 - PCIN4" ]
            # [ inline ( always ) ]
            pub fn pcin4(&mut self) -> _Pcin4W {
                _Pcin4W { w: self }
            }
            # [ doc = "Bit 5 - PCIN5" ]
            # [ inline ( always ) ]
            pub fn pcin5(&mut self) -> _Pcin5W {
                _Pcin5W { w: self }
            }
            # [ doc = "Bit 6 - PCIN6" ]
            # [ inline ( always ) ]
            pub fn pcin6(&mut self) -> _Pcin6W {
                _Pcin6W { w: self }
            }
            # [ doc = "Bit 7 - PCIN7" ]
            # [ inline ( always ) ]
            pub fn pcin7(&mut self) -> _Pcin7W {
                _Pcin7W { w: self }
            }
            # [ doc = "Bit 8 - PCIN8" ]
            # [ inline ( always ) ]
            pub fn pcin8(&mut self) -> _Pcin8W {
                _Pcin8W { w: self }
            }
            # [ doc = "Bit 9 - PCIN9" ]
            # [ inline ( always ) ]
            pub fn pcin9(&mut self) -> _Pcin9W {
                _Pcin9W { w: self }
            }
            # [ doc = "Bit 10 - PCIN10" ]
            # [ inline ( always ) ]
            pub fn pcin10(&mut self) -> _Pcin10W {
                _Pcin10W { w: self }
            }
            # [ doc = "Bit 11 - PCIN11" ]
            # [ inline ( always ) ]
            pub fn pcin11(&mut self) -> _Pcin11W {
                _Pcin11W { w: self }
            }
            # [ doc = "Bit 12 - PCIN12" ]
            # [ inline ( always ) ]
            pub fn pcin12(&mut self) -> _Pcin12W {
                _Pcin12W { w: self }
            }
            # [ doc = "Bit 13 - PCIN13" ]
            # [ inline ( always ) ]
            pub fn pcin13(&mut self) -> _Pcin13W {
                _Pcin13W { w: self }
            }
            # [ doc = "Bit 14 - PCIN14" ]
            # [ inline ( always ) ]
            pub fn pcin14(&mut self) -> _Pcin14W {
                _Pcin14W { w: self }
            }
            # [ doc = "Bit 15 - PCIN15" ]
            # [ inline ( always ) ]
            pub fn pcin15(&mut self) -> _Pcin15W {
                _Pcin15W { w: self }
            }
        }
    }
    # [ doc = "Port C Output" ]
    pub struct Pcout {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port C Output" ]
    pub mod pcout {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pcout {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout0R {
            bits: u8,
        }
        impl Pcout0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout1R {
            bits: u8,
        }
        impl Pcout1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout2R {
            bits: u8,
        }
        impl Pcout2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout3R {
            bits: u8,
        }
        impl Pcout3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout4R {
            bits: u8,
        }
        impl Pcout4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout5R {
            bits: u8,
        }
        impl Pcout5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout6R {
            bits: u8,
        }
        impl Pcout6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout7R {
            bits: u8,
        }
        impl Pcout7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout8R {
            bits: u8,
        }
        impl Pcout8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout9R {
            bits: u8,
        }
        impl Pcout9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout10R {
            bits: u8,
        }
        impl Pcout10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout11R {
            bits: u8,
        }
        impl Pcout11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout12R {
            bits: u8,
        }
        impl Pcout12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout13R {
            bits: u8,
        }
        impl Pcout13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout14R {
            bits: u8,
        }
        impl Pcout14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcout15R {
            bits: u8,
        }
        impl Pcout15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcout15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcout15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PCOUT0" ]
            # [ inline ( always ) ]
            pub fn pcout0(&self) -> Pcout0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout0R { bits }
            }
            # [ doc = "Bit 1 - PCOUT1" ]
            # [ inline ( always ) ]
            pub fn pcout1(&self) -> Pcout1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout1R { bits }
            }
            # [ doc = "Bit 2 - PCOUT2" ]
            # [ inline ( always ) ]
            pub fn pcout2(&self) -> Pcout2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout2R { bits }
            }
            # [ doc = "Bit 3 - PCOUT3" ]
            # [ inline ( always ) ]
            pub fn pcout3(&self) -> Pcout3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout3R { bits }
            }
            # [ doc = "Bit 4 - PCOUT4" ]
            # [ inline ( always ) ]
            pub fn pcout4(&self) -> Pcout4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout4R { bits }
            }
            # [ doc = "Bit 5 - PCOUT5" ]
            # [ inline ( always ) ]
            pub fn pcout5(&self) -> Pcout5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout5R { bits }
            }
            # [ doc = "Bit 6 - PCOUT6" ]
            # [ inline ( always ) ]
            pub fn pcout6(&self) -> Pcout6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout6R { bits }
            }
            # [ doc = "Bit 7 - PCOUT7" ]
            # [ inline ( always ) ]
            pub fn pcout7(&self) -> Pcout7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout7R { bits }
            }
            # [ doc = "Bit 8 - PCOUT8" ]
            # [ inline ( always ) ]
            pub fn pcout8(&self) -> Pcout8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout8R { bits }
            }
            # [ doc = "Bit 9 - PCOUT9" ]
            # [ inline ( always ) ]
            pub fn pcout9(&self) -> Pcout9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout9R { bits }
            }
            # [ doc = "Bit 10 - PCOUT10" ]
            # [ inline ( always ) ]
            pub fn pcout10(&self) -> Pcout10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout10R { bits }
            }
            # [ doc = "Bit 11 - PCOUT11" ]
            # [ inline ( always ) ]
            pub fn pcout11(&self) -> Pcout11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout11R { bits }
            }
            # [ doc = "Bit 12 - PCOUT12" ]
            # [ inline ( always ) ]
            pub fn pcout12(&self) -> Pcout12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout12R { bits }
            }
            # [ doc = "Bit 13 - PCOUT13" ]
            # [ inline ( always ) ]
            pub fn pcout13(&self) -> Pcout13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout13R { bits }
            }
            # [ doc = "Bit 14 - PCOUT14" ]
            # [ inline ( always ) ]
            pub fn pcout14(&self) -> Pcout14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout14R { bits }
            }
            # [ doc = "Bit 15 - PCOUT15" ]
            # [ inline ( always ) ]
            pub fn pcout15(&self) -> Pcout15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcout15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PCOUT0" ]
            # [ inline ( always ) ]
            pub fn pcout0(&mut self) -> _Pcout0W {
                _Pcout0W { w: self }
            }
            # [ doc = "Bit 1 - PCOUT1" ]
            # [ inline ( always ) ]
            pub fn pcout1(&mut self) -> _Pcout1W {
                _Pcout1W { w: self }
            }
            # [ doc = "Bit 2 - PCOUT2" ]
            # [ inline ( always ) ]
            pub fn pcout2(&mut self) -> _Pcout2W {
                _Pcout2W { w: self }
            }
            # [ doc = "Bit 3 - PCOUT3" ]
            # [ inline ( always ) ]
            pub fn pcout3(&mut self) -> _Pcout3W {
                _Pcout3W { w: self }
            }
            # [ doc = "Bit 4 - PCOUT4" ]
            # [ inline ( always ) ]
            pub fn pcout4(&mut self) -> _Pcout4W {
                _Pcout4W { w: self }
            }
            # [ doc = "Bit 5 - PCOUT5" ]
            # [ inline ( always ) ]
            pub fn pcout5(&mut self) -> _Pcout5W {
                _Pcout5W { w: self }
            }
            # [ doc = "Bit 6 - PCOUT6" ]
            # [ inline ( always ) ]
            pub fn pcout6(&mut self) -> _Pcout6W {
                _Pcout6W { w: self }
            }
            # [ doc = "Bit 7 - PCOUT7" ]
            # [ inline ( always ) ]
            pub fn pcout7(&mut self) -> _Pcout7W {
                _Pcout7W { w: self }
            }
            # [ doc = "Bit 8 - PCOUT8" ]
            # [ inline ( always ) ]
            pub fn pcout8(&mut self) -> _Pcout8W {
                _Pcout8W { w: self }
            }
            # [ doc = "Bit 9 - PCOUT9" ]
            # [ inline ( always ) ]
            pub fn pcout9(&mut self) -> _Pcout9W {
                _Pcout9W { w: self }
            }
            # [ doc = "Bit 10 - PCOUT10" ]
            # [ inline ( always ) ]
            pub fn pcout10(&mut self) -> _Pcout10W {
                _Pcout10W { w: self }
            }
            # [ doc = "Bit 11 - PCOUT11" ]
            # [ inline ( always ) ]
            pub fn pcout11(&mut self) -> _Pcout11W {
                _Pcout11W { w: self }
            }
            # [ doc = "Bit 12 - PCOUT12" ]
            # [ inline ( always ) ]
            pub fn pcout12(&mut self) -> _Pcout12W {
                _Pcout12W { w: self }
            }
            # [ doc = "Bit 13 - PCOUT13" ]
            # [ inline ( always ) ]
            pub fn pcout13(&mut self) -> _Pcout13W {
                _Pcout13W { w: self }
            }
            # [ doc = "Bit 14 - PCOUT14" ]
            # [ inline ( always ) ]
            pub fn pcout14(&mut self) -> _Pcout14W {
                _Pcout14W { w: self }
            }
            # [ doc = "Bit 15 - PCOUT15" ]
            # [ inline ( always ) ]
            pub fn pcout15(&mut self) -> _Pcout15W {
                _Pcout15W { w: self }
            }
        }
    }
    # [ doc = "Port C Direction" ]
    pub struct Pcdir {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port C Direction" ]
    pub mod pcdir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pcdir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir0R {
            bits: u8,
        }
        impl Pcdir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir1R {
            bits: u8,
        }
        impl Pcdir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir2R {
            bits: u8,
        }
        impl Pcdir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir3R {
            bits: u8,
        }
        impl Pcdir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir4R {
            bits: u8,
        }
        impl Pcdir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir5R {
            bits: u8,
        }
        impl Pcdir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir6R {
            bits: u8,
        }
        impl Pcdir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir7R {
            bits: u8,
        }
        impl Pcdir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir8R {
            bits: u8,
        }
        impl Pcdir8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir9R {
            bits: u8,
        }
        impl Pcdir9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir10R {
            bits: u8,
        }
        impl Pcdir10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir11R {
            bits: u8,
        }
        impl Pcdir11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir12R {
            bits: u8,
        }
        impl Pcdir12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir13R {
            bits: u8,
        }
        impl Pcdir13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir14R {
            bits: u8,
        }
        impl Pcdir14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcdir15R {
            bits: u8,
        }
        impl Pcdir15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcdir15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcdir15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PCDIR0" ]
            # [ inline ( always ) ]
            pub fn pcdir0(&self) -> Pcdir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir0R { bits }
            }
            # [ doc = "Bit 1 - PCDIR1" ]
            # [ inline ( always ) ]
            pub fn pcdir1(&self) -> Pcdir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir1R { bits }
            }
            # [ doc = "Bit 2 - PCDIR2" ]
            # [ inline ( always ) ]
            pub fn pcdir2(&self) -> Pcdir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir2R { bits }
            }
            # [ doc = "Bit 3 - PCDIR3" ]
            # [ inline ( always ) ]
            pub fn pcdir3(&self) -> Pcdir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir3R { bits }
            }
            # [ doc = "Bit 4 - PCDIR4" ]
            # [ inline ( always ) ]
            pub fn pcdir4(&self) -> Pcdir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir4R { bits }
            }
            # [ doc = "Bit 5 - PCDIR5" ]
            # [ inline ( always ) ]
            pub fn pcdir5(&self) -> Pcdir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir5R { bits }
            }
            # [ doc = "Bit 6 - PCDIR6" ]
            # [ inline ( always ) ]
            pub fn pcdir6(&self) -> Pcdir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir6R { bits }
            }
            # [ doc = "Bit 7 - PCDIR7" ]
            # [ inline ( always ) ]
            pub fn pcdir7(&self) -> Pcdir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir7R { bits }
            }
            # [ doc = "Bit 8 - PCDIR8" ]
            # [ inline ( always ) ]
            pub fn pcdir8(&self) -> Pcdir8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir8R { bits }
            }
            # [ doc = "Bit 9 - PCDIR9" ]
            # [ inline ( always ) ]
            pub fn pcdir9(&self) -> Pcdir9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir9R { bits }
            }
            # [ doc = "Bit 10 - PCDIR10" ]
            # [ inline ( always ) ]
            pub fn pcdir10(&self) -> Pcdir10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir10R { bits }
            }
            # [ doc = "Bit 11 - PCDIR11" ]
            # [ inline ( always ) ]
            pub fn pcdir11(&self) -> Pcdir11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir11R { bits }
            }
            # [ doc = "Bit 12 - PCDIR12" ]
            # [ inline ( always ) ]
            pub fn pcdir12(&self) -> Pcdir12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir12R { bits }
            }
            # [ doc = "Bit 13 - PCDIR13" ]
            # [ inline ( always ) ]
            pub fn pcdir13(&self) -> Pcdir13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir13R { bits }
            }
            # [ doc = "Bit 14 - PCDIR14" ]
            # [ inline ( always ) ]
            pub fn pcdir14(&self) -> Pcdir14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir14R { bits }
            }
            # [ doc = "Bit 15 - PCDIR15" ]
            # [ inline ( always ) ]
            pub fn pcdir15(&self) -> Pcdir15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcdir15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PCDIR0" ]
            # [ inline ( always ) ]
            pub fn pcdir0(&mut self) -> _Pcdir0W {
                _Pcdir0W { w: self }
            }
            # [ doc = "Bit 1 - PCDIR1" ]
            # [ inline ( always ) ]
            pub fn pcdir1(&mut self) -> _Pcdir1W {
                _Pcdir1W { w: self }
            }
            # [ doc = "Bit 2 - PCDIR2" ]
            # [ inline ( always ) ]
            pub fn pcdir2(&mut self) -> _Pcdir2W {
                _Pcdir2W { w: self }
            }
            # [ doc = "Bit 3 - PCDIR3" ]
            # [ inline ( always ) ]
            pub fn pcdir3(&mut self) -> _Pcdir3W {
                _Pcdir3W { w: self }
            }
            # [ doc = "Bit 4 - PCDIR4" ]
            # [ inline ( always ) ]
            pub fn pcdir4(&mut self) -> _Pcdir4W {
                _Pcdir4W { w: self }
            }
            # [ doc = "Bit 5 - PCDIR5" ]
            # [ inline ( always ) ]
            pub fn pcdir5(&mut self) -> _Pcdir5W {
                _Pcdir5W { w: self }
            }
            # [ doc = "Bit 6 - PCDIR6" ]
            # [ inline ( always ) ]
            pub fn pcdir6(&mut self) -> _Pcdir6W {
                _Pcdir6W { w: self }
            }
            # [ doc = "Bit 7 - PCDIR7" ]
            # [ inline ( always ) ]
            pub fn pcdir7(&mut self) -> _Pcdir7W {
                _Pcdir7W { w: self }
            }
            # [ doc = "Bit 8 - PCDIR8" ]
            # [ inline ( always ) ]
            pub fn pcdir8(&mut self) -> _Pcdir8W {
                _Pcdir8W { w: self }
            }
            # [ doc = "Bit 9 - PCDIR9" ]
            # [ inline ( always ) ]
            pub fn pcdir9(&mut self) -> _Pcdir9W {
                _Pcdir9W { w: self }
            }
            # [ doc = "Bit 10 - PCDIR10" ]
            # [ inline ( always ) ]
            pub fn pcdir10(&mut self) -> _Pcdir10W {
                _Pcdir10W { w: self }
            }
            # [ doc = "Bit 11 - PCDIR11" ]
            # [ inline ( always ) ]
            pub fn pcdir11(&mut self) -> _Pcdir11W {
                _Pcdir11W { w: self }
            }
            # [ doc = "Bit 12 - PCDIR12" ]
            # [ inline ( always ) ]
            pub fn pcdir12(&mut self) -> _Pcdir12W {
                _Pcdir12W { w: self }
            }
            # [ doc = "Bit 13 - PCDIR13" ]
            # [ inline ( always ) ]
            pub fn pcdir13(&mut self) -> _Pcdir13W {
                _Pcdir13W { w: self }
            }
            # [ doc = "Bit 14 - PCDIR14" ]
            # [ inline ( always ) ]
            pub fn pcdir14(&mut self) -> _Pcdir14W {
                _Pcdir14W { w: self }
            }
            # [ doc = "Bit 15 - PCDIR15" ]
            # [ inline ( always ) ]
            pub fn pcdir15(&mut self) -> _Pcdir15W {
                _Pcdir15W { w: self }
            }
        }
    }
    # [ doc = "Port C Resistor Enable" ]
    pub struct Pcren {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port C Resistor Enable" ]
    pub mod pcren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pcren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren0R {
            bits: u8,
        }
        impl Pcren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren1R {
            bits: u8,
        }
        impl Pcren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren2R {
            bits: u8,
        }
        impl Pcren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren3R {
            bits: u8,
        }
        impl Pcren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren4R {
            bits: u8,
        }
        impl Pcren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren5R {
            bits: u8,
        }
        impl Pcren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren6R {
            bits: u8,
        }
        impl Pcren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren7R {
            bits: u8,
        }
        impl Pcren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren8R {
            bits: u8,
        }
        impl Pcren8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren9R {
            bits: u8,
        }
        impl Pcren9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren10R {
            bits: u8,
        }
        impl Pcren10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren11R {
            bits: u8,
        }
        impl Pcren11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren12R {
            bits: u8,
        }
        impl Pcren12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren13R {
            bits: u8,
        }
        impl Pcren13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren14R {
            bits: u8,
        }
        impl Pcren14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcren15R {
            bits: u8,
        }
        impl Pcren15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcren15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcren15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PCREN0" ]
            # [ inline ( always ) ]
            pub fn pcren0(&self) -> Pcren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren0R { bits }
            }
            # [ doc = "Bit 1 - PCREN1" ]
            # [ inline ( always ) ]
            pub fn pcren1(&self) -> Pcren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren1R { bits }
            }
            # [ doc = "Bit 2 - PCREN2" ]
            # [ inline ( always ) ]
            pub fn pcren2(&self) -> Pcren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren2R { bits }
            }
            # [ doc = "Bit 3 - PCREN3" ]
            # [ inline ( always ) ]
            pub fn pcren3(&self) -> Pcren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren3R { bits }
            }
            # [ doc = "Bit 4 - PCREN4" ]
            # [ inline ( always ) ]
            pub fn pcren4(&self) -> Pcren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren4R { bits }
            }
            # [ doc = "Bit 5 - PCREN5" ]
            # [ inline ( always ) ]
            pub fn pcren5(&self) -> Pcren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren5R { bits }
            }
            # [ doc = "Bit 6 - PCREN6" ]
            # [ inline ( always ) ]
            pub fn pcren6(&self) -> Pcren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren6R { bits }
            }
            # [ doc = "Bit 7 - PCREN7" ]
            # [ inline ( always ) ]
            pub fn pcren7(&self) -> Pcren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren7R { bits }
            }
            # [ doc = "Bit 8 - PCREN8" ]
            # [ inline ( always ) ]
            pub fn pcren8(&self) -> Pcren8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren8R { bits }
            }
            # [ doc = "Bit 9 - PCREN9" ]
            # [ inline ( always ) ]
            pub fn pcren9(&self) -> Pcren9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren9R { bits }
            }
            # [ doc = "Bit 10 - PCREN10" ]
            # [ inline ( always ) ]
            pub fn pcren10(&self) -> Pcren10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren10R { bits }
            }
            # [ doc = "Bit 11 - PCREN11" ]
            # [ inline ( always ) ]
            pub fn pcren11(&self) -> Pcren11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren11R { bits }
            }
            # [ doc = "Bit 12 - PCREN12" ]
            # [ inline ( always ) ]
            pub fn pcren12(&self) -> Pcren12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren12R { bits }
            }
            # [ doc = "Bit 13 - PCREN13" ]
            # [ inline ( always ) ]
            pub fn pcren13(&self) -> Pcren13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren13R { bits }
            }
            # [ doc = "Bit 14 - PCREN14" ]
            # [ inline ( always ) ]
            pub fn pcren14(&self) -> Pcren14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren14R { bits }
            }
            # [ doc = "Bit 15 - PCREN15" ]
            # [ inline ( always ) ]
            pub fn pcren15(&self) -> Pcren15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcren15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PCREN0" ]
            # [ inline ( always ) ]
            pub fn pcren0(&mut self) -> _Pcren0W {
                _Pcren0W { w: self }
            }
            # [ doc = "Bit 1 - PCREN1" ]
            # [ inline ( always ) ]
            pub fn pcren1(&mut self) -> _Pcren1W {
                _Pcren1W { w: self }
            }
            # [ doc = "Bit 2 - PCREN2" ]
            # [ inline ( always ) ]
            pub fn pcren2(&mut self) -> _Pcren2W {
                _Pcren2W { w: self }
            }
            # [ doc = "Bit 3 - PCREN3" ]
            # [ inline ( always ) ]
            pub fn pcren3(&mut self) -> _Pcren3W {
                _Pcren3W { w: self }
            }
            # [ doc = "Bit 4 - PCREN4" ]
            # [ inline ( always ) ]
            pub fn pcren4(&mut self) -> _Pcren4W {
                _Pcren4W { w: self }
            }
            # [ doc = "Bit 5 - PCREN5" ]
            # [ inline ( always ) ]
            pub fn pcren5(&mut self) -> _Pcren5W {
                _Pcren5W { w: self }
            }
            # [ doc = "Bit 6 - PCREN6" ]
            # [ inline ( always ) ]
            pub fn pcren6(&mut self) -> _Pcren6W {
                _Pcren6W { w: self }
            }
            # [ doc = "Bit 7 - PCREN7" ]
            # [ inline ( always ) ]
            pub fn pcren7(&mut self) -> _Pcren7W {
                _Pcren7W { w: self }
            }
            # [ doc = "Bit 8 - PCREN8" ]
            # [ inline ( always ) ]
            pub fn pcren8(&mut self) -> _Pcren8W {
                _Pcren8W { w: self }
            }
            # [ doc = "Bit 9 - PCREN9" ]
            # [ inline ( always ) ]
            pub fn pcren9(&mut self) -> _Pcren9W {
                _Pcren9W { w: self }
            }
            # [ doc = "Bit 10 - PCREN10" ]
            # [ inline ( always ) ]
            pub fn pcren10(&mut self) -> _Pcren10W {
                _Pcren10W { w: self }
            }
            # [ doc = "Bit 11 - PCREN11" ]
            # [ inline ( always ) ]
            pub fn pcren11(&mut self) -> _Pcren11W {
                _Pcren11W { w: self }
            }
            # [ doc = "Bit 12 - PCREN12" ]
            # [ inline ( always ) ]
            pub fn pcren12(&mut self) -> _Pcren12W {
                _Pcren12W { w: self }
            }
            # [ doc = "Bit 13 - PCREN13" ]
            # [ inline ( always ) ]
            pub fn pcren13(&mut self) -> _Pcren13W {
                _Pcren13W { w: self }
            }
            # [ doc = "Bit 14 - PCREN14" ]
            # [ inline ( always ) ]
            pub fn pcren14(&mut self) -> _Pcren14W {
                _Pcren14W { w: self }
            }
            # [ doc = "Bit 15 - PCREN15" ]
            # [ inline ( always ) ]
            pub fn pcren15(&mut self) -> _Pcren15W {
                _Pcren15W { w: self }
            }
        }
    }
    # [ doc = "Port C Drive Strenght" ]
    pub struct Pcds {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port C Drive Strenght" ]
    pub mod pcds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pcds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds0R {
            bits: u8,
        }
        impl Pcds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds1R {
            bits: u8,
        }
        impl Pcds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds2R {
            bits: u8,
        }
        impl Pcds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds3R {
            bits: u8,
        }
        impl Pcds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds4R {
            bits: u8,
        }
        impl Pcds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds5R {
            bits: u8,
        }
        impl Pcds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds6R {
            bits: u8,
        }
        impl Pcds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds7R {
            bits: u8,
        }
        impl Pcds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds8R {
            bits: u8,
        }
        impl Pcds8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds9R {
            bits: u8,
        }
        impl Pcds9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds10R {
            bits: u8,
        }
        impl Pcds10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds11R {
            bits: u8,
        }
        impl Pcds11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds12R {
            bits: u8,
        }
        impl Pcds12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds13R {
            bits: u8,
        }
        impl Pcds13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds14R {
            bits: u8,
        }
        impl Pcds14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcds15R {
            bits: u8,
        }
        impl Pcds15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcds15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcds15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PCDS0" ]
            # [ inline ( always ) ]
            pub fn pcds0(&self) -> Pcds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds0R { bits }
            }
            # [ doc = "Bit 1 - PCDS1" ]
            # [ inline ( always ) ]
            pub fn pcds1(&self) -> Pcds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds1R { bits }
            }
            # [ doc = "Bit 2 - PCDS2" ]
            # [ inline ( always ) ]
            pub fn pcds2(&self) -> Pcds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds2R { bits }
            }
            # [ doc = "Bit 3 - PCDS3" ]
            # [ inline ( always ) ]
            pub fn pcds3(&self) -> Pcds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds3R { bits }
            }
            # [ doc = "Bit 4 - PCDS4" ]
            # [ inline ( always ) ]
            pub fn pcds4(&self) -> Pcds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds4R { bits }
            }
            # [ doc = "Bit 5 - PCDS5" ]
            # [ inline ( always ) ]
            pub fn pcds5(&self) -> Pcds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds5R { bits }
            }
            # [ doc = "Bit 6 - PCDS6" ]
            # [ inline ( always ) ]
            pub fn pcds6(&self) -> Pcds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds6R { bits }
            }
            # [ doc = "Bit 7 - PCDS7" ]
            # [ inline ( always ) ]
            pub fn pcds7(&self) -> Pcds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds7R { bits }
            }
            # [ doc = "Bit 8 - PCDS8" ]
            # [ inline ( always ) ]
            pub fn pcds8(&self) -> Pcds8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds8R { bits }
            }
            # [ doc = "Bit 9 - PCDS9" ]
            # [ inline ( always ) ]
            pub fn pcds9(&self) -> Pcds9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds9R { bits }
            }
            # [ doc = "Bit 10 - PCDS10" ]
            # [ inline ( always ) ]
            pub fn pcds10(&self) -> Pcds10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds10R { bits }
            }
            # [ doc = "Bit 11 - PCDS11" ]
            # [ inline ( always ) ]
            pub fn pcds11(&self) -> Pcds11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds11R { bits }
            }
            # [ doc = "Bit 12 - PCDS12" ]
            # [ inline ( always ) ]
            pub fn pcds12(&self) -> Pcds12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds12R { bits }
            }
            # [ doc = "Bit 13 - PCDS13" ]
            # [ inline ( always ) ]
            pub fn pcds13(&self) -> Pcds13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds13R { bits }
            }
            # [ doc = "Bit 14 - PCDS14" ]
            # [ inline ( always ) ]
            pub fn pcds14(&self) -> Pcds14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds14R { bits }
            }
            # [ doc = "Bit 15 - PCDS15" ]
            # [ inline ( always ) ]
            pub fn pcds15(&self) -> Pcds15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcds15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PCDS0" ]
            # [ inline ( always ) ]
            pub fn pcds0(&mut self) -> _Pcds0W {
                _Pcds0W { w: self }
            }
            # [ doc = "Bit 1 - PCDS1" ]
            # [ inline ( always ) ]
            pub fn pcds1(&mut self) -> _Pcds1W {
                _Pcds1W { w: self }
            }
            # [ doc = "Bit 2 - PCDS2" ]
            # [ inline ( always ) ]
            pub fn pcds2(&mut self) -> _Pcds2W {
                _Pcds2W { w: self }
            }
            # [ doc = "Bit 3 - PCDS3" ]
            # [ inline ( always ) ]
            pub fn pcds3(&mut self) -> _Pcds3W {
                _Pcds3W { w: self }
            }
            # [ doc = "Bit 4 - PCDS4" ]
            # [ inline ( always ) ]
            pub fn pcds4(&mut self) -> _Pcds4W {
                _Pcds4W { w: self }
            }
            # [ doc = "Bit 5 - PCDS5" ]
            # [ inline ( always ) ]
            pub fn pcds5(&mut self) -> _Pcds5W {
                _Pcds5W { w: self }
            }
            # [ doc = "Bit 6 - PCDS6" ]
            # [ inline ( always ) ]
            pub fn pcds6(&mut self) -> _Pcds6W {
                _Pcds6W { w: self }
            }
            # [ doc = "Bit 7 - PCDS7" ]
            # [ inline ( always ) ]
            pub fn pcds7(&mut self) -> _Pcds7W {
                _Pcds7W { w: self }
            }
            # [ doc = "Bit 8 - PCDS8" ]
            # [ inline ( always ) ]
            pub fn pcds8(&mut self) -> _Pcds8W {
                _Pcds8W { w: self }
            }
            # [ doc = "Bit 9 - PCDS9" ]
            # [ inline ( always ) ]
            pub fn pcds9(&mut self) -> _Pcds9W {
                _Pcds9W { w: self }
            }
            # [ doc = "Bit 10 - PCDS10" ]
            # [ inline ( always ) ]
            pub fn pcds10(&mut self) -> _Pcds10W {
                _Pcds10W { w: self }
            }
            # [ doc = "Bit 11 - PCDS11" ]
            # [ inline ( always ) ]
            pub fn pcds11(&mut self) -> _Pcds11W {
                _Pcds11W { w: self }
            }
            # [ doc = "Bit 12 - PCDS12" ]
            # [ inline ( always ) ]
            pub fn pcds12(&mut self) -> _Pcds12W {
                _Pcds12W { w: self }
            }
            # [ doc = "Bit 13 - PCDS13" ]
            # [ inline ( always ) ]
            pub fn pcds13(&mut self) -> _Pcds13W {
                _Pcds13W { w: self }
            }
            # [ doc = "Bit 14 - PCDS14" ]
            # [ inline ( always ) ]
            pub fn pcds14(&mut self) -> _Pcds14W {
                _Pcds14W { w: self }
            }
            # [ doc = "Bit 15 - PCDS15" ]
            # [ inline ( always ) ]
            pub fn pcds15(&mut self) -> _Pcds15W {
                _Pcds15W { w: self }
            }
        }
    }
    # [ doc = "Port C Selection" ]
    pub struct Pcsel {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port C Selection" ]
    pub mod pcsel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pcsel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel0R {
            bits: u8,
        }
        impl Pcsel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel1R {
            bits: u8,
        }
        impl Pcsel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel2R {
            bits: u8,
        }
        impl Pcsel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel3R {
            bits: u8,
        }
        impl Pcsel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel4R {
            bits: u8,
        }
        impl Pcsel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel5R {
            bits: u8,
        }
        impl Pcsel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel6R {
            bits: u8,
        }
        impl Pcsel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel7R {
            bits: u8,
        }
        impl Pcsel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel8R {
            bits: u8,
        }
        impl Pcsel8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel9R {
            bits: u8,
        }
        impl Pcsel9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel10R {
            bits: u8,
        }
        impl Pcsel10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel11R {
            bits: u8,
        }
        impl Pcsel11R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel12R {
            bits: u8,
        }
        impl Pcsel12R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel13R {
            bits: u8,
        }
        impl Pcsel13R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel14R {
            bits: u8,
        }
        impl Pcsel14R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pcsel15R {
            bits: u8,
        }
        impl Pcsel15R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel11W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel12W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel13W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel14W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pcsel15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pcsel15W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PCSEL0" ]
            # [ inline ( always ) ]
            pub fn pcsel0(&self) -> Pcsel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel0R { bits }
            }
            # [ doc = "Bit 1 - PCSEL1" ]
            # [ inline ( always ) ]
            pub fn pcsel1(&self) -> Pcsel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel1R { bits }
            }
            # [ doc = "Bit 2 - PCSEL2" ]
            # [ inline ( always ) ]
            pub fn pcsel2(&self) -> Pcsel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel2R { bits }
            }
            # [ doc = "Bit 3 - PCSEL3" ]
            # [ inline ( always ) ]
            pub fn pcsel3(&self) -> Pcsel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel3R { bits }
            }
            # [ doc = "Bit 4 - PCSEL4" ]
            # [ inline ( always ) ]
            pub fn pcsel4(&self) -> Pcsel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel4R { bits }
            }
            # [ doc = "Bit 5 - PCSEL5" ]
            # [ inline ( always ) ]
            pub fn pcsel5(&self) -> Pcsel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel5R { bits }
            }
            # [ doc = "Bit 6 - PCSEL6" ]
            # [ inline ( always ) ]
            pub fn pcsel6(&self) -> Pcsel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel6R { bits }
            }
            # [ doc = "Bit 7 - PCSEL7" ]
            # [ inline ( always ) ]
            pub fn pcsel7(&self) -> Pcsel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel7R { bits }
            }
            # [ doc = "Bit 8 - PCSEL8" ]
            # [ inline ( always ) ]
            pub fn pcsel8(&self) -> Pcsel8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel8R { bits }
            }
            # [ doc = "Bit 9 - PCSEL9" ]
            # [ inline ( always ) ]
            pub fn pcsel9(&self) -> Pcsel9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel9R { bits }
            }
            # [ doc = "Bit 10 - PCSEL10" ]
            # [ inline ( always ) ]
            pub fn pcsel10(&self) -> Pcsel10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel10R { bits }
            }
            # [ doc = "Bit 11 - PCSEL11" ]
            # [ inline ( always ) ]
            pub fn pcsel11(&self) -> Pcsel11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel11R { bits }
            }
            # [ doc = "Bit 12 - PCSEL12" ]
            # [ inline ( always ) ]
            pub fn pcsel12(&self) -> Pcsel12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel12R { bits }
            }
            # [ doc = "Bit 13 - PCSEL13" ]
            # [ inline ( always ) ]
            pub fn pcsel13(&self) -> Pcsel13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel13R { bits }
            }
            # [ doc = "Bit 14 - PCSEL14" ]
            # [ inline ( always ) ]
            pub fn pcsel14(&self) -> Pcsel14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel14R { bits }
            }
            # [ doc = "Bit 15 - PCSEL15" ]
            # [ inline ( always ) ]
            pub fn pcsel15(&self) -> Pcsel15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pcsel15R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PCSEL0" ]
            # [ inline ( always ) ]
            pub fn pcsel0(&mut self) -> _Pcsel0W {
                _Pcsel0W { w: self }
            }
            # [ doc = "Bit 1 - PCSEL1" ]
            # [ inline ( always ) ]
            pub fn pcsel1(&mut self) -> _Pcsel1W {
                _Pcsel1W { w: self }
            }
            # [ doc = "Bit 2 - PCSEL2" ]
            # [ inline ( always ) ]
            pub fn pcsel2(&mut self) -> _Pcsel2W {
                _Pcsel2W { w: self }
            }
            # [ doc = "Bit 3 - PCSEL3" ]
            # [ inline ( always ) ]
            pub fn pcsel3(&mut self) -> _Pcsel3W {
                _Pcsel3W { w: self }
            }
            # [ doc = "Bit 4 - PCSEL4" ]
            # [ inline ( always ) ]
            pub fn pcsel4(&mut self) -> _Pcsel4W {
                _Pcsel4W { w: self }
            }
            # [ doc = "Bit 5 - PCSEL5" ]
            # [ inline ( always ) ]
            pub fn pcsel5(&mut self) -> _Pcsel5W {
                _Pcsel5W { w: self }
            }
            # [ doc = "Bit 6 - PCSEL6" ]
            # [ inline ( always ) ]
            pub fn pcsel6(&mut self) -> _Pcsel6W {
                _Pcsel6W { w: self }
            }
            # [ doc = "Bit 7 - PCSEL7" ]
            # [ inline ( always ) ]
            pub fn pcsel7(&mut self) -> _Pcsel7W {
                _Pcsel7W { w: self }
            }
            # [ doc = "Bit 8 - PCSEL8" ]
            # [ inline ( always ) ]
            pub fn pcsel8(&mut self) -> _Pcsel8W {
                _Pcsel8W { w: self }
            }
            # [ doc = "Bit 9 - PCSEL9" ]
            # [ inline ( always ) ]
            pub fn pcsel9(&mut self) -> _Pcsel9W {
                _Pcsel9W { w: self }
            }
            # [ doc = "Bit 10 - PCSEL10" ]
            # [ inline ( always ) ]
            pub fn pcsel10(&mut self) -> _Pcsel10W {
                _Pcsel10W { w: self }
            }
            # [ doc = "Bit 11 - PCSEL11" ]
            # [ inline ( always ) ]
            pub fn pcsel11(&mut self) -> _Pcsel11W {
                _Pcsel11W { w: self }
            }
            # [ doc = "Bit 12 - PCSEL12" ]
            # [ inline ( always ) ]
            pub fn pcsel12(&mut self) -> _Pcsel12W {
                _Pcsel12W { w: self }
            }
            # [ doc = "Bit 13 - PCSEL13" ]
            # [ inline ( always ) ]
            pub fn pcsel13(&mut self) -> _Pcsel13W {
                _Pcsel13W { w: self }
            }
            # [ doc = "Bit 14 - PCSEL14" ]
            # [ inline ( always ) ]
            pub fn pcsel14(&mut self) -> _Pcsel14W {
                _Pcsel14W { w: self }
            }
            # [ doc = "Bit 15 - PCSEL15" ]
            # [ inline ( always ) ]
            pub fn pcsel15(&mut self) -> _Pcsel15W {
                _Pcsel15W { w: self }
            }
        }
    }
}
# [ doc = "Port C" ]
pub struct PortC {
    register_block: port_c::RegisterBlock,
}
impl Deref for PortC {
    type Target = port_c::RegisterBlock;
    fn deref(&self) -> &port_c::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port 5" ]
pub const PORT_5: Peripheral<Port5> = unsafe { Peripheral::new(0) };
# [ doc = "Port 5" ]
pub mod port_5 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 576usize],
        # [ doc = "0x240 - Port 5 Input" ]
        pub p5in: P5in,
        _reserved1: [u8; 1usize],
        # [ doc = "0x242 - Port 5 Output" ]
        pub p5out: P5out,
        _reserved2: [u8; 1usize],
        # [ doc = "0x244 - Port 5 Direction" ]
        pub p5dir: P5dir,
        _reserved3: [u8; 1usize],
        # [ doc = "0x246 - Port 5 Resistor Enable" ]
        pub p5ren: P5ren,
        _reserved4: [u8; 1usize],
        # [ doc = "0x248 - Port 5 Drive Strenght" ]
        pub p5ds: P5ds,
        _reserved5: [u8; 1usize],
        # [ doc = "0x24a - Port 5 Selection" ]
        pub p5sel: P5sel,
    }
    # [ doc = "Port 5 Input" ]
    pub struct P5in {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 5 Input" ]
    pub mod p5in {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P5in {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in0R {
            bits: u8,
        }
        impl P5in0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in1R {
            bits: u8,
        }
        impl P5in1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in2R {
            bits: u8,
        }
        impl P5in2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in3R {
            bits: u8,
        }
        impl P5in3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in4R {
            bits: u8,
        }
        impl P5in4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in5R {
            bits: u8,
        }
        impl P5in5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in6R {
            bits: u8,
        }
        impl P5in6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5in7R {
            bits: u8,
        }
        impl P5in7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5in7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5in7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P5IN0" ]
            # [ inline ( always ) ]
            pub fn p5in0(&self) -> P5in0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in0R { bits }
            }
            # [ doc = "Bit 1 - P5IN1" ]
            # [ inline ( always ) ]
            pub fn p5in1(&self) -> P5in1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in1R { bits }
            }
            # [ doc = "Bit 2 - P5IN2" ]
            # [ inline ( always ) ]
            pub fn p5in2(&self) -> P5in2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in2R { bits }
            }
            # [ doc = "Bit 3 - P5IN3" ]
            # [ inline ( always ) ]
            pub fn p5in3(&self) -> P5in3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in3R { bits }
            }
            # [ doc = "Bit 4 - P5IN4" ]
            # [ inline ( always ) ]
            pub fn p5in4(&self) -> P5in4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in4R { bits }
            }
            # [ doc = "Bit 5 - P5IN5" ]
            # [ inline ( always ) ]
            pub fn p5in5(&self) -> P5in5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in5R { bits }
            }
            # [ doc = "Bit 6 - P5IN6" ]
            # [ inline ( always ) ]
            pub fn p5in6(&self) -> P5in6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in6R { bits }
            }
            # [ doc = "Bit 7 - P5IN7" ]
            # [ inline ( always ) ]
            pub fn p5in7(&self) -> P5in7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5in7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P5IN0" ]
            # [ inline ( always ) ]
            pub fn p5in0(&mut self) -> _P5in0W {
                _P5in0W { w: self }
            }
            # [ doc = "Bit 1 - P5IN1" ]
            # [ inline ( always ) ]
            pub fn p5in1(&mut self) -> _P5in1W {
                _P5in1W { w: self }
            }
            # [ doc = "Bit 2 - P5IN2" ]
            # [ inline ( always ) ]
            pub fn p5in2(&mut self) -> _P5in2W {
                _P5in2W { w: self }
            }
            # [ doc = "Bit 3 - P5IN3" ]
            # [ inline ( always ) ]
            pub fn p5in3(&mut self) -> _P5in3W {
                _P5in3W { w: self }
            }
            # [ doc = "Bit 4 - P5IN4" ]
            # [ inline ( always ) ]
            pub fn p5in4(&mut self) -> _P5in4W {
                _P5in4W { w: self }
            }
            # [ doc = "Bit 5 - P5IN5" ]
            # [ inline ( always ) ]
            pub fn p5in5(&mut self) -> _P5in5W {
                _P5in5W { w: self }
            }
            # [ doc = "Bit 6 - P5IN6" ]
            # [ inline ( always ) ]
            pub fn p5in6(&mut self) -> _P5in6W {
                _P5in6W { w: self }
            }
            # [ doc = "Bit 7 - P5IN7" ]
            # [ inline ( always ) ]
            pub fn p5in7(&mut self) -> _P5in7W {
                _P5in7W { w: self }
            }
        }
    }
    # [ doc = "Port 5 Output" ]
    pub struct P5out {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 5 Output" ]
    pub mod p5out {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P5out {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out0R {
            bits: u8,
        }
        impl P5out0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out1R {
            bits: u8,
        }
        impl P5out1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out2R {
            bits: u8,
        }
        impl P5out2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out3R {
            bits: u8,
        }
        impl P5out3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out4R {
            bits: u8,
        }
        impl P5out4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out5R {
            bits: u8,
        }
        impl P5out5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out6R {
            bits: u8,
        }
        impl P5out6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5out7R {
            bits: u8,
        }
        impl P5out7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5out7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5out7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P5OUT0" ]
            # [ inline ( always ) ]
            pub fn p5out0(&self) -> P5out0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out0R { bits }
            }
            # [ doc = "Bit 1 - P5OUT1" ]
            # [ inline ( always ) ]
            pub fn p5out1(&self) -> P5out1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out1R { bits }
            }
            # [ doc = "Bit 2 - P5OUT2" ]
            # [ inline ( always ) ]
            pub fn p5out2(&self) -> P5out2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out2R { bits }
            }
            # [ doc = "Bit 3 - P5OUT3" ]
            # [ inline ( always ) ]
            pub fn p5out3(&self) -> P5out3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out3R { bits }
            }
            # [ doc = "Bit 4 - P5OUT4" ]
            # [ inline ( always ) ]
            pub fn p5out4(&self) -> P5out4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out4R { bits }
            }
            # [ doc = "Bit 5 - P5OUT5" ]
            # [ inline ( always ) ]
            pub fn p5out5(&self) -> P5out5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out5R { bits }
            }
            # [ doc = "Bit 6 - P5OUT6" ]
            # [ inline ( always ) ]
            pub fn p5out6(&self) -> P5out6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out6R { bits }
            }
            # [ doc = "Bit 7 - P5OUT7" ]
            # [ inline ( always ) ]
            pub fn p5out7(&self) -> P5out7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5out7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P5OUT0" ]
            # [ inline ( always ) ]
            pub fn p5out0(&mut self) -> _P5out0W {
                _P5out0W { w: self }
            }
            # [ doc = "Bit 1 - P5OUT1" ]
            # [ inline ( always ) ]
            pub fn p5out1(&mut self) -> _P5out1W {
                _P5out1W { w: self }
            }
            # [ doc = "Bit 2 - P5OUT2" ]
            # [ inline ( always ) ]
            pub fn p5out2(&mut self) -> _P5out2W {
                _P5out2W { w: self }
            }
            # [ doc = "Bit 3 - P5OUT3" ]
            # [ inline ( always ) ]
            pub fn p5out3(&mut self) -> _P5out3W {
                _P5out3W { w: self }
            }
            # [ doc = "Bit 4 - P5OUT4" ]
            # [ inline ( always ) ]
            pub fn p5out4(&mut self) -> _P5out4W {
                _P5out4W { w: self }
            }
            # [ doc = "Bit 5 - P5OUT5" ]
            # [ inline ( always ) ]
            pub fn p5out5(&mut self) -> _P5out5W {
                _P5out5W { w: self }
            }
            # [ doc = "Bit 6 - P5OUT6" ]
            # [ inline ( always ) ]
            pub fn p5out6(&mut self) -> _P5out6W {
                _P5out6W { w: self }
            }
            # [ doc = "Bit 7 - P5OUT7" ]
            # [ inline ( always ) ]
            pub fn p5out7(&mut self) -> _P5out7W {
                _P5out7W { w: self }
            }
        }
    }
    # [ doc = "Port 5 Direction" ]
    pub struct P5dir {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 5 Direction" ]
    pub mod p5dir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P5dir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir0R {
            bits: u8,
        }
        impl P5dir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir1R {
            bits: u8,
        }
        impl P5dir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir2R {
            bits: u8,
        }
        impl P5dir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir3R {
            bits: u8,
        }
        impl P5dir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir4R {
            bits: u8,
        }
        impl P5dir4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir5R {
            bits: u8,
        }
        impl P5dir5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir6R {
            bits: u8,
        }
        impl P5dir6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5dir7R {
            bits: u8,
        }
        impl P5dir7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5dir7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5dir7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P5DIR0" ]
            # [ inline ( always ) ]
            pub fn p5dir0(&self) -> P5dir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir0R { bits }
            }
            # [ doc = "Bit 1 - P5DIR1" ]
            # [ inline ( always ) ]
            pub fn p5dir1(&self) -> P5dir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir1R { bits }
            }
            # [ doc = "Bit 2 - P5DIR2" ]
            # [ inline ( always ) ]
            pub fn p5dir2(&self) -> P5dir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir2R { bits }
            }
            # [ doc = "Bit 3 - P5DIR3" ]
            # [ inline ( always ) ]
            pub fn p5dir3(&self) -> P5dir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir3R { bits }
            }
            # [ doc = "Bit 4 - P5DIR4" ]
            # [ inline ( always ) ]
            pub fn p5dir4(&self) -> P5dir4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir4R { bits }
            }
            # [ doc = "Bit 5 - P5DIR5" ]
            # [ inline ( always ) ]
            pub fn p5dir5(&self) -> P5dir5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir5R { bits }
            }
            # [ doc = "Bit 6 - P5DIR6" ]
            # [ inline ( always ) ]
            pub fn p5dir6(&self) -> P5dir6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir6R { bits }
            }
            # [ doc = "Bit 7 - P5DIR7" ]
            # [ inline ( always ) ]
            pub fn p5dir7(&self) -> P5dir7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5dir7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P5DIR0" ]
            # [ inline ( always ) ]
            pub fn p5dir0(&mut self) -> _P5dir0W {
                _P5dir0W { w: self }
            }
            # [ doc = "Bit 1 - P5DIR1" ]
            # [ inline ( always ) ]
            pub fn p5dir1(&mut self) -> _P5dir1W {
                _P5dir1W { w: self }
            }
            # [ doc = "Bit 2 - P5DIR2" ]
            # [ inline ( always ) ]
            pub fn p5dir2(&mut self) -> _P5dir2W {
                _P5dir2W { w: self }
            }
            # [ doc = "Bit 3 - P5DIR3" ]
            # [ inline ( always ) ]
            pub fn p5dir3(&mut self) -> _P5dir3W {
                _P5dir3W { w: self }
            }
            # [ doc = "Bit 4 - P5DIR4" ]
            # [ inline ( always ) ]
            pub fn p5dir4(&mut self) -> _P5dir4W {
                _P5dir4W { w: self }
            }
            # [ doc = "Bit 5 - P5DIR5" ]
            # [ inline ( always ) ]
            pub fn p5dir5(&mut self) -> _P5dir5W {
                _P5dir5W { w: self }
            }
            # [ doc = "Bit 6 - P5DIR6" ]
            # [ inline ( always ) ]
            pub fn p5dir6(&mut self) -> _P5dir6W {
                _P5dir6W { w: self }
            }
            # [ doc = "Bit 7 - P5DIR7" ]
            # [ inline ( always ) ]
            pub fn p5dir7(&mut self) -> _P5dir7W {
                _P5dir7W { w: self }
            }
        }
    }
    # [ doc = "Port 5 Resistor Enable" ]
    pub struct P5ren {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 5 Resistor Enable" ]
    pub mod p5ren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P5ren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren0R {
            bits: u8,
        }
        impl P5ren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren1R {
            bits: u8,
        }
        impl P5ren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren2R {
            bits: u8,
        }
        impl P5ren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren3R {
            bits: u8,
        }
        impl P5ren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren4R {
            bits: u8,
        }
        impl P5ren4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren5R {
            bits: u8,
        }
        impl P5ren5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren6R {
            bits: u8,
        }
        impl P5ren6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ren7R {
            bits: u8,
        }
        impl P5ren7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ren7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ren7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P5REN0" ]
            # [ inline ( always ) ]
            pub fn p5ren0(&self) -> P5ren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren0R { bits }
            }
            # [ doc = "Bit 1 - P5REN1" ]
            # [ inline ( always ) ]
            pub fn p5ren1(&self) -> P5ren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren1R { bits }
            }
            # [ doc = "Bit 2 - P5REN2" ]
            # [ inline ( always ) ]
            pub fn p5ren2(&self) -> P5ren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren2R { bits }
            }
            # [ doc = "Bit 3 - P5REN3" ]
            # [ inline ( always ) ]
            pub fn p5ren3(&self) -> P5ren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren3R { bits }
            }
            # [ doc = "Bit 4 - P5REN4" ]
            # [ inline ( always ) ]
            pub fn p5ren4(&self) -> P5ren4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren4R { bits }
            }
            # [ doc = "Bit 5 - P5REN5" ]
            # [ inline ( always ) ]
            pub fn p5ren5(&self) -> P5ren5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren5R { bits }
            }
            # [ doc = "Bit 6 - P5REN6" ]
            # [ inline ( always ) ]
            pub fn p5ren6(&self) -> P5ren6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren6R { bits }
            }
            # [ doc = "Bit 7 - P5REN7" ]
            # [ inline ( always ) ]
            pub fn p5ren7(&self) -> P5ren7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ren7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P5REN0" ]
            # [ inline ( always ) ]
            pub fn p5ren0(&mut self) -> _P5ren0W {
                _P5ren0W { w: self }
            }
            # [ doc = "Bit 1 - P5REN1" ]
            # [ inline ( always ) ]
            pub fn p5ren1(&mut self) -> _P5ren1W {
                _P5ren1W { w: self }
            }
            # [ doc = "Bit 2 - P5REN2" ]
            # [ inline ( always ) ]
            pub fn p5ren2(&mut self) -> _P5ren2W {
                _P5ren2W { w: self }
            }
            # [ doc = "Bit 3 - P5REN3" ]
            # [ inline ( always ) ]
            pub fn p5ren3(&mut self) -> _P5ren3W {
                _P5ren3W { w: self }
            }
            # [ doc = "Bit 4 - P5REN4" ]
            # [ inline ( always ) ]
            pub fn p5ren4(&mut self) -> _P5ren4W {
                _P5ren4W { w: self }
            }
            # [ doc = "Bit 5 - P5REN5" ]
            # [ inline ( always ) ]
            pub fn p5ren5(&mut self) -> _P5ren5W {
                _P5ren5W { w: self }
            }
            # [ doc = "Bit 6 - P5REN6" ]
            # [ inline ( always ) ]
            pub fn p5ren6(&mut self) -> _P5ren6W {
                _P5ren6W { w: self }
            }
            # [ doc = "Bit 7 - P5REN7" ]
            # [ inline ( always ) ]
            pub fn p5ren7(&mut self) -> _P5ren7W {
                _P5ren7W { w: self }
            }
        }
    }
    # [ doc = "Port 5 Drive Strenght" ]
    pub struct P5ds {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 5 Drive Strenght" ]
    pub mod p5ds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P5ds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds0R {
            bits: u8,
        }
        impl P5ds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds1R {
            bits: u8,
        }
        impl P5ds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds2R {
            bits: u8,
        }
        impl P5ds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds3R {
            bits: u8,
        }
        impl P5ds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds4R {
            bits: u8,
        }
        impl P5ds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds5R {
            bits: u8,
        }
        impl P5ds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds6R {
            bits: u8,
        }
        impl P5ds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5ds7R {
            bits: u8,
        }
        impl P5ds7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5ds7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5ds7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P5DS0" ]
            # [ inline ( always ) ]
            pub fn p5ds0(&self) -> P5ds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds0R { bits }
            }
            # [ doc = "Bit 1 - P5DS1" ]
            # [ inline ( always ) ]
            pub fn p5ds1(&self) -> P5ds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds1R { bits }
            }
            # [ doc = "Bit 2 - P5DS2" ]
            # [ inline ( always ) ]
            pub fn p5ds2(&self) -> P5ds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds2R { bits }
            }
            # [ doc = "Bit 3 - P5DS3" ]
            # [ inline ( always ) ]
            pub fn p5ds3(&self) -> P5ds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds3R { bits }
            }
            # [ doc = "Bit 4 - P5DS4" ]
            # [ inline ( always ) ]
            pub fn p5ds4(&self) -> P5ds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds4R { bits }
            }
            # [ doc = "Bit 5 - P5DS5" ]
            # [ inline ( always ) ]
            pub fn p5ds5(&self) -> P5ds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds5R { bits }
            }
            # [ doc = "Bit 6 - P5DS6" ]
            # [ inline ( always ) ]
            pub fn p5ds6(&self) -> P5ds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds6R { bits }
            }
            # [ doc = "Bit 7 - P5DS7" ]
            # [ inline ( always ) ]
            pub fn p5ds7(&self) -> P5ds7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5ds7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P5DS0" ]
            # [ inline ( always ) ]
            pub fn p5ds0(&mut self) -> _P5ds0W {
                _P5ds0W { w: self }
            }
            # [ doc = "Bit 1 - P5DS1" ]
            # [ inline ( always ) ]
            pub fn p5ds1(&mut self) -> _P5ds1W {
                _P5ds1W { w: self }
            }
            # [ doc = "Bit 2 - P5DS2" ]
            # [ inline ( always ) ]
            pub fn p5ds2(&mut self) -> _P5ds2W {
                _P5ds2W { w: self }
            }
            # [ doc = "Bit 3 - P5DS3" ]
            # [ inline ( always ) ]
            pub fn p5ds3(&mut self) -> _P5ds3W {
                _P5ds3W { w: self }
            }
            # [ doc = "Bit 4 - P5DS4" ]
            # [ inline ( always ) ]
            pub fn p5ds4(&mut self) -> _P5ds4W {
                _P5ds4W { w: self }
            }
            # [ doc = "Bit 5 - P5DS5" ]
            # [ inline ( always ) ]
            pub fn p5ds5(&mut self) -> _P5ds5W {
                _P5ds5W { w: self }
            }
            # [ doc = "Bit 6 - P5DS6" ]
            # [ inline ( always ) ]
            pub fn p5ds6(&mut self) -> _P5ds6W {
                _P5ds6W { w: self }
            }
            # [ doc = "Bit 7 - P5DS7" ]
            # [ inline ( always ) ]
            pub fn p5ds7(&mut self) -> _P5ds7W {
                _P5ds7W { w: self }
            }
        }
    }
    # [ doc = "Port 5 Selection" ]
    pub struct P5sel {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port 5 Selection" ]
    pub mod p5sel {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P5sel {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel0R {
            bits: u8,
        }
        impl P5sel0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel1R {
            bits: u8,
        }
        impl P5sel1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel2R {
            bits: u8,
        }
        impl P5sel2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel3R {
            bits: u8,
        }
        impl P5sel3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel4R {
            bits: u8,
        }
        impl P5sel4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel5R {
            bits: u8,
        }
        impl P5sel5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel6R {
            bits: u8,
        }
        impl P5sel6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct P5sel7R {
            bits: u8,
        }
        impl P5sel7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _P5sel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _P5sel7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - P5SEL0" ]
            # [ inline ( always ) ]
            pub fn p5sel0(&self) -> P5sel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel0R { bits }
            }
            # [ doc = "Bit 1 - P5SEL1" ]
            # [ inline ( always ) ]
            pub fn p5sel1(&self) -> P5sel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel1R { bits }
            }
            # [ doc = "Bit 2 - P5SEL2" ]
            # [ inline ( always ) ]
            pub fn p5sel2(&self) -> P5sel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel2R { bits }
            }
            # [ doc = "Bit 3 - P5SEL3" ]
            # [ inline ( always ) ]
            pub fn p5sel3(&self) -> P5sel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel3R { bits }
            }
            # [ doc = "Bit 4 - P5SEL4" ]
            # [ inline ( always ) ]
            pub fn p5sel4(&self) -> P5sel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel4R { bits }
            }
            # [ doc = "Bit 5 - P5SEL5" ]
            # [ inline ( always ) ]
            pub fn p5sel5(&self) -> P5sel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel5R { bits }
            }
            # [ doc = "Bit 6 - P5SEL6" ]
            # [ inline ( always ) ]
            pub fn p5sel6(&self) -> P5sel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel6R { bits }
            }
            # [ doc = "Bit 7 - P5SEL7" ]
            # [ inline ( always ) ]
            pub fn p5sel7(&self) -> P5sel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                P5sel7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - P5SEL0" ]
            # [ inline ( always ) ]
            pub fn p5sel0(&mut self) -> _P5sel0W {
                _P5sel0W { w: self }
            }
            # [ doc = "Bit 1 - P5SEL1" ]
            # [ inline ( always ) ]
            pub fn p5sel1(&mut self) -> _P5sel1W {
                _P5sel1W { w: self }
            }
            # [ doc = "Bit 2 - P5SEL2" ]
            # [ inline ( always ) ]
            pub fn p5sel2(&mut self) -> _P5sel2W {
                _P5sel2W { w: self }
            }
            # [ doc = "Bit 3 - P5SEL3" ]
            # [ inline ( always ) ]
            pub fn p5sel3(&mut self) -> _P5sel3W {
                _P5sel3W { w: self }
            }
            # [ doc = "Bit 4 - P5SEL4" ]
            # [ inline ( always ) ]
            pub fn p5sel4(&mut self) -> _P5sel4W {
                _P5sel4W { w: self }
            }
            # [ doc = "Bit 5 - P5SEL5" ]
            # [ inline ( always ) ]
            pub fn p5sel5(&mut self) -> _P5sel5W {
                _P5sel5W { w: self }
            }
            # [ doc = "Bit 6 - P5SEL6" ]
            # [ inline ( always ) ]
            pub fn p5sel6(&mut self) -> _P5sel6W {
                _P5sel6W { w: self }
            }
            # [ doc = "Bit 7 - P5SEL7" ]
            # [ inline ( always ) ]
            pub fn p5sel7(&mut self) -> _P5sel7W {
                _P5sel7W { w: self }
            }
        }
    }
}
# [ doc = "Port 5" ]
pub struct Port5 {
    register_block: port_5::RegisterBlock,
}
impl Deref for Port5 {
    type Target = port_5::RegisterBlock;
    fn deref(&self) -> &port_5::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port J" ]
pub const PORT_J: Peripheral<PortJ> = unsafe { Peripheral::new(0) };
# [ doc = "Port J" ]
pub mod port_j {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 800usize],
        # [ doc = "0x320 - Port J Input" ]
        pub pjin: Pjin,
        # [ doc = "0x322 - Port J Output" ]
        pub pjout: Pjout,
        # [ doc = "0x324 - Port J Direction" ]
        pub pjdir: Pjdir,
        # [ doc = "0x326 - Port J Resistor Enable" ]
        pub pjren: Pjren,
        # [ doc = "0x328 - Port J Drive Strenght" ]
        pub pjds: Pjds,
    }
    # [ doc = "Port J Input" ]
    pub struct Pjin {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port J Input" ]
    pub mod pjin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pjin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjin0R {
            bits: u8,
        }
        impl Pjin0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjin1R {
            bits: u8,
        }
        impl Pjin1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjin2R {
            bits: u8,
        }
        impl Pjin2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjin3R {
            bits: u8,
        }
        impl Pjin3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjin0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjin0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjin1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjin1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjin2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjin2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjin3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjin3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PJIN0" ]
            # [ inline ( always ) ]
            pub fn pjin0(&self) -> Pjin0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjin0R { bits }
            }
            # [ doc = "Bit 1 - PJIN1" ]
            # [ inline ( always ) ]
            pub fn pjin1(&self) -> Pjin1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjin1R { bits }
            }
            # [ doc = "Bit 2 - PJIN2" ]
            # [ inline ( always ) ]
            pub fn pjin2(&self) -> Pjin2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjin2R { bits }
            }
            # [ doc = "Bit 3 - PJIN3" ]
            # [ inline ( always ) ]
            pub fn pjin3(&self) -> Pjin3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjin3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PJIN0" ]
            # [ inline ( always ) ]
            pub fn pjin0(&mut self) -> _Pjin0W {
                _Pjin0W { w: self }
            }
            # [ doc = "Bit 1 - PJIN1" ]
            # [ inline ( always ) ]
            pub fn pjin1(&mut self) -> _Pjin1W {
                _Pjin1W { w: self }
            }
            # [ doc = "Bit 2 - PJIN2" ]
            # [ inline ( always ) ]
            pub fn pjin2(&mut self) -> _Pjin2W {
                _Pjin2W { w: self }
            }
            # [ doc = "Bit 3 - PJIN3" ]
            # [ inline ( always ) ]
            pub fn pjin3(&mut self) -> _Pjin3W {
                _Pjin3W { w: self }
            }
        }
    }
    # [ doc = "Port J Output" ]
    pub struct Pjout {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port J Output" ]
    pub mod pjout {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pjout {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjout0R {
            bits: u8,
        }
        impl Pjout0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjout1R {
            bits: u8,
        }
        impl Pjout1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjout2R {
            bits: u8,
        }
        impl Pjout2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjout3R {
            bits: u8,
        }
        impl Pjout3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjout0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjout0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjout1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjout1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjout2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjout2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjout3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjout3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PJOUT0" ]
            # [ inline ( always ) ]
            pub fn pjout0(&self) -> Pjout0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjout0R { bits }
            }
            # [ doc = "Bit 1 - PJOUT1" ]
            # [ inline ( always ) ]
            pub fn pjout1(&self) -> Pjout1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjout1R { bits }
            }
            # [ doc = "Bit 2 - PJOUT2" ]
            # [ inline ( always ) ]
            pub fn pjout2(&self) -> Pjout2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjout2R { bits }
            }
            # [ doc = "Bit 3 - PJOUT3" ]
            # [ inline ( always ) ]
            pub fn pjout3(&self) -> Pjout3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjout3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PJOUT0" ]
            # [ inline ( always ) ]
            pub fn pjout0(&mut self) -> _Pjout0W {
                _Pjout0W { w: self }
            }
            # [ doc = "Bit 1 - PJOUT1" ]
            # [ inline ( always ) ]
            pub fn pjout1(&mut self) -> _Pjout1W {
                _Pjout1W { w: self }
            }
            # [ doc = "Bit 2 - PJOUT2" ]
            # [ inline ( always ) ]
            pub fn pjout2(&mut self) -> _Pjout2W {
                _Pjout2W { w: self }
            }
            # [ doc = "Bit 3 - PJOUT3" ]
            # [ inline ( always ) ]
            pub fn pjout3(&mut self) -> _Pjout3W {
                _Pjout3W { w: self }
            }
        }
    }
    # [ doc = "Port J Direction" ]
    pub struct Pjdir {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port J Direction" ]
    pub mod pjdir {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pjdir {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjdir0R {
            bits: u8,
        }
        impl Pjdir0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjdir1R {
            bits: u8,
        }
        impl Pjdir1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjdir2R {
            bits: u8,
        }
        impl Pjdir2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjdir3R {
            bits: u8,
        }
        impl Pjdir3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjdir0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjdir0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjdir1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjdir1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjdir2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjdir2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjdir3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjdir3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PJDIR0" ]
            # [ inline ( always ) ]
            pub fn pjdir0(&self) -> Pjdir0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjdir0R { bits }
            }
            # [ doc = "Bit 1 - PJDIR1" ]
            # [ inline ( always ) ]
            pub fn pjdir1(&self) -> Pjdir1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjdir1R { bits }
            }
            # [ doc = "Bit 2 - PJDIR2" ]
            # [ inline ( always ) ]
            pub fn pjdir2(&self) -> Pjdir2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjdir2R { bits }
            }
            # [ doc = "Bit 3 - PJDIR3" ]
            # [ inline ( always ) ]
            pub fn pjdir3(&self) -> Pjdir3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjdir3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PJDIR0" ]
            # [ inline ( always ) ]
            pub fn pjdir0(&mut self) -> _Pjdir0W {
                _Pjdir0W { w: self }
            }
            # [ doc = "Bit 1 - PJDIR1" ]
            # [ inline ( always ) ]
            pub fn pjdir1(&mut self) -> _Pjdir1W {
                _Pjdir1W { w: self }
            }
            # [ doc = "Bit 2 - PJDIR2" ]
            # [ inline ( always ) ]
            pub fn pjdir2(&mut self) -> _Pjdir2W {
                _Pjdir2W { w: self }
            }
            # [ doc = "Bit 3 - PJDIR3" ]
            # [ inline ( always ) ]
            pub fn pjdir3(&mut self) -> _Pjdir3W {
                _Pjdir3W { w: self }
            }
        }
    }
    # [ doc = "Port J Resistor Enable" ]
    pub struct Pjren {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port J Resistor Enable" ]
    pub mod pjren {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pjren {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjren0R {
            bits: u8,
        }
        impl Pjren0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjren1R {
            bits: u8,
        }
        impl Pjren1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjren2R {
            bits: u8,
        }
        impl Pjren2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjren3R {
            bits: u8,
        }
        impl Pjren3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjren0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjren0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjren1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjren1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjren2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjren2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjren3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjren3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PJREN0" ]
            # [ inline ( always ) ]
            pub fn pjren0(&self) -> Pjren0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjren0R { bits }
            }
            # [ doc = "Bit 1 - PJREN1" ]
            # [ inline ( always ) ]
            pub fn pjren1(&self) -> Pjren1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjren1R { bits }
            }
            # [ doc = "Bit 2 - PJREN2" ]
            # [ inline ( always ) ]
            pub fn pjren2(&self) -> Pjren2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjren2R { bits }
            }
            # [ doc = "Bit 3 - PJREN3" ]
            # [ inline ( always ) ]
            pub fn pjren3(&self) -> Pjren3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjren3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PJREN0" ]
            # [ inline ( always ) ]
            pub fn pjren0(&mut self) -> _Pjren0W {
                _Pjren0W { w: self }
            }
            # [ doc = "Bit 1 - PJREN1" ]
            # [ inline ( always ) ]
            pub fn pjren1(&mut self) -> _Pjren1W {
                _Pjren1W { w: self }
            }
            # [ doc = "Bit 2 - PJREN2" ]
            # [ inline ( always ) ]
            pub fn pjren2(&mut self) -> _Pjren2W {
                _Pjren2W { w: self }
            }
            # [ doc = "Bit 3 - PJREN3" ]
            # [ inline ( always ) ]
            pub fn pjren3(&mut self) -> _Pjren3W {
                _Pjren3W { w: self }
            }
        }
    }
    # [ doc = "Port J Drive Strenght" ]
    pub struct Pjds {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port J Drive Strenght" ]
    pub mod pjds {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pjds {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjds0R {
            bits: u8,
        }
        impl Pjds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjds1R {
            bits: u8,
        }
        impl Pjds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjds2R {
            bits: u8,
        }
        impl Pjds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pjds3R {
            bits: u8,
        }
        impl Pjds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pjds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pjds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PJDS0" ]
            # [ inline ( always ) ]
            pub fn pjds0(&self) -> Pjds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjds0R { bits }
            }
            # [ doc = "Bit 1 - PJDS1" ]
            # [ inline ( always ) ]
            pub fn pjds1(&self) -> Pjds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjds1R { bits }
            }
            # [ doc = "Bit 2 - PJDS2" ]
            # [ inline ( always ) ]
            pub fn pjds2(&self) -> Pjds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjds2R { bits }
            }
            # [ doc = "Bit 3 - PJDS3" ]
            # [ inline ( always ) ]
            pub fn pjds3(&self) -> Pjds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pjds3R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PJDS0" ]
            # [ inline ( always ) ]
            pub fn pjds0(&mut self) -> _Pjds0W {
                _Pjds0W { w: self }
            }
            # [ doc = "Bit 1 - PJDS1" ]
            # [ inline ( always ) ]
            pub fn pjds1(&mut self) -> _Pjds1W {
                _Pjds1W { w: self }
            }
            # [ doc = "Bit 2 - PJDS2" ]
            # [ inline ( always ) ]
            pub fn pjds2(&mut self) -> _Pjds2W {
                _Pjds2W { w: self }
            }
            # [ doc = "Bit 3 - PJDS3" ]
            # [ inline ( always ) ]
            pub fn pjds3(&mut self) -> _Pjds3W {
                _Pjds3W { w: self }
            }
        }
    }
}
# [ doc = "Port J" ]
pub struct PortJ {
    register_block: port_j::RegisterBlock,
}
impl Deref for PortJ {
    type Target = port_j::RegisterBlock;
    fn deref(&self) -> &port_j::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port Mapping Control" ]
pub const PORT_MAPPING_CONTROL: Peripheral<PortMappingControl> = unsafe { Peripheral::new(0) };
# [ doc = "Port Mapping Control" ]
pub mod port_mapping_control {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 448usize],
        # [ doc = "0x1c0 - Port Mapping Key register" ]
        pub pmapkeyid: Pmapkeyid,
        # [ doc = "0x1c2 - Port Mapping control register" ]
        pub pmapctl: Pmapctl,
    }
    # [ doc = "Port Mapping Key register" ]
    pub struct Pmapkeyid {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port Mapping Key register" ]
    pub mod pmapkeyid {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pmapkeyid {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Port Mapping control register" ]
    pub struct Pmapctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port Mapping control register" ]
    pub mod pmapctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pmapctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmaplockedR {
            bits: u8,
        }
        impl PmaplockedR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmaprecfgR {
            bits: u8,
        }
        impl PmaprecfgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmaplockedW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmaplockedW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmaprecfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmaprecfgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Port Mapping Lock bit. Read only" ]
            # [ inline ( always ) ]
            pub fn pmaplocked(&self) -> PmaplockedR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmaplockedR { bits }
            }
            # [ doc = "Bit 1 - Port Mapping re-configuration control bit" ]
            # [ inline ( always ) ]
            pub fn pmaprecfg(&self) -> PmaprecfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmaprecfgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Port Mapping Lock bit. Read only" ]
            # [ inline ( always ) ]
            pub fn pmaplocked(&mut self) -> _PmaplockedW {
                _PmaplockedW { w: self }
            }
            # [ doc = "Bit 1 - Port Mapping re-configuration control bit" ]
            # [ inline ( always ) ]
            pub fn pmaprecfg(&mut self) -> _PmaprecfgW {
                _PmaprecfgW { w: self }
            }
        }
    }
}
# [ doc = "Port Mapping Control" ]
pub struct PortMappingControl {
    register_block: port_mapping_control::RegisterBlock,
}
impl Deref for PortMappingControl {
    type Target = port_mapping_control::RegisterBlock;
    fn deref(&self) -> &port_mapping_control::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port Mapping Port 1" ]
pub const PORT_MAPPING_PORT_1: Peripheral<PortMappingPort1> = unsafe { Peripheral::new(0) };
# [ doc = "Port Mapping Port 1" ]
pub mod port_mapping_port_1 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 456usize],
        # [ doc = "0x1c8 - Port P1.0/1 mapping register" ]
        pub p1map01: P1map01,
        # [ doc = "0x1ca - Port P1.2/3 mapping register" ]
        pub p1map23: P1map23,
        # [ doc = "0x1cc - Port P1.4/5 mapping register" ]
        pub p1map45: P1map45,
        # [ doc = "0x1ce - Port P1.6/7 mapping register" ]
        pub p1map67: P1map67,
    }
    # [ doc = "Port P1.0/1 mapping register" ]
    pub struct P1map01 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P1.0/1 mapping register" ]
    pub mod p1map01 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P1map01 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap010R {
            bits: u8,
        }
        impl Pmap010R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap011R {
            bits: u8,
        }
        impl Pmap011R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap012R {
            bits: u8,
        }
        impl Pmap012R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap013R {
            bits: u8,
        }
        impl Pmap013R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap014R {
            bits: u8,
        }
        impl Pmap014R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap015R {
            bits: u8,
        }
        impl Pmap015R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap016R {
            bits: u8,
        }
        impl Pmap016R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap017R {
            bits: u8,
        }
        impl Pmap017R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap018R {
            bits: u8,
        }
        impl Pmap018R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap019R {
            bits: u8,
        }
        impl Pmap019R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0110R {
            bits: u8,
        }
        impl Pmap0110R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0111R {
            bits: u8,
        }
        impl Pmap0111R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0112R {
            bits: u8,
        }
        impl Pmap0112R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0113R {
            bits: u8,
        }
        impl Pmap0113R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0114R {
            bits: u8,
        }
        impl Pmap0114R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0115R {
            bits: u8,
        }
        impl Pmap0115R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap010W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap010W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap011W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap011W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap012W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap012W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap013W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap013W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap014W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap014W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap015W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap015W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap016W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap016W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap017W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap017W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap018W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap018W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap019W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap019W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0110W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0110W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0111W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0111W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0112W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0112W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0113W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0113W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0114W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0114W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0115W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0115W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP01_0" ]
            # [ inline ( always ) ]
            pub fn pmap01_0(&self) -> Pmap010R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap010R { bits }
            }
            # [ doc = "Bit 1 - PMAP01_1" ]
            # [ inline ( always ) ]
            pub fn pmap01_1(&self) -> Pmap011R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap011R { bits }
            }
            # [ doc = "Bit 2 - PMAP01_2" ]
            # [ inline ( always ) ]
            pub fn pmap01_2(&self) -> Pmap012R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap012R { bits }
            }
            # [ doc = "Bit 3 - PMAP01_3" ]
            # [ inline ( always ) ]
            pub fn pmap01_3(&self) -> Pmap013R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap013R { bits }
            }
            # [ doc = "Bit 4 - PMAP01_4" ]
            # [ inline ( always ) ]
            pub fn pmap01_4(&self) -> Pmap014R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap014R { bits }
            }
            # [ doc = "Bit 5 - PMAP01_5" ]
            # [ inline ( always ) ]
            pub fn pmap01_5(&self) -> Pmap015R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap015R { bits }
            }
            # [ doc = "Bit 6 - PMAP01_6" ]
            # [ inline ( always ) ]
            pub fn pmap01_6(&self) -> Pmap016R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap016R { bits }
            }
            # [ doc = "Bit 7 - PMAP01_7" ]
            # [ inline ( always ) ]
            pub fn pmap01_7(&self) -> Pmap017R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap017R { bits }
            }
            # [ doc = "Bit 8 - PMAP01_8" ]
            # [ inline ( always ) ]
            pub fn pmap01_8(&self) -> Pmap018R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap018R { bits }
            }
            # [ doc = "Bit 9 - PMAP01_9" ]
            # [ inline ( always ) ]
            pub fn pmap01_9(&self) -> Pmap019R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap019R { bits }
            }
            # [ doc = "Bit 10 - PMAP01_10" ]
            # [ inline ( always ) ]
            pub fn pmap01_10(&self) -> Pmap0110R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0110R { bits }
            }
            # [ doc = "Bit 11 - PMAP01_11" ]
            # [ inline ( always ) ]
            pub fn pmap01_11(&self) -> Pmap0111R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0111R { bits }
            }
            # [ doc = "Bit 12 - PMAP01_12" ]
            # [ inline ( always ) ]
            pub fn pmap01_12(&self) -> Pmap0112R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0112R { bits }
            }
            # [ doc = "Bit 13 - PMAP01_13" ]
            # [ inline ( always ) ]
            pub fn pmap01_13(&self) -> Pmap0113R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0113R { bits }
            }
            # [ doc = "Bit 14 - PMAP01_14" ]
            # [ inline ( always ) ]
            pub fn pmap01_14(&self) -> Pmap0114R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0114R { bits }
            }
            # [ doc = "Bit 15 - PMAP01_15" ]
            # [ inline ( always ) ]
            pub fn pmap01_15(&self) -> Pmap0115R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0115R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP01_0" ]
            # [ inline ( always ) ]
            pub fn pmap01_0(&mut self) -> _Pmap010W {
                _Pmap010W { w: self }
            }
            # [ doc = "Bit 1 - PMAP01_1" ]
            # [ inline ( always ) ]
            pub fn pmap01_1(&mut self) -> _Pmap011W {
                _Pmap011W { w: self }
            }
            # [ doc = "Bit 2 - PMAP01_2" ]
            # [ inline ( always ) ]
            pub fn pmap01_2(&mut self) -> _Pmap012W {
                _Pmap012W { w: self }
            }
            # [ doc = "Bit 3 - PMAP01_3" ]
            # [ inline ( always ) ]
            pub fn pmap01_3(&mut self) -> _Pmap013W {
                _Pmap013W { w: self }
            }
            # [ doc = "Bit 4 - PMAP01_4" ]
            # [ inline ( always ) ]
            pub fn pmap01_4(&mut self) -> _Pmap014W {
                _Pmap014W { w: self }
            }
            # [ doc = "Bit 5 - PMAP01_5" ]
            # [ inline ( always ) ]
            pub fn pmap01_5(&mut self) -> _Pmap015W {
                _Pmap015W { w: self }
            }
            # [ doc = "Bit 6 - PMAP01_6" ]
            # [ inline ( always ) ]
            pub fn pmap01_6(&mut self) -> _Pmap016W {
                _Pmap016W { w: self }
            }
            # [ doc = "Bit 7 - PMAP01_7" ]
            # [ inline ( always ) ]
            pub fn pmap01_7(&mut self) -> _Pmap017W {
                _Pmap017W { w: self }
            }
            # [ doc = "Bit 8 - PMAP01_8" ]
            # [ inline ( always ) ]
            pub fn pmap01_8(&mut self) -> _Pmap018W {
                _Pmap018W { w: self }
            }
            # [ doc = "Bit 9 - PMAP01_9" ]
            # [ inline ( always ) ]
            pub fn pmap01_9(&mut self) -> _Pmap019W {
                _Pmap019W { w: self }
            }
            # [ doc = "Bit 10 - PMAP01_10" ]
            # [ inline ( always ) ]
            pub fn pmap01_10(&mut self) -> _Pmap0110W {
                _Pmap0110W { w: self }
            }
            # [ doc = "Bit 11 - PMAP01_11" ]
            # [ inline ( always ) ]
            pub fn pmap01_11(&mut self) -> _Pmap0111W {
                _Pmap0111W { w: self }
            }
            # [ doc = "Bit 12 - PMAP01_12" ]
            # [ inline ( always ) ]
            pub fn pmap01_12(&mut self) -> _Pmap0112W {
                _Pmap0112W { w: self }
            }
            # [ doc = "Bit 13 - PMAP01_13" ]
            # [ inline ( always ) ]
            pub fn pmap01_13(&mut self) -> _Pmap0113W {
                _Pmap0113W { w: self }
            }
            # [ doc = "Bit 14 - PMAP01_14" ]
            # [ inline ( always ) ]
            pub fn pmap01_14(&mut self) -> _Pmap0114W {
                _Pmap0114W { w: self }
            }
            # [ doc = "Bit 15 - PMAP01_15" ]
            # [ inline ( always ) ]
            pub fn pmap01_15(&mut self) -> _Pmap0115W {
                _Pmap0115W { w: self }
            }
        }
    }
    # [ doc = "Port P1.2/3 mapping register" ]
    pub struct P1map23 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P1.2/3 mapping register" ]
    pub mod p1map23 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P1map23 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap230R {
            bits: u8,
        }
        impl Pmap230R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap231R {
            bits: u8,
        }
        impl Pmap231R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap232R {
            bits: u8,
        }
        impl Pmap232R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap233R {
            bits: u8,
        }
        impl Pmap233R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap234R {
            bits: u8,
        }
        impl Pmap234R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap235R {
            bits: u8,
        }
        impl Pmap235R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap236R {
            bits: u8,
        }
        impl Pmap236R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap237R {
            bits: u8,
        }
        impl Pmap237R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap238R {
            bits: u8,
        }
        impl Pmap238R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap239R {
            bits: u8,
        }
        impl Pmap239R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2310R {
            bits: u8,
        }
        impl Pmap2310R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2311R {
            bits: u8,
        }
        impl Pmap2311R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2312R {
            bits: u8,
        }
        impl Pmap2312R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2313R {
            bits: u8,
        }
        impl Pmap2313R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2314R {
            bits: u8,
        }
        impl Pmap2314R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2315R {
            bits: u8,
        }
        impl Pmap2315R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap230W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap230W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap231W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap231W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap232W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap232W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap233W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap233W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap234W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap234W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap235W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap235W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap236W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap236W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap237W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap237W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap238W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap238W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap239W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap239W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2310W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2310W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2311W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2311W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2312W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2312W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2313W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2313W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2314W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2314W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2315W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2315W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP23_0" ]
            # [ inline ( always ) ]
            pub fn pmap23_0(&self) -> Pmap230R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap230R { bits }
            }
            # [ doc = "Bit 1 - PMAP23_1" ]
            # [ inline ( always ) ]
            pub fn pmap23_1(&self) -> Pmap231R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap231R { bits }
            }
            # [ doc = "Bit 2 - PMAP23_2" ]
            # [ inline ( always ) ]
            pub fn pmap23_2(&self) -> Pmap232R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap232R { bits }
            }
            # [ doc = "Bit 3 - PMAP23_3" ]
            # [ inline ( always ) ]
            pub fn pmap23_3(&self) -> Pmap233R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap233R { bits }
            }
            # [ doc = "Bit 4 - PMAP23_4" ]
            # [ inline ( always ) ]
            pub fn pmap23_4(&self) -> Pmap234R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap234R { bits }
            }
            # [ doc = "Bit 5 - PMAP23_5" ]
            # [ inline ( always ) ]
            pub fn pmap23_5(&self) -> Pmap235R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap235R { bits }
            }
            # [ doc = "Bit 6 - PMAP23_6" ]
            # [ inline ( always ) ]
            pub fn pmap23_6(&self) -> Pmap236R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap236R { bits }
            }
            # [ doc = "Bit 7 - PMAP23_7" ]
            # [ inline ( always ) ]
            pub fn pmap23_7(&self) -> Pmap237R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap237R { bits }
            }
            # [ doc = "Bit 8 - PMAP23_8" ]
            # [ inline ( always ) ]
            pub fn pmap23_8(&self) -> Pmap238R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap238R { bits }
            }
            # [ doc = "Bit 9 - PMAP23_9" ]
            # [ inline ( always ) ]
            pub fn pmap23_9(&self) -> Pmap239R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap239R { bits }
            }
            # [ doc = "Bit 10 - PMAP23_10" ]
            # [ inline ( always ) ]
            pub fn pmap23_10(&self) -> Pmap2310R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2310R { bits }
            }
            # [ doc = "Bit 11 - PMAP23_11" ]
            # [ inline ( always ) ]
            pub fn pmap23_11(&self) -> Pmap2311R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2311R { bits }
            }
            # [ doc = "Bit 12 - PMAP23_12" ]
            # [ inline ( always ) ]
            pub fn pmap23_12(&self) -> Pmap2312R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2312R { bits }
            }
            # [ doc = "Bit 13 - PMAP23_13" ]
            # [ inline ( always ) ]
            pub fn pmap23_13(&self) -> Pmap2313R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2313R { bits }
            }
            # [ doc = "Bit 14 - PMAP23_14" ]
            # [ inline ( always ) ]
            pub fn pmap23_14(&self) -> Pmap2314R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2314R { bits }
            }
            # [ doc = "Bit 15 - PMAP23_15" ]
            # [ inline ( always ) ]
            pub fn pmap23_15(&self) -> Pmap2315R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2315R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP23_0" ]
            # [ inline ( always ) ]
            pub fn pmap23_0(&mut self) -> _Pmap230W {
                _Pmap230W { w: self }
            }
            # [ doc = "Bit 1 - PMAP23_1" ]
            # [ inline ( always ) ]
            pub fn pmap23_1(&mut self) -> _Pmap231W {
                _Pmap231W { w: self }
            }
            # [ doc = "Bit 2 - PMAP23_2" ]
            # [ inline ( always ) ]
            pub fn pmap23_2(&mut self) -> _Pmap232W {
                _Pmap232W { w: self }
            }
            # [ doc = "Bit 3 - PMAP23_3" ]
            # [ inline ( always ) ]
            pub fn pmap23_3(&mut self) -> _Pmap233W {
                _Pmap233W { w: self }
            }
            # [ doc = "Bit 4 - PMAP23_4" ]
            # [ inline ( always ) ]
            pub fn pmap23_4(&mut self) -> _Pmap234W {
                _Pmap234W { w: self }
            }
            # [ doc = "Bit 5 - PMAP23_5" ]
            # [ inline ( always ) ]
            pub fn pmap23_5(&mut self) -> _Pmap235W {
                _Pmap235W { w: self }
            }
            # [ doc = "Bit 6 - PMAP23_6" ]
            # [ inline ( always ) ]
            pub fn pmap23_6(&mut self) -> _Pmap236W {
                _Pmap236W { w: self }
            }
            # [ doc = "Bit 7 - PMAP23_7" ]
            # [ inline ( always ) ]
            pub fn pmap23_7(&mut self) -> _Pmap237W {
                _Pmap237W { w: self }
            }
            # [ doc = "Bit 8 - PMAP23_8" ]
            # [ inline ( always ) ]
            pub fn pmap23_8(&mut self) -> _Pmap238W {
                _Pmap238W { w: self }
            }
            # [ doc = "Bit 9 - PMAP23_9" ]
            # [ inline ( always ) ]
            pub fn pmap23_9(&mut self) -> _Pmap239W {
                _Pmap239W { w: self }
            }
            # [ doc = "Bit 10 - PMAP23_10" ]
            # [ inline ( always ) ]
            pub fn pmap23_10(&mut self) -> _Pmap2310W {
                _Pmap2310W { w: self }
            }
            # [ doc = "Bit 11 - PMAP23_11" ]
            # [ inline ( always ) ]
            pub fn pmap23_11(&mut self) -> _Pmap2311W {
                _Pmap2311W { w: self }
            }
            # [ doc = "Bit 12 - PMAP23_12" ]
            # [ inline ( always ) ]
            pub fn pmap23_12(&mut self) -> _Pmap2312W {
                _Pmap2312W { w: self }
            }
            # [ doc = "Bit 13 - PMAP23_13" ]
            # [ inline ( always ) ]
            pub fn pmap23_13(&mut self) -> _Pmap2313W {
                _Pmap2313W { w: self }
            }
            # [ doc = "Bit 14 - PMAP23_14" ]
            # [ inline ( always ) ]
            pub fn pmap23_14(&mut self) -> _Pmap2314W {
                _Pmap2314W { w: self }
            }
            # [ doc = "Bit 15 - PMAP23_15" ]
            # [ inline ( always ) ]
            pub fn pmap23_15(&mut self) -> _Pmap2315W {
                _Pmap2315W { w: self }
            }
        }
    }
    # [ doc = "Port P1.4/5 mapping register" ]
    pub struct P1map45 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P1.4/5 mapping register" ]
    pub mod p1map45 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P1map45 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap450R {
            bits: u8,
        }
        impl Pmap450R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap451R {
            bits: u8,
        }
        impl Pmap451R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap452R {
            bits: u8,
        }
        impl Pmap452R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap453R {
            bits: u8,
        }
        impl Pmap453R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap454R {
            bits: u8,
        }
        impl Pmap454R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap455R {
            bits: u8,
        }
        impl Pmap455R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap456R {
            bits: u8,
        }
        impl Pmap456R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap457R {
            bits: u8,
        }
        impl Pmap457R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap458R {
            bits: u8,
        }
        impl Pmap458R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap459R {
            bits: u8,
        }
        impl Pmap459R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4510R {
            bits: u8,
        }
        impl Pmap4510R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4511R {
            bits: u8,
        }
        impl Pmap4511R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4512R {
            bits: u8,
        }
        impl Pmap4512R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4513R {
            bits: u8,
        }
        impl Pmap4513R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4514R {
            bits: u8,
        }
        impl Pmap4514R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4515R {
            bits: u8,
        }
        impl Pmap4515R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap450W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap450W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap451W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap451W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap452W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap452W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap453W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap453W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap454W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap454W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap455W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap455W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap456W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap456W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap457W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap457W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap458W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap458W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap459W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap459W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4510W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4510W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4511W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4511W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4512W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4512W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4513W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4513W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4514W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4514W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4515W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4515W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP45_0" ]
            # [ inline ( always ) ]
            pub fn pmap45_0(&self) -> Pmap450R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap450R { bits }
            }
            # [ doc = "Bit 1 - PMAP45_1" ]
            # [ inline ( always ) ]
            pub fn pmap45_1(&self) -> Pmap451R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap451R { bits }
            }
            # [ doc = "Bit 2 - PMAP45_2" ]
            # [ inline ( always ) ]
            pub fn pmap45_2(&self) -> Pmap452R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap452R { bits }
            }
            # [ doc = "Bit 3 - PMAP45_3" ]
            # [ inline ( always ) ]
            pub fn pmap45_3(&self) -> Pmap453R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap453R { bits }
            }
            # [ doc = "Bit 4 - PMAP45_4" ]
            # [ inline ( always ) ]
            pub fn pmap45_4(&self) -> Pmap454R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap454R { bits }
            }
            # [ doc = "Bit 5 - PMAP45_5" ]
            # [ inline ( always ) ]
            pub fn pmap45_5(&self) -> Pmap455R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap455R { bits }
            }
            # [ doc = "Bit 6 - PMAP45_6" ]
            # [ inline ( always ) ]
            pub fn pmap45_6(&self) -> Pmap456R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap456R { bits }
            }
            # [ doc = "Bit 7 - PMAP45_7" ]
            # [ inline ( always ) ]
            pub fn pmap45_7(&self) -> Pmap457R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap457R { bits }
            }
            # [ doc = "Bit 8 - PMAP45_8" ]
            # [ inline ( always ) ]
            pub fn pmap45_8(&self) -> Pmap458R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap458R { bits }
            }
            # [ doc = "Bit 9 - PMAP45_9" ]
            # [ inline ( always ) ]
            pub fn pmap45_9(&self) -> Pmap459R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap459R { bits }
            }
            # [ doc = "Bit 10 - PMAP45_10" ]
            # [ inline ( always ) ]
            pub fn pmap45_10(&self) -> Pmap4510R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4510R { bits }
            }
            # [ doc = "Bit 11 - PMAP45_11" ]
            # [ inline ( always ) ]
            pub fn pmap45_11(&self) -> Pmap4511R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4511R { bits }
            }
            # [ doc = "Bit 12 - PMAP45_12" ]
            # [ inline ( always ) ]
            pub fn pmap45_12(&self) -> Pmap4512R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4512R { bits }
            }
            # [ doc = "Bit 13 - PMAP45_13" ]
            # [ inline ( always ) ]
            pub fn pmap45_13(&self) -> Pmap4513R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4513R { bits }
            }
            # [ doc = "Bit 14 - PMAP45_14" ]
            # [ inline ( always ) ]
            pub fn pmap45_14(&self) -> Pmap4514R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4514R { bits }
            }
            # [ doc = "Bit 15 - PMAP45_15" ]
            # [ inline ( always ) ]
            pub fn pmap45_15(&self) -> Pmap4515R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4515R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP45_0" ]
            # [ inline ( always ) ]
            pub fn pmap45_0(&mut self) -> _Pmap450W {
                _Pmap450W { w: self }
            }
            # [ doc = "Bit 1 - PMAP45_1" ]
            # [ inline ( always ) ]
            pub fn pmap45_1(&mut self) -> _Pmap451W {
                _Pmap451W { w: self }
            }
            # [ doc = "Bit 2 - PMAP45_2" ]
            # [ inline ( always ) ]
            pub fn pmap45_2(&mut self) -> _Pmap452W {
                _Pmap452W { w: self }
            }
            # [ doc = "Bit 3 - PMAP45_3" ]
            # [ inline ( always ) ]
            pub fn pmap45_3(&mut self) -> _Pmap453W {
                _Pmap453W { w: self }
            }
            # [ doc = "Bit 4 - PMAP45_4" ]
            # [ inline ( always ) ]
            pub fn pmap45_4(&mut self) -> _Pmap454W {
                _Pmap454W { w: self }
            }
            # [ doc = "Bit 5 - PMAP45_5" ]
            # [ inline ( always ) ]
            pub fn pmap45_5(&mut self) -> _Pmap455W {
                _Pmap455W { w: self }
            }
            # [ doc = "Bit 6 - PMAP45_6" ]
            # [ inline ( always ) ]
            pub fn pmap45_6(&mut self) -> _Pmap456W {
                _Pmap456W { w: self }
            }
            # [ doc = "Bit 7 - PMAP45_7" ]
            # [ inline ( always ) ]
            pub fn pmap45_7(&mut self) -> _Pmap457W {
                _Pmap457W { w: self }
            }
            # [ doc = "Bit 8 - PMAP45_8" ]
            # [ inline ( always ) ]
            pub fn pmap45_8(&mut self) -> _Pmap458W {
                _Pmap458W { w: self }
            }
            # [ doc = "Bit 9 - PMAP45_9" ]
            # [ inline ( always ) ]
            pub fn pmap45_9(&mut self) -> _Pmap459W {
                _Pmap459W { w: self }
            }
            # [ doc = "Bit 10 - PMAP45_10" ]
            # [ inline ( always ) ]
            pub fn pmap45_10(&mut self) -> _Pmap4510W {
                _Pmap4510W { w: self }
            }
            # [ doc = "Bit 11 - PMAP45_11" ]
            # [ inline ( always ) ]
            pub fn pmap45_11(&mut self) -> _Pmap4511W {
                _Pmap4511W { w: self }
            }
            # [ doc = "Bit 12 - PMAP45_12" ]
            # [ inline ( always ) ]
            pub fn pmap45_12(&mut self) -> _Pmap4512W {
                _Pmap4512W { w: self }
            }
            # [ doc = "Bit 13 - PMAP45_13" ]
            # [ inline ( always ) ]
            pub fn pmap45_13(&mut self) -> _Pmap4513W {
                _Pmap4513W { w: self }
            }
            # [ doc = "Bit 14 - PMAP45_14" ]
            # [ inline ( always ) ]
            pub fn pmap45_14(&mut self) -> _Pmap4514W {
                _Pmap4514W { w: self }
            }
            # [ doc = "Bit 15 - PMAP45_15" ]
            # [ inline ( always ) ]
            pub fn pmap45_15(&mut self) -> _Pmap4515W {
                _Pmap4515W { w: self }
            }
        }
    }
    # [ doc = "Port P1.6/7 mapping register" ]
    pub struct P1map67 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P1.6/7 mapping register" ]
    pub mod p1map67 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P1map67 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap670R {
            bits: u8,
        }
        impl Pmap670R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap671R {
            bits: u8,
        }
        impl Pmap671R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap672R {
            bits: u8,
        }
        impl Pmap672R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap673R {
            bits: u8,
        }
        impl Pmap673R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap674R {
            bits: u8,
        }
        impl Pmap674R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap675R {
            bits: u8,
        }
        impl Pmap675R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap676R {
            bits: u8,
        }
        impl Pmap676R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap677R {
            bits: u8,
        }
        impl Pmap677R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap678R {
            bits: u8,
        }
        impl Pmap678R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap679R {
            bits: u8,
        }
        impl Pmap679R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6710R {
            bits: u8,
        }
        impl Pmap6710R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6711R {
            bits: u8,
        }
        impl Pmap6711R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6712R {
            bits: u8,
        }
        impl Pmap6712R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6713R {
            bits: u8,
        }
        impl Pmap6713R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6714R {
            bits: u8,
        }
        impl Pmap6714R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6715R {
            bits: u8,
        }
        impl Pmap6715R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap670W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap670W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap671W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap671W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap672W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap672W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap673W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap673W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap674W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap674W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap675W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap675W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap676W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap676W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap677W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap677W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap678W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap678W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap679W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap679W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6710W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6710W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6711W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6711W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6712W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6712W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6713W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6713W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6714W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6714W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6715W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6715W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP67_0" ]
            # [ inline ( always ) ]
            pub fn pmap67_0(&self) -> Pmap670R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap670R { bits }
            }
            # [ doc = "Bit 1 - PMAP67_1" ]
            # [ inline ( always ) ]
            pub fn pmap67_1(&self) -> Pmap671R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap671R { bits }
            }
            # [ doc = "Bit 2 - PMAP67_2" ]
            # [ inline ( always ) ]
            pub fn pmap67_2(&self) -> Pmap672R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap672R { bits }
            }
            # [ doc = "Bit 3 - PMAP67_3" ]
            # [ inline ( always ) ]
            pub fn pmap67_3(&self) -> Pmap673R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap673R { bits }
            }
            # [ doc = "Bit 4 - PMAP67_4" ]
            # [ inline ( always ) ]
            pub fn pmap67_4(&self) -> Pmap674R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap674R { bits }
            }
            # [ doc = "Bit 5 - PMAP67_5" ]
            # [ inline ( always ) ]
            pub fn pmap67_5(&self) -> Pmap675R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap675R { bits }
            }
            # [ doc = "Bit 6 - PMAP67_6" ]
            # [ inline ( always ) ]
            pub fn pmap67_6(&self) -> Pmap676R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap676R { bits }
            }
            # [ doc = "Bit 7 - PMAP67_7" ]
            # [ inline ( always ) ]
            pub fn pmap67_7(&self) -> Pmap677R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap677R { bits }
            }
            # [ doc = "Bit 8 - PMAP67_8" ]
            # [ inline ( always ) ]
            pub fn pmap67_8(&self) -> Pmap678R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap678R { bits }
            }
            # [ doc = "Bit 9 - PMAP67_9" ]
            # [ inline ( always ) ]
            pub fn pmap67_9(&self) -> Pmap679R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap679R { bits }
            }
            # [ doc = "Bit 10 - PMAP67_10" ]
            # [ inline ( always ) ]
            pub fn pmap67_10(&self) -> Pmap6710R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6710R { bits }
            }
            # [ doc = "Bit 11 - PMAP67_11" ]
            # [ inline ( always ) ]
            pub fn pmap67_11(&self) -> Pmap6711R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6711R { bits }
            }
            # [ doc = "Bit 12 - PMAP67_12" ]
            # [ inline ( always ) ]
            pub fn pmap67_12(&self) -> Pmap6712R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6712R { bits }
            }
            # [ doc = "Bit 13 - PMAP67_13" ]
            # [ inline ( always ) ]
            pub fn pmap67_13(&self) -> Pmap6713R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6713R { bits }
            }
            # [ doc = "Bit 14 - PMAP67_14" ]
            # [ inline ( always ) ]
            pub fn pmap67_14(&self) -> Pmap6714R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6714R { bits }
            }
            # [ doc = "Bit 15 - PMAP67_15" ]
            # [ inline ( always ) ]
            pub fn pmap67_15(&self) -> Pmap6715R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6715R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP67_0" ]
            # [ inline ( always ) ]
            pub fn pmap67_0(&mut self) -> _Pmap670W {
                _Pmap670W { w: self }
            }
            # [ doc = "Bit 1 - PMAP67_1" ]
            # [ inline ( always ) ]
            pub fn pmap67_1(&mut self) -> _Pmap671W {
                _Pmap671W { w: self }
            }
            # [ doc = "Bit 2 - PMAP67_2" ]
            # [ inline ( always ) ]
            pub fn pmap67_2(&mut self) -> _Pmap672W {
                _Pmap672W { w: self }
            }
            # [ doc = "Bit 3 - PMAP67_3" ]
            # [ inline ( always ) ]
            pub fn pmap67_3(&mut self) -> _Pmap673W {
                _Pmap673W { w: self }
            }
            # [ doc = "Bit 4 - PMAP67_4" ]
            # [ inline ( always ) ]
            pub fn pmap67_4(&mut self) -> _Pmap674W {
                _Pmap674W { w: self }
            }
            # [ doc = "Bit 5 - PMAP67_5" ]
            # [ inline ( always ) ]
            pub fn pmap67_5(&mut self) -> _Pmap675W {
                _Pmap675W { w: self }
            }
            # [ doc = "Bit 6 - PMAP67_6" ]
            # [ inline ( always ) ]
            pub fn pmap67_6(&mut self) -> _Pmap676W {
                _Pmap676W { w: self }
            }
            # [ doc = "Bit 7 - PMAP67_7" ]
            # [ inline ( always ) ]
            pub fn pmap67_7(&mut self) -> _Pmap677W {
                _Pmap677W { w: self }
            }
            # [ doc = "Bit 8 - PMAP67_8" ]
            # [ inline ( always ) ]
            pub fn pmap67_8(&mut self) -> _Pmap678W {
                _Pmap678W { w: self }
            }
            # [ doc = "Bit 9 - PMAP67_9" ]
            # [ inline ( always ) ]
            pub fn pmap67_9(&mut self) -> _Pmap679W {
                _Pmap679W { w: self }
            }
            # [ doc = "Bit 10 - PMAP67_10" ]
            # [ inline ( always ) ]
            pub fn pmap67_10(&mut self) -> _Pmap6710W {
                _Pmap6710W { w: self }
            }
            # [ doc = "Bit 11 - PMAP67_11" ]
            # [ inline ( always ) ]
            pub fn pmap67_11(&mut self) -> _Pmap6711W {
                _Pmap6711W { w: self }
            }
            # [ doc = "Bit 12 - PMAP67_12" ]
            # [ inline ( always ) ]
            pub fn pmap67_12(&mut self) -> _Pmap6712W {
                _Pmap6712W { w: self }
            }
            # [ doc = "Bit 13 - PMAP67_13" ]
            # [ inline ( always ) ]
            pub fn pmap67_13(&mut self) -> _Pmap6713W {
                _Pmap6713W { w: self }
            }
            # [ doc = "Bit 14 - PMAP67_14" ]
            # [ inline ( always ) ]
            pub fn pmap67_14(&mut self) -> _Pmap6714W {
                _Pmap6714W { w: self }
            }
            # [ doc = "Bit 15 - PMAP67_15" ]
            # [ inline ( always ) ]
            pub fn pmap67_15(&mut self) -> _Pmap6715W {
                _Pmap6715W { w: self }
            }
        }
    }
    # [ doc = "Port P1.0 mapping register" ]
    pub struct P1map0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.0 mapping register" ]
    pub mod p1map0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.1 mapping register" ]
    pub struct P1map1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.1 mapping register" ]
    pub mod p1map1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.2 mapping register" ]
    pub struct P1map2 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.2 mapping register" ]
    pub mod p1map2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.3 mapping register" ]
    pub struct P1map3 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.3 mapping register" ]
    pub mod p1map3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.4 mapping register" ]
    pub struct P1map4 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.4 mapping register" ]
    pub mod p1map4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.5 mapping register" ]
    pub struct P1map5 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.5 mapping register" ]
    pub mod p1map5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.6 mapping register" ]
    pub struct P1map6 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.6 mapping register" ]
    pub mod p1map6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P1.7 mapping register" ]
    pub struct P1map7 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P1.7 mapping register" ]
    pub mod p1map7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P1map7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
}
# [ doc = "Port Mapping Port 1" ]
pub struct PortMappingPort1 {
    register_block: port_mapping_port_1::RegisterBlock,
}
impl Deref for PortMappingPort1 {
    type Target = port_mapping_port_1::RegisterBlock;
    fn deref(&self) -> &port_mapping_port_1::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port Mapping Port 2" ]
pub const PORT_MAPPING_PORT_2: Peripheral<PortMappingPort2> = unsafe { Peripheral::new(0) };
# [ doc = "Port Mapping Port 2" ]
pub mod port_mapping_port_2 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 464usize],
        # [ doc = "0x1d0 - Port P2.0/1 mapping register" ]
        pub p2map01: P2map01,
        # [ doc = "0x1d2 - Port P2.2/3 mapping register" ]
        pub p2map23: P2map23,
        # [ doc = "0x1d4 - Port P2.4/5 mapping register" ]
        pub p2map45: P2map45,
        # [ doc = "0x1d6 - Port P2.6/7 mapping register" ]
        pub p2map67: P2map67,
    }
    # [ doc = "Port P2.0/1 mapping register" ]
    pub struct P2map01 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P2.0/1 mapping register" ]
    pub mod p2map01 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P2map01 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap010R {
            bits: u8,
        }
        impl Pmap010R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap011R {
            bits: u8,
        }
        impl Pmap011R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap012R {
            bits: u8,
        }
        impl Pmap012R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap013R {
            bits: u8,
        }
        impl Pmap013R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap014R {
            bits: u8,
        }
        impl Pmap014R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap015R {
            bits: u8,
        }
        impl Pmap015R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap016R {
            bits: u8,
        }
        impl Pmap016R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap017R {
            bits: u8,
        }
        impl Pmap017R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap018R {
            bits: u8,
        }
        impl Pmap018R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap019R {
            bits: u8,
        }
        impl Pmap019R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0110R {
            bits: u8,
        }
        impl Pmap0110R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0111R {
            bits: u8,
        }
        impl Pmap0111R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0112R {
            bits: u8,
        }
        impl Pmap0112R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0113R {
            bits: u8,
        }
        impl Pmap0113R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0114R {
            bits: u8,
        }
        impl Pmap0114R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0115R {
            bits: u8,
        }
        impl Pmap0115R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap010W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap010W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap011W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap011W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap012W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap012W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap013W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap013W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap014W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap014W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap015W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap015W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap016W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap016W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap017W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap017W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap018W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap018W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap019W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap019W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0110W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0110W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0111W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0111W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0112W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0112W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0113W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0113W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0114W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0114W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0115W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0115W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP01_0" ]
            # [ inline ( always ) ]
            pub fn pmap01_0(&self) -> Pmap010R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap010R { bits }
            }
            # [ doc = "Bit 1 - PMAP01_1" ]
            # [ inline ( always ) ]
            pub fn pmap01_1(&self) -> Pmap011R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap011R { bits }
            }
            # [ doc = "Bit 2 - PMAP01_2" ]
            # [ inline ( always ) ]
            pub fn pmap01_2(&self) -> Pmap012R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap012R { bits }
            }
            # [ doc = "Bit 3 - PMAP01_3" ]
            # [ inline ( always ) ]
            pub fn pmap01_3(&self) -> Pmap013R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap013R { bits }
            }
            # [ doc = "Bit 4 - PMAP01_4" ]
            # [ inline ( always ) ]
            pub fn pmap01_4(&self) -> Pmap014R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap014R { bits }
            }
            # [ doc = "Bit 5 - PMAP01_5" ]
            # [ inline ( always ) ]
            pub fn pmap01_5(&self) -> Pmap015R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap015R { bits }
            }
            # [ doc = "Bit 6 - PMAP01_6" ]
            # [ inline ( always ) ]
            pub fn pmap01_6(&self) -> Pmap016R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap016R { bits }
            }
            # [ doc = "Bit 7 - PMAP01_7" ]
            # [ inline ( always ) ]
            pub fn pmap01_7(&self) -> Pmap017R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap017R { bits }
            }
            # [ doc = "Bit 8 - PMAP01_8" ]
            # [ inline ( always ) ]
            pub fn pmap01_8(&self) -> Pmap018R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap018R { bits }
            }
            # [ doc = "Bit 9 - PMAP01_9" ]
            # [ inline ( always ) ]
            pub fn pmap01_9(&self) -> Pmap019R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap019R { bits }
            }
            # [ doc = "Bit 10 - PMAP01_10" ]
            # [ inline ( always ) ]
            pub fn pmap01_10(&self) -> Pmap0110R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0110R { bits }
            }
            # [ doc = "Bit 11 - PMAP01_11" ]
            # [ inline ( always ) ]
            pub fn pmap01_11(&self) -> Pmap0111R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0111R { bits }
            }
            # [ doc = "Bit 12 - PMAP01_12" ]
            # [ inline ( always ) ]
            pub fn pmap01_12(&self) -> Pmap0112R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0112R { bits }
            }
            # [ doc = "Bit 13 - PMAP01_13" ]
            # [ inline ( always ) ]
            pub fn pmap01_13(&self) -> Pmap0113R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0113R { bits }
            }
            # [ doc = "Bit 14 - PMAP01_14" ]
            # [ inline ( always ) ]
            pub fn pmap01_14(&self) -> Pmap0114R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0114R { bits }
            }
            # [ doc = "Bit 15 - PMAP01_15" ]
            # [ inline ( always ) ]
            pub fn pmap01_15(&self) -> Pmap0115R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0115R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP01_0" ]
            # [ inline ( always ) ]
            pub fn pmap01_0(&mut self) -> _Pmap010W {
                _Pmap010W { w: self }
            }
            # [ doc = "Bit 1 - PMAP01_1" ]
            # [ inline ( always ) ]
            pub fn pmap01_1(&mut self) -> _Pmap011W {
                _Pmap011W { w: self }
            }
            # [ doc = "Bit 2 - PMAP01_2" ]
            # [ inline ( always ) ]
            pub fn pmap01_2(&mut self) -> _Pmap012W {
                _Pmap012W { w: self }
            }
            # [ doc = "Bit 3 - PMAP01_3" ]
            # [ inline ( always ) ]
            pub fn pmap01_3(&mut self) -> _Pmap013W {
                _Pmap013W { w: self }
            }
            # [ doc = "Bit 4 - PMAP01_4" ]
            # [ inline ( always ) ]
            pub fn pmap01_4(&mut self) -> _Pmap014W {
                _Pmap014W { w: self }
            }
            # [ doc = "Bit 5 - PMAP01_5" ]
            # [ inline ( always ) ]
            pub fn pmap01_5(&mut self) -> _Pmap015W {
                _Pmap015W { w: self }
            }
            # [ doc = "Bit 6 - PMAP01_6" ]
            # [ inline ( always ) ]
            pub fn pmap01_6(&mut self) -> _Pmap016W {
                _Pmap016W { w: self }
            }
            # [ doc = "Bit 7 - PMAP01_7" ]
            # [ inline ( always ) ]
            pub fn pmap01_7(&mut self) -> _Pmap017W {
                _Pmap017W { w: self }
            }
            # [ doc = "Bit 8 - PMAP01_8" ]
            # [ inline ( always ) ]
            pub fn pmap01_8(&mut self) -> _Pmap018W {
                _Pmap018W { w: self }
            }
            # [ doc = "Bit 9 - PMAP01_9" ]
            # [ inline ( always ) ]
            pub fn pmap01_9(&mut self) -> _Pmap019W {
                _Pmap019W { w: self }
            }
            # [ doc = "Bit 10 - PMAP01_10" ]
            # [ inline ( always ) ]
            pub fn pmap01_10(&mut self) -> _Pmap0110W {
                _Pmap0110W { w: self }
            }
            # [ doc = "Bit 11 - PMAP01_11" ]
            # [ inline ( always ) ]
            pub fn pmap01_11(&mut self) -> _Pmap0111W {
                _Pmap0111W { w: self }
            }
            # [ doc = "Bit 12 - PMAP01_12" ]
            # [ inline ( always ) ]
            pub fn pmap01_12(&mut self) -> _Pmap0112W {
                _Pmap0112W { w: self }
            }
            # [ doc = "Bit 13 - PMAP01_13" ]
            # [ inline ( always ) ]
            pub fn pmap01_13(&mut self) -> _Pmap0113W {
                _Pmap0113W { w: self }
            }
            # [ doc = "Bit 14 - PMAP01_14" ]
            # [ inline ( always ) ]
            pub fn pmap01_14(&mut self) -> _Pmap0114W {
                _Pmap0114W { w: self }
            }
            # [ doc = "Bit 15 - PMAP01_15" ]
            # [ inline ( always ) ]
            pub fn pmap01_15(&mut self) -> _Pmap0115W {
                _Pmap0115W { w: self }
            }
        }
    }
    # [ doc = "Port P2.2/3 mapping register" ]
    pub struct P2map23 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P2.2/3 mapping register" ]
    pub mod p2map23 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P2map23 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap230R {
            bits: u8,
        }
        impl Pmap230R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap231R {
            bits: u8,
        }
        impl Pmap231R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap232R {
            bits: u8,
        }
        impl Pmap232R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap233R {
            bits: u8,
        }
        impl Pmap233R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap234R {
            bits: u8,
        }
        impl Pmap234R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap235R {
            bits: u8,
        }
        impl Pmap235R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap236R {
            bits: u8,
        }
        impl Pmap236R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap237R {
            bits: u8,
        }
        impl Pmap237R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap238R {
            bits: u8,
        }
        impl Pmap238R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap239R {
            bits: u8,
        }
        impl Pmap239R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2310R {
            bits: u8,
        }
        impl Pmap2310R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2311R {
            bits: u8,
        }
        impl Pmap2311R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2312R {
            bits: u8,
        }
        impl Pmap2312R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2313R {
            bits: u8,
        }
        impl Pmap2313R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2314R {
            bits: u8,
        }
        impl Pmap2314R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2315R {
            bits: u8,
        }
        impl Pmap2315R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap230W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap230W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap231W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap231W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap232W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap232W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap233W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap233W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap234W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap234W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap235W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap235W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap236W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap236W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap237W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap237W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap238W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap238W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap239W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap239W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2310W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2310W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2311W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2311W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2312W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2312W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2313W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2313W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2314W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2314W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2315W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2315W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP23_0" ]
            # [ inline ( always ) ]
            pub fn pmap23_0(&self) -> Pmap230R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap230R { bits }
            }
            # [ doc = "Bit 1 - PMAP23_1" ]
            # [ inline ( always ) ]
            pub fn pmap23_1(&self) -> Pmap231R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap231R { bits }
            }
            # [ doc = "Bit 2 - PMAP23_2" ]
            # [ inline ( always ) ]
            pub fn pmap23_2(&self) -> Pmap232R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap232R { bits }
            }
            # [ doc = "Bit 3 - PMAP23_3" ]
            # [ inline ( always ) ]
            pub fn pmap23_3(&self) -> Pmap233R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap233R { bits }
            }
            # [ doc = "Bit 4 - PMAP23_4" ]
            # [ inline ( always ) ]
            pub fn pmap23_4(&self) -> Pmap234R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap234R { bits }
            }
            # [ doc = "Bit 5 - PMAP23_5" ]
            # [ inline ( always ) ]
            pub fn pmap23_5(&self) -> Pmap235R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap235R { bits }
            }
            # [ doc = "Bit 6 - PMAP23_6" ]
            # [ inline ( always ) ]
            pub fn pmap23_6(&self) -> Pmap236R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap236R { bits }
            }
            # [ doc = "Bit 7 - PMAP23_7" ]
            # [ inline ( always ) ]
            pub fn pmap23_7(&self) -> Pmap237R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap237R { bits }
            }
            # [ doc = "Bit 8 - PMAP23_8" ]
            # [ inline ( always ) ]
            pub fn pmap23_8(&self) -> Pmap238R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap238R { bits }
            }
            # [ doc = "Bit 9 - PMAP23_9" ]
            # [ inline ( always ) ]
            pub fn pmap23_9(&self) -> Pmap239R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap239R { bits }
            }
            # [ doc = "Bit 10 - PMAP23_10" ]
            # [ inline ( always ) ]
            pub fn pmap23_10(&self) -> Pmap2310R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2310R { bits }
            }
            # [ doc = "Bit 11 - PMAP23_11" ]
            # [ inline ( always ) ]
            pub fn pmap23_11(&self) -> Pmap2311R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2311R { bits }
            }
            # [ doc = "Bit 12 - PMAP23_12" ]
            # [ inline ( always ) ]
            pub fn pmap23_12(&self) -> Pmap2312R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2312R { bits }
            }
            # [ doc = "Bit 13 - PMAP23_13" ]
            # [ inline ( always ) ]
            pub fn pmap23_13(&self) -> Pmap2313R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2313R { bits }
            }
            # [ doc = "Bit 14 - PMAP23_14" ]
            # [ inline ( always ) ]
            pub fn pmap23_14(&self) -> Pmap2314R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2314R { bits }
            }
            # [ doc = "Bit 15 - PMAP23_15" ]
            # [ inline ( always ) ]
            pub fn pmap23_15(&self) -> Pmap2315R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2315R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP23_0" ]
            # [ inline ( always ) ]
            pub fn pmap23_0(&mut self) -> _Pmap230W {
                _Pmap230W { w: self }
            }
            # [ doc = "Bit 1 - PMAP23_1" ]
            # [ inline ( always ) ]
            pub fn pmap23_1(&mut self) -> _Pmap231W {
                _Pmap231W { w: self }
            }
            # [ doc = "Bit 2 - PMAP23_2" ]
            # [ inline ( always ) ]
            pub fn pmap23_2(&mut self) -> _Pmap232W {
                _Pmap232W { w: self }
            }
            # [ doc = "Bit 3 - PMAP23_3" ]
            # [ inline ( always ) ]
            pub fn pmap23_3(&mut self) -> _Pmap233W {
                _Pmap233W { w: self }
            }
            # [ doc = "Bit 4 - PMAP23_4" ]
            # [ inline ( always ) ]
            pub fn pmap23_4(&mut self) -> _Pmap234W {
                _Pmap234W { w: self }
            }
            # [ doc = "Bit 5 - PMAP23_5" ]
            # [ inline ( always ) ]
            pub fn pmap23_5(&mut self) -> _Pmap235W {
                _Pmap235W { w: self }
            }
            # [ doc = "Bit 6 - PMAP23_6" ]
            # [ inline ( always ) ]
            pub fn pmap23_6(&mut self) -> _Pmap236W {
                _Pmap236W { w: self }
            }
            # [ doc = "Bit 7 - PMAP23_7" ]
            # [ inline ( always ) ]
            pub fn pmap23_7(&mut self) -> _Pmap237W {
                _Pmap237W { w: self }
            }
            # [ doc = "Bit 8 - PMAP23_8" ]
            # [ inline ( always ) ]
            pub fn pmap23_8(&mut self) -> _Pmap238W {
                _Pmap238W { w: self }
            }
            # [ doc = "Bit 9 - PMAP23_9" ]
            # [ inline ( always ) ]
            pub fn pmap23_9(&mut self) -> _Pmap239W {
                _Pmap239W { w: self }
            }
            # [ doc = "Bit 10 - PMAP23_10" ]
            # [ inline ( always ) ]
            pub fn pmap23_10(&mut self) -> _Pmap2310W {
                _Pmap2310W { w: self }
            }
            # [ doc = "Bit 11 - PMAP23_11" ]
            # [ inline ( always ) ]
            pub fn pmap23_11(&mut self) -> _Pmap2311W {
                _Pmap2311W { w: self }
            }
            # [ doc = "Bit 12 - PMAP23_12" ]
            # [ inline ( always ) ]
            pub fn pmap23_12(&mut self) -> _Pmap2312W {
                _Pmap2312W { w: self }
            }
            # [ doc = "Bit 13 - PMAP23_13" ]
            # [ inline ( always ) ]
            pub fn pmap23_13(&mut self) -> _Pmap2313W {
                _Pmap2313W { w: self }
            }
            # [ doc = "Bit 14 - PMAP23_14" ]
            # [ inline ( always ) ]
            pub fn pmap23_14(&mut self) -> _Pmap2314W {
                _Pmap2314W { w: self }
            }
            # [ doc = "Bit 15 - PMAP23_15" ]
            # [ inline ( always ) ]
            pub fn pmap23_15(&mut self) -> _Pmap2315W {
                _Pmap2315W { w: self }
            }
        }
    }
    # [ doc = "Port P2.4/5 mapping register" ]
    pub struct P2map45 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P2.4/5 mapping register" ]
    pub mod p2map45 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P2map45 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap450R {
            bits: u8,
        }
        impl Pmap450R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap451R {
            bits: u8,
        }
        impl Pmap451R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap452R {
            bits: u8,
        }
        impl Pmap452R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap453R {
            bits: u8,
        }
        impl Pmap453R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap454R {
            bits: u8,
        }
        impl Pmap454R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap455R {
            bits: u8,
        }
        impl Pmap455R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap456R {
            bits: u8,
        }
        impl Pmap456R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap457R {
            bits: u8,
        }
        impl Pmap457R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap458R {
            bits: u8,
        }
        impl Pmap458R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap459R {
            bits: u8,
        }
        impl Pmap459R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4510R {
            bits: u8,
        }
        impl Pmap4510R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4511R {
            bits: u8,
        }
        impl Pmap4511R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4512R {
            bits: u8,
        }
        impl Pmap4512R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4513R {
            bits: u8,
        }
        impl Pmap4513R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4514R {
            bits: u8,
        }
        impl Pmap4514R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4515R {
            bits: u8,
        }
        impl Pmap4515R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap450W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap450W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap451W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap451W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap452W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap452W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap453W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap453W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap454W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap454W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap455W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap455W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap456W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap456W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap457W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap457W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap458W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap458W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap459W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap459W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4510W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4510W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4511W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4511W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4512W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4512W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4513W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4513W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4514W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4514W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4515W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4515W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP45_0" ]
            # [ inline ( always ) ]
            pub fn pmap45_0(&self) -> Pmap450R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap450R { bits }
            }
            # [ doc = "Bit 1 - PMAP45_1" ]
            # [ inline ( always ) ]
            pub fn pmap45_1(&self) -> Pmap451R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap451R { bits }
            }
            # [ doc = "Bit 2 - PMAP45_2" ]
            # [ inline ( always ) ]
            pub fn pmap45_2(&self) -> Pmap452R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap452R { bits }
            }
            # [ doc = "Bit 3 - PMAP45_3" ]
            # [ inline ( always ) ]
            pub fn pmap45_3(&self) -> Pmap453R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap453R { bits }
            }
            # [ doc = "Bit 4 - PMAP45_4" ]
            # [ inline ( always ) ]
            pub fn pmap45_4(&self) -> Pmap454R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap454R { bits }
            }
            # [ doc = "Bit 5 - PMAP45_5" ]
            # [ inline ( always ) ]
            pub fn pmap45_5(&self) -> Pmap455R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap455R { bits }
            }
            # [ doc = "Bit 6 - PMAP45_6" ]
            # [ inline ( always ) ]
            pub fn pmap45_6(&self) -> Pmap456R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap456R { bits }
            }
            # [ doc = "Bit 7 - PMAP45_7" ]
            # [ inline ( always ) ]
            pub fn pmap45_7(&self) -> Pmap457R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap457R { bits }
            }
            # [ doc = "Bit 8 - PMAP45_8" ]
            # [ inline ( always ) ]
            pub fn pmap45_8(&self) -> Pmap458R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap458R { bits }
            }
            # [ doc = "Bit 9 - PMAP45_9" ]
            # [ inline ( always ) ]
            pub fn pmap45_9(&self) -> Pmap459R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap459R { bits }
            }
            # [ doc = "Bit 10 - PMAP45_10" ]
            # [ inline ( always ) ]
            pub fn pmap45_10(&self) -> Pmap4510R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4510R { bits }
            }
            # [ doc = "Bit 11 - PMAP45_11" ]
            # [ inline ( always ) ]
            pub fn pmap45_11(&self) -> Pmap4511R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4511R { bits }
            }
            # [ doc = "Bit 12 - PMAP45_12" ]
            # [ inline ( always ) ]
            pub fn pmap45_12(&self) -> Pmap4512R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4512R { bits }
            }
            # [ doc = "Bit 13 - PMAP45_13" ]
            # [ inline ( always ) ]
            pub fn pmap45_13(&self) -> Pmap4513R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4513R { bits }
            }
            # [ doc = "Bit 14 - PMAP45_14" ]
            # [ inline ( always ) ]
            pub fn pmap45_14(&self) -> Pmap4514R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4514R { bits }
            }
            # [ doc = "Bit 15 - PMAP45_15" ]
            # [ inline ( always ) ]
            pub fn pmap45_15(&self) -> Pmap4515R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4515R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP45_0" ]
            # [ inline ( always ) ]
            pub fn pmap45_0(&mut self) -> _Pmap450W {
                _Pmap450W { w: self }
            }
            # [ doc = "Bit 1 - PMAP45_1" ]
            # [ inline ( always ) ]
            pub fn pmap45_1(&mut self) -> _Pmap451W {
                _Pmap451W { w: self }
            }
            # [ doc = "Bit 2 - PMAP45_2" ]
            # [ inline ( always ) ]
            pub fn pmap45_2(&mut self) -> _Pmap452W {
                _Pmap452W { w: self }
            }
            # [ doc = "Bit 3 - PMAP45_3" ]
            # [ inline ( always ) ]
            pub fn pmap45_3(&mut self) -> _Pmap453W {
                _Pmap453W { w: self }
            }
            # [ doc = "Bit 4 - PMAP45_4" ]
            # [ inline ( always ) ]
            pub fn pmap45_4(&mut self) -> _Pmap454W {
                _Pmap454W { w: self }
            }
            # [ doc = "Bit 5 - PMAP45_5" ]
            # [ inline ( always ) ]
            pub fn pmap45_5(&mut self) -> _Pmap455W {
                _Pmap455W { w: self }
            }
            # [ doc = "Bit 6 - PMAP45_6" ]
            # [ inline ( always ) ]
            pub fn pmap45_6(&mut self) -> _Pmap456W {
                _Pmap456W { w: self }
            }
            # [ doc = "Bit 7 - PMAP45_7" ]
            # [ inline ( always ) ]
            pub fn pmap45_7(&mut self) -> _Pmap457W {
                _Pmap457W { w: self }
            }
            # [ doc = "Bit 8 - PMAP45_8" ]
            # [ inline ( always ) ]
            pub fn pmap45_8(&mut self) -> _Pmap458W {
                _Pmap458W { w: self }
            }
            # [ doc = "Bit 9 - PMAP45_9" ]
            # [ inline ( always ) ]
            pub fn pmap45_9(&mut self) -> _Pmap459W {
                _Pmap459W { w: self }
            }
            # [ doc = "Bit 10 - PMAP45_10" ]
            # [ inline ( always ) ]
            pub fn pmap45_10(&mut self) -> _Pmap4510W {
                _Pmap4510W { w: self }
            }
            # [ doc = "Bit 11 - PMAP45_11" ]
            # [ inline ( always ) ]
            pub fn pmap45_11(&mut self) -> _Pmap4511W {
                _Pmap4511W { w: self }
            }
            # [ doc = "Bit 12 - PMAP45_12" ]
            # [ inline ( always ) ]
            pub fn pmap45_12(&mut self) -> _Pmap4512W {
                _Pmap4512W { w: self }
            }
            # [ doc = "Bit 13 - PMAP45_13" ]
            # [ inline ( always ) ]
            pub fn pmap45_13(&mut self) -> _Pmap4513W {
                _Pmap4513W { w: self }
            }
            # [ doc = "Bit 14 - PMAP45_14" ]
            # [ inline ( always ) ]
            pub fn pmap45_14(&mut self) -> _Pmap4514W {
                _Pmap4514W { w: self }
            }
            # [ doc = "Bit 15 - PMAP45_15" ]
            # [ inline ( always ) ]
            pub fn pmap45_15(&mut self) -> _Pmap4515W {
                _Pmap4515W { w: self }
            }
        }
    }
    # [ doc = "Port P2.6/7 mapping register" ]
    pub struct P2map67 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P2.6/7 mapping register" ]
    pub mod p2map67 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P2map67 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap670R {
            bits: u8,
        }
        impl Pmap670R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap671R {
            bits: u8,
        }
        impl Pmap671R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap672R {
            bits: u8,
        }
        impl Pmap672R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap673R {
            bits: u8,
        }
        impl Pmap673R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap674R {
            bits: u8,
        }
        impl Pmap674R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap675R {
            bits: u8,
        }
        impl Pmap675R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap676R {
            bits: u8,
        }
        impl Pmap676R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap677R {
            bits: u8,
        }
        impl Pmap677R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap678R {
            bits: u8,
        }
        impl Pmap678R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap679R {
            bits: u8,
        }
        impl Pmap679R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6710R {
            bits: u8,
        }
        impl Pmap6710R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6711R {
            bits: u8,
        }
        impl Pmap6711R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6712R {
            bits: u8,
        }
        impl Pmap6712R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6713R {
            bits: u8,
        }
        impl Pmap6713R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6714R {
            bits: u8,
        }
        impl Pmap6714R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6715R {
            bits: u8,
        }
        impl Pmap6715R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap670W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap670W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap671W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap671W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap672W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap672W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap673W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap673W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap674W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap674W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap675W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap675W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap676W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap676W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap677W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap677W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap678W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap678W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap679W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap679W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6710W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6710W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6711W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6711W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6712W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6712W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6713W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6713W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6714W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6714W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6715W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6715W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP67_0" ]
            # [ inline ( always ) ]
            pub fn pmap67_0(&self) -> Pmap670R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap670R { bits }
            }
            # [ doc = "Bit 1 - PMAP67_1" ]
            # [ inline ( always ) ]
            pub fn pmap67_1(&self) -> Pmap671R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap671R { bits }
            }
            # [ doc = "Bit 2 - PMAP67_2" ]
            # [ inline ( always ) ]
            pub fn pmap67_2(&self) -> Pmap672R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap672R { bits }
            }
            # [ doc = "Bit 3 - PMAP67_3" ]
            # [ inline ( always ) ]
            pub fn pmap67_3(&self) -> Pmap673R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap673R { bits }
            }
            # [ doc = "Bit 4 - PMAP67_4" ]
            # [ inline ( always ) ]
            pub fn pmap67_4(&self) -> Pmap674R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap674R { bits }
            }
            # [ doc = "Bit 5 - PMAP67_5" ]
            # [ inline ( always ) ]
            pub fn pmap67_5(&self) -> Pmap675R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap675R { bits }
            }
            # [ doc = "Bit 6 - PMAP67_6" ]
            # [ inline ( always ) ]
            pub fn pmap67_6(&self) -> Pmap676R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap676R { bits }
            }
            # [ doc = "Bit 7 - PMAP67_7" ]
            # [ inline ( always ) ]
            pub fn pmap67_7(&self) -> Pmap677R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap677R { bits }
            }
            # [ doc = "Bit 8 - PMAP67_8" ]
            # [ inline ( always ) ]
            pub fn pmap67_8(&self) -> Pmap678R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap678R { bits }
            }
            # [ doc = "Bit 9 - PMAP67_9" ]
            # [ inline ( always ) ]
            pub fn pmap67_9(&self) -> Pmap679R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap679R { bits }
            }
            # [ doc = "Bit 10 - PMAP67_10" ]
            # [ inline ( always ) ]
            pub fn pmap67_10(&self) -> Pmap6710R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6710R { bits }
            }
            # [ doc = "Bit 11 - PMAP67_11" ]
            # [ inline ( always ) ]
            pub fn pmap67_11(&self) -> Pmap6711R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6711R { bits }
            }
            # [ doc = "Bit 12 - PMAP67_12" ]
            # [ inline ( always ) ]
            pub fn pmap67_12(&self) -> Pmap6712R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6712R { bits }
            }
            # [ doc = "Bit 13 - PMAP67_13" ]
            # [ inline ( always ) ]
            pub fn pmap67_13(&self) -> Pmap6713R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6713R { bits }
            }
            # [ doc = "Bit 14 - PMAP67_14" ]
            # [ inline ( always ) ]
            pub fn pmap67_14(&self) -> Pmap6714R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6714R { bits }
            }
            # [ doc = "Bit 15 - PMAP67_15" ]
            # [ inline ( always ) ]
            pub fn pmap67_15(&self) -> Pmap6715R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6715R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP67_0" ]
            # [ inline ( always ) ]
            pub fn pmap67_0(&mut self) -> _Pmap670W {
                _Pmap670W { w: self }
            }
            # [ doc = "Bit 1 - PMAP67_1" ]
            # [ inline ( always ) ]
            pub fn pmap67_1(&mut self) -> _Pmap671W {
                _Pmap671W { w: self }
            }
            # [ doc = "Bit 2 - PMAP67_2" ]
            # [ inline ( always ) ]
            pub fn pmap67_2(&mut self) -> _Pmap672W {
                _Pmap672W { w: self }
            }
            # [ doc = "Bit 3 - PMAP67_3" ]
            # [ inline ( always ) ]
            pub fn pmap67_3(&mut self) -> _Pmap673W {
                _Pmap673W { w: self }
            }
            # [ doc = "Bit 4 - PMAP67_4" ]
            # [ inline ( always ) ]
            pub fn pmap67_4(&mut self) -> _Pmap674W {
                _Pmap674W { w: self }
            }
            # [ doc = "Bit 5 - PMAP67_5" ]
            # [ inline ( always ) ]
            pub fn pmap67_5(&mut self) -> _Pmap675W {
                _Pmap675W { w: self }
            }
            # [ doc = "Bit 6 - PMAP67_6" ]
            # [ inline ( always ) ]
            pub fn pmap67_6(&mut self) -> _Pmap676W {
                _Pmap676W { w: self }
            }
            # [ doc = "Bit 7 - PMAP67_7" ]
            # [ inline ( always ) ]
            pub fn pmap67_7(&mut self) -> _Pmap677W {
                _Pmap677W { w: self }
            }
            # [ doc = "Bit 8 - PMAP67_8" ]
            # [ inline ( always ) ]
            pub fn pmap67_8(&mut self) -> _Pmap678W {
                _Pmap678W { w: self }
            }
            # [ doc = "Bit 9 - PMAP67_9" ]
            # [ inline ( always ) ]
            pub fn pmap67_9(&mut self) -> _Pmap679W {
                _Pmap679W { w: self }
            }
            # [ doc = "Bit 10 - PMAP67_10" ]
            # [ inline ( always ) ]
            pub fn pmap67_10(&mut self) -> _Pmap6710W {
                _Pmap6710W { w: self }
            }
            # [ doc = "Bit 11 - PMAP67_11" ]
            # [ inline ( always ) ]
            pub fn pmap67_11(&mut self) -> _Pmap6711W {
                _Pmap6711W { w: self }
            }
            # [ doc = "Bit 12 - PMAP67_12" ]
            # [ inline ( always ) ]
            pub fn pmap67_12(&mut self) -> _Pmap6712W {
                _Pmap6712W { w: self }
            }
            # [ doc = "Bit 13 - PMAP67_13" ]
            # [ inline ( always ) ]
            pub fn pmap67_13(&mut self) -> _Pmap6713W {
                _Pmap6713W { w: self }
            }
            # [ doc = "Bit 14 - PMAP67_14" ]
            # [ inline ( always ) ]
            pub fn pmap67_14(&mut self) -> _Pmap6714W {
                _Pmap6714W { w: self }
            }
            # [ doc = "Bit 15 - PMAP67_15" ]
            # [ inline ( always ) ]
            pub fn pmap67_15(&mut self) -> _Pmap6715W {
                _Pmap6715W { w: self }
            }
        }
    }
    # [ doc = "Port P2.0 mapping register" ]
    pub struct P2map0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.0 mapping register" ]
    pub mod p2map0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.1 mapping register" ]
    pub struct P2map1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.1 mapping register" ]
    pub mod p2map1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.2 mapping register" ]
    pub struct P2map2 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.2 mapping register" ]
    pub mod p2map2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.3 mapping register" ]
    pub struct P2map3 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.3 mapping register" ]
    pub mod p2map3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.4 mapping register" ]
    pub struct P2map4 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.4 mapping register" ]
    pub mod p2map4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.5 mapping register" ]
    pub struct P2map5 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.5 mapping register" ]
    pub mod p2map5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.6 mapping register" ]
    pub struct P2map6 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.6 mapping register" ]
    pub mod p2map6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P2.7 mapping register" ]
    pub struct P2map7 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P2.7 mapping register" ]
    pub mod p2map7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P2map7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
}
# [ doc = "Port Mapping Port 2" ]
pub struct PortMappingPort2 {
    register_block: port_mapping_port_2::RegisterBlock,
}
impl Deref for PortMappingPort2 {
    type Target = port_mapping_port_2::RegisterBlock;
    fn deref(&self) -> &port_mapping_port_2::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Port Mapping Port 3" ]
pub const PORT_MAPPING_PORT_3: Peripheral<PortMappingPort3> = unsafe { Peripheral::new(0) };
# [ doc = "Port Mapping Port 3" ]
pub mod port_mapping_port_3 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 472usize],
        # [ doc = "0x1d8 - Port P3.0/1 mapping register" ]
        pub p3map01: P3map01,
        # [ doc = "0x1da - Port P3.2/3 mapping register" ]
        pub p3map23: P3map23,
        # [ doc = "0x1dc - Port P3.4/5 mapping register" ]
        pub p3map45: P3map45,
        # [ doc = "0x1de - Port P3.6/7 mapping register" ]
        pub p3map67: P3map67,
    }
    # [ doc = "Port P3.0/1 mapping register" ]
    pub struct P3map01 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P3.0/1 mapping register" ]
    pub mod p3map01 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P3map01 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap010R {
            bits: u8,
        }
        impl Pmap010R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap011R {
            bits: u8,
        }
        impl Pmap011R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap012R {
            bits: u8,
        }
        impl Pmap012R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap013R {
            bits: u8,
        }
        impl Pmap013R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap014R {
            bits: u8,
        }
        impl Pmap014R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap015R {
            bits: u8,
        }
        impl Pmap015R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap016R {
            bits: u8,
        }
        impl Pmap016R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap017R {
            bits: u8,
        }
        impl Pmap017R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap018R {
            bits: u8,
        }
        impl Pmap018R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap019R {
            bits: u8,
        }
        impl Pmap019R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0110R {
            bits: u8,
        }
        impl Pmap0110R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0111R {
            bits: u8,
        }
        impl Pmap0111R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0112R {
            bits: u8,
        }
        impl Pmap0112R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0113R {
            bits: u8,
        }
        impl Pmap0113R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0114R {
            bits: u8,
        }
        impl Pmap0114R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0115R {
            bits: u8,
        }
        impl Pmap0115R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap010W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap010W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap011W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap011W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap012W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap012W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap013W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap013W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap014W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap014W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap015W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap015W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap016W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap016W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap017W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap017W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap018W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap018W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap019W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap019W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0110W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0110W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0111W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0111W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0112W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0112W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0113W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0113W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0114W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0114W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0115W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0115W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP01_0" ]
            # [ inline ( always ) ]
            pub fn pmap01_0(&self) -> Pmap010R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap010R { bits }
            }
            # [ doc = "Bit 1 - PMAP01_1" ]
            # [ inline ( always ) ]
            pub fn pmap01_1(&self) -> Pmap011R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap011R { bits }
            }
            # [ doc = "Bit 2 - PMAP01_2" ]
            # [ inline ( always ) ]
            pub fn pmap01_2(&self) -> Pmap012R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap012R { bits }
            }
            # [ doc = "Bit 3 - PMAP01_3" ]
            # [ inline ( always ) ]
            pub fn pmap01_3(&self) -> Pmap013R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap013R { bits }
            }
            # [ doc = "Bit 4 - PMAP01_4" ]
            # [ inline ( always ) ]
            pub fn pmap01_4(&self) -> Pmap014R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap014R { bits }
            }
            # [ doc = "Bit 5 - PMAP01_5" ]
            # [ inline ( always ) ]
            pub fn pmap01_5(&self) -> Pmap015R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap015R { bits }
            }
            # [ doc = "Bit 6 - PMAP01_6" ]
            # [ inline ( always ) ]
            pub fn pmap01_6(&self) -> Pmap016R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap016R { bits }
            }
            # [ doc = "Bit 7 - PMAP01_7" ]
            # [ inline ( always ) ]
            pub fn pmap01_7(&self) -> Pmap017R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap017R { bits }
            }
            # [ doc = "Bit 8 - PMAP01_8" ]
            # [ inline ( always ) ]
            pub fn pmap01_8(&self) -> Pmap018R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap018R { bits }
            }
            # [ doc = "Bit 9 - PMAP01_9" ]
            # [ inline ( always ) ]
            pub fn pmap01_9(&self) -> Pmap019R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap019R { bits }
            }
            # [ doc = "Bit 10 - PMAP01_10" ]
            # [ inline ( always ) ]
            pub fn pmap01_10(&self) -> Pmap0110R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0110R { bits }
            }
            # [ doc = "Bit 11 - PMAP01_11" ]
            # [ inline ( always ) ]
            pub fn pmap01_11(&self) -> Pmap0111R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0111R { bits }
            }
            # [ doc = "Bit 12 - PMAP01_12" ]
            # [ inline ( always ) ]
            pub fn pmap01_12(&self) -> Pmap0112R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0112R { bits }
            }
            # [ doc = "Bit 13 - PMAP01_13" ]
            # [ inline ( always ) ]
            pub fn pmap01_13(&self) -> Pmap0113R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0113R { bits }
            }
            # [ doc = "Bit 14 - PMAP01_14" ]
            # [ inline ( always ) ]
            pub fn pmap01_14(&self) -> Pmap0114R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0114R { bits }
            }
            # [ doc = "Bit 15 - PMAP01_15" ]
            # [ inline ( always ) ]
            pub fn pmap01_15(&self) -> Pmap0115R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap0115R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP01_0" ]
            # [ inline ( always ) ]
            pub fn pmap01_0(&mut self) -> _Pmap010W {
                _Pmap010W { w: self }
            }
            # [ doc = "Bit 1 - PMAP01_1" ]
            # [ inline ( always ) ]
            pub fn pmap01_1(&mut self) -> _Pmap011W {
                _Pmap011W { w: self }
            }
            # [ doc = "Bit 2 - PMAP01_2" ]
            # [ inline ( always ) ]
            pub fn pmap01_2(&mut self) -> _Pmap012W {
                _Pmap012W { w: self }
            }
            # [ doc = "Bit 3 - PMAP01_3" ]
            # [ inline ( always ) ]
            pub fn pmap01_3(&mut self) -> _Pmap013W {
                _Pmap013W { w: self }
            }
            # [ doc = "Bit 4 - PMAP01_4" ]
            # [ inline ( always ) ]
            pub fn pmap01_4(&mut self) -> _Pmap014W {
                _Pmap014W { w: self }
            }
            # [ doc = "Bit 5 - PMAP01_5" ]
            # [ inline ( always ) ]
            pub fn pmap01_5(&mut self) -> _Pmap015W {
                _Pmap015W { w: self }
            }
            # [ doc = "Bit 6 - PMAP01_6" ]
            # [ inline ( always ) ]
            pub fn pmap01_6(&mut self) -> _Pmap016W {
                _Pmap016W { w: self }
            }
            # [ doc = "Bit 7 - PMAP01_7" ]
            # [ inline ( always ) ]
            pub fn pmap01_7(&mut self) -> _Pmap017W {
                _Pmap017W { w: self }
            }
            # [ doc = "Bit 8 - PMAP01_8" ]
            # [ inline ( always ) ]
            pub fn pmap01_8(&mut self) -> _Pmap018W {
                _Pmap018W { w: self }
            }
            # [ doc = "Bit 9 - PMAP01_9" ]
            # [ inline ( always ) ]
            pub fn pmap01_9(&mut self) -> _Pmap019W {
                _Pmap019W { w: self }
            }
            # [ doc = "Bit 10 - PMAP01_10" ]
            # [ inline ( always ) ]
            pub fn pmap01_10(&mut self) -> _Pmap0110W {
                _Pmap0110W { w: self }
            }
            # [ doc = "Bit 11 - PMAP01_11" ]
            # [ inline ( always ) ]
            pub fn pmap01_11(&mut self) -> _Pmap0111W {
                _Pmap0111W { w: self }
            }
            # [ doc = "Bit 12 - PMAP01_12" ]
            # [ inline ( always ) ]
            pub fn pmap01_12(&mut self) -> _Pmap0112W {
                _Pmap0112W { w: self }
            }
            # [ doc = "Bit 13 - PMAP01_13" ]
            # [ inline ( always ) ]
            pub fn pmap01_13(&mut self) -> _Pmap0113W {
                _Pmap0113W { w: self }
            }
            # [ doc = "Bit 14 - PMAP01_14" ]
            # [ inline ( always ) ]
            pub fn pmap01_14(&mut self) -> _Pmap0114W {
                _Pmap0114W { w: self }
            }
            # [ doc = "Bit 15 - PMAP01_15" ]
            # [ inline ( always ) ]
            pub fn pmap01_15(&mut self) -> _Pmap0115W {
                _Pmap0115W { w: self }
            }
        }
    }
    # [ doc = "Port P3.2/3 mapping register" ]
    pub struct P3map23 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P3.2/3 mapping register" ]
    pub mod p3map23 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P3map23 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap230R {
            bits: u8,
        }
        impl Pmap230R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap231R {
            bits: u8,
        }
        impl Pmap231R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap232R {
            bits: u8,
        }
        impl Pmap232R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap233R {
            bits: u8,
        }
        impl Pmap233R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap234R {
            bits: u8,
        }
        impl Pmap234R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap235R {
            bits: u8,
        }
        impl Pmap235R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap236R {
            bits: u8,
        }
        impl Pmap236R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap237R {
            bits: u8,
        }
        impl Pmap237R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap238R {
            bits: u8,
        }
        impl Pmap238R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap239R {
            bits: u8,
        }
        impl Pmap239R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2310R {
            bits: u8,
        }
        impl Pmap2310R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2311R {
            bits: u8,
        }
        impl Pmap2311R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2312R {
            bits: u8,
        }
        impl Pmap2312R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2313R {
            bits: u8,
        }
        impl Pmap2313R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2314R {
            bits: u8,
        }
        impl Pmap2314R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2315R {
            bits: u8,
        }
        impl Pmap2315R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap230W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap230W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap231W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap231W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap232W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap232W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap233W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap233W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap234W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap234W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap235W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap235W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap236W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap236W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap237W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap237W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap238W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap238W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap239W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap239W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2310W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2310W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2311W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2311W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2312W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2312W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2313W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2313W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2314W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2314W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2315W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2315W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP23_0" ]
            # [ inline ( always ) ]
            pub fn pmap23_0(&self) -> Pmap230R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap230R { bits }
            }
            # [ doc = "Bit 1 - PMAP23_1" ]
            # [ inline ( always ) ]
            pub fn pmap23_1(&self) -> Pmap231R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap231R { bits }
            }
            # [ doc = "Bit 2 - PMAP23_2" ]
            # [ inline ( always ) ]
            pub fn pmap23_2(&self) -> Pmap232R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap232R { bits }
            }
            # [ doc = "Bit 3 - PMAP23_3" ]
            # [ inline ( always ) ]
            pub fn pmap23_3(&self) -> Pmap233R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap233R { bits }
            }
            # [ doc = "Bit 4 - PMAP23_4" ]
            # [ inline ( always ) ]
            pub fn pmap23_4(&self) -> Pmap234R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap234R { bits }
            }
            # [ doc = "Bit 5 - PMAP23_5" ]
            # [ inline ( always ) ]
            pub fn pmap23_5(&self) -> Pmap235R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap235R { bits }
            }
            # [ doc = "Bit 6 - PMAP23_6" ]
            # [ inline ( always ) ]
            pub fn pmap23_6(&self) -> Pmap236R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap236R { bits }
            }
            # [ doc = "Bit 7 - PMAP23_7" ]
            # [ inline ( always ) ]
            pub fn pmap23_7(&self) -> Pmap237R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap237R { bits }
            }
            # [ doc = "Bit 8 - PMAP23_8" ]
            # [ inline ( always ) ]
            pub fn pmap23_8(&self) -> Pmap238R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap238R { bits }
            }
            # [ doc = "Bit 9 - PMAP23_9" ]
            # [ inline ( always ) ]
            pub fn pmap23_9(&self) -> Pmap239R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap239R { bits }
            }
            # [ doc = "Bit 10 - PMAP23_10" ]
            # [ inline ( always ) ]
            pub fn pmap23_10(&self) -> Pmap2310R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2310R { bits }
            }
            # [ doc = "Bit 11 - PMAP23_11" ]
            # [ inline ( always ) ]
            pub fn pmap23_11(&self) -> Pmap2311R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2311R { bits }
            }
            # [ doc = "Bit 12 - PMAP23_12" ]
            # [ inline ( always ) ]
            pub fn pmap23_12(&self) -> Pmap2312R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2312R { bits }
            }
            # [ doc = "Bit 13 - PMAP23_13" ]
            # [ inline ( always ) ]
            pub fn pmap23_13(&self) -> Pmap2313R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2313R { bits }
            }
            # [ doc = "Bit 14 - PMAP23_14" ]
            # [ inline ( always ) ]
            pub fn pmap23_14(&self) -> Pmap2314R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2314R { bits }
            }
            # [ doc = "Bit 15 - PMAP23_15" ]
            # [ inline ( always ) ]
            pub fn pmap23_15(&self) -> Pmap2315R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap2315R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP23_0" ]
            # [ inline ( always ) ]
            pub fn pmap23_0(&mut self) -> _Pmap230W {
                _Pmap230W { w: self }
            }
            # [ doc = "Bit 1 - PMAP23_1" ]
            # [ inline ( always ) ]
            pub fn pmap23_1(&mut self) -> _Pmap231W {
                _Pmap231W { w: self }
            }
            # [ doc = "Bit 2 - PMAP23_2" ]
            # [ inline ( always ) ]
            pub fn pmap23_2(&mut self) -> _Pmap232W {
                _Pmap232W { w: self }
            }
            # [ doc = "Bit 3 - PMAP23_3" ]
            # [ inline ( always ) ]
            pub fn pmap23_3(&mut self) -> _Pmap233W {
                _Pmap233W { w: self }
            }
            # [ doc = "Bit 4 - PMAP23_4" ]
            # [ inline ( always ) ]
            pub fn pmap23_4(&mut self) -> _Pmap234W {
                _Pmap234W { w: self }
            }
            # [ doc = "Bit 5 - PMAP23_5" ]
            # [ inline ( always ) ]
            pub fn pmap23_5(&mut self) -> _Pmap235W {
                _Pmap235W { w: self }
            }
            # [ doc = "Bit 6 - PMAP23_6" ]
            # [ inline ( always ) ]
            pub fn pmap23_6(&mut self) -> _Pmap236W {
                _Pmap236W { w: self }
            }
            # [ doc = "Bit 7 - PMAP23_7" ]
            # [ inline ( always ) ]
            pub fn pmap23_7(&mut self) -> _Pmap237W {
                _Pmap237W { w: self }
            }
            # [ doc = "Bit 8 - PMAP23_8" ]
            # [ inline ( always ) ]
            pub fn pmap23_8(&mut self) -> _Pmap238W {
                _Pmap238W { w: self }
            }
            # [ doc = "Bit 9 - PMAP23_9" ]
            # [ inline ( always ) ]
            pub fn pmap23_9(&mut self) -> _Pmap239W {
                _Pmap239W { w: self }
            }
            # [ doc = "Bit 10 - PMAP23_10" ]
            # [ inline ( always ) ]
            pub fn pmap23_10(&mut self) -> _Pmap2310W {
                _Pmap2310W { w: self }
            }
            # [ doc = "Bit 11 - PMAP23_11" ]
            # [ inline ( always ) ]
            pub fn pmap23_11(&mut self) -> _Pmap2311W {
                _Pmap2311W { w: self }
            }
            # [ doc = "Bit 12 - PMAP23_12" ]
            # [ inline ( always ) ]
            pub fn pmap23_12(&mut self) -> _Pmap2312W {
                _Pmap2312W { w: self }
            }
            # [ doc = "Bit 13 - PMAP23_13" ]
            # [ inline ( always ) ]
            pub fn pmap23_13(&mut self) -> _Pmap2313W {
                _Pmap2313W { w: self }
            }
            # [ doc = "Bit 14 - PMAP23_14" ]
            # [ inline ( always ) ]
            pub fn pmap23_14(&mut self) -> _Pmap2314W {
                _Pmap2314W { w: self }
            }
            # [ doc = "Bit 15 - PMAP23_15" ]
            # [ inline ( always ) ]
            pub fn pmap23_15(&mut self) -> _Pmap2315W {
                _Pmap2315W { w: self }
            }
        }
    }
    # [ doc = "Port P3.4/5 mapping register" ]
    pub struct P3map45 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P3.4/5 mapping register" ]
    pub mod p3map45 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P3map45 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap450R {
            bits: u8,
        }
        impl Pmap450R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap451R {
            bits: u8,
        }
        impl Pmap451R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap452R {
            bits: u8,
        }
        impl Pmap452R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap453R {
            bits: u8,
        }
        impl Pmap453R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap454R {
            bits: u8,
        }
        impl Pmap454R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap455R {
            bits: u8,
        }
        impl Pmap455R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap456R {
            bits: u8,
        }
        impl Pmap456R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap457R {
            bits: u8,
        }
        impl Pmap457R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap458R {
            bits: u8,
        }
        impl Pmap458R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap459R {
            bits: u8,
        }
        impl Pmap459R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4510R {
            bits: u8,
        }
        impl Pmap4510R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4511R {
            bits: u8,
        }
        impl Pmap4511R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4512R {
            bits: u8,
        }
        impl Pmap4512R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4513R {
            bits: u8,
        }
        impl Pmap4513R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4514R {
            bits: u8,
        }
        impl Pmap4514R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4515R {
            bits: u8,
        }
        impl Pmap4515R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap450W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap450W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap451W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap451W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap452W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap452W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap453W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap453W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap454W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap454W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap455W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap455W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap456W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap456W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap457W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap457W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap458W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap458W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap459W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap459W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4510W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4510W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4511W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4511W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4512W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4512W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4513W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4513W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4514W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4514W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4515W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4515W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP45_0" ]
            # [ inline ( always ) ]
            pub fn pmap45_0(&self) -> Pmap450R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap450R { bits }
            }
            # [ doc = "Bit 1 - PMAP45_1" ]
            # [ inline ( always ) ]
            pub fn pmap45_1(&self) -> Pmap451R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap451R { bits }
            }
            # [ doc = "Bit 2 - PMAP45_2" ]
            # [ inline ( always ) ]
            pub fn pmap45_2(&self) -> Pmap452R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap452R { bits }
            }
            # [ doc = "Bit 3 - PMAP45_3" ]
            # [ inline ( always ) ]
            pub fn pmap45_3(&self) -> Pmap453R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap453R { bits }
            }
            # [ doc = "Bit 4 - PMAP45_4" ]
            # [ inline ( always ) ]
            pub fn pmap45_4(&self) -> Pmap454R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap454R { bits }
            }
            # [ doc = "Bit 5 - PMAP45_5" ]
            # [ inline ( always ) ]
            pub fn pmap45_5(&self) -> Pmap455R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap455R { bits }
            }
            # [ doc = "Bit 6 - PMAP45_6" ]
            # [ inline ( always ) ]
            pub fn pmap45_6(&self) -> Pmap456R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap456R { bits }
            }
            # [ doc = "Bit 7 - PMAP45_7" ]
            # [ inline ( always ) ]
            pub fn pmap45_7(&self) -> Pmap457R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap457R { bits }
            }
            # [ doc = "Bit 8 - PMAP45_8" ]
            # [ inline ( always ) ]
            pub fn pmap45_8(&self) -> Pmap458R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap458R { bits }
            }
            # [ doc = "Bit 9 - PMAP45_9" ]
            # [ inline ( always ) ]
            pub fn pmap45_9(&self) -> Pmap459R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap459R { bits }
            }
            # [ doc = "Bit 10 - PMAP45_10" ]
            # [ inline ( always ) ]
            pub fn pmap45_10(&self) -> Pmap4510R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4510R { bits }
            }
            # [ doc = "Bit 11 - PMAP45_11" ]
            # [ inline ( always ) ]
            pub fn pmap45_11(&self) -> Pmap4511R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4511R { bits }
            }
            # [ doc = "Bit 12 - PMAP45_12" ]
            # [ inline ( always ) ]
            pub fn pmap45_12(&self) -> Pmap4512R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4512R { bits }
            }
            # [ doc = "Bit 13 - PMAP45_13" ]
            # [ inline ( always ) ]
            pub fn pmap45_13(&self) -> Pmap4513R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4513R { bits }
            }
            # [ doc = "Bit 14 - PMAP45_14" ]
            # [ inline ( always ) ]
            pub fn pmap45_14(&self) -> Pmap4514R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4514R { bits }
            }
            # [ doc = "Bit 15 - PMAP45_15" ]
            # [ inline ( always ) ]
            pub fn pmap45_15(&self) -> Pmap4515R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap4515R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP45_0" ]
            # [ inline ( always ) ]
            pub fn pmap45_0(&mut self) -> _Pmap450W {
                _Pmap450W { w: self }
            }
            # [ doc = "Bit 1 - PMAP45_1" ]
            # [ inline ( always ) ]
            pub fn pmap45_1(&mut self) -> _Pmap451W {
                _Pmap451W { w: self }
            }
            # [ doc = "Bit 2 - PMAP45_2" ]
            # [ inline ( always ) ]
            pub fn pmap45_2(&mut self) -> _Pmap452W {
                _Pmap452W { w: self }
            }
            # [ doc = "Bit 3 - PMAP45_3" ]
            # [ inline ( always ) ]
            pub fn pmap45_3(&mut self) -> _Pmap453W {
                _Pmap453W { w: self }
            }
            # [ doc = "Bit 4 - PMAP45_4" ]
            # [ inline ( always ) ]
            pub fn pmap45_4(&mut self) -> _Pmap454W {
                _Pmap454W { w: self }
            }
            # [ doc = "Bit 5 - PMAP45_5" ]
            # [ inline ( always ) ]
            pub fn pmap45_5(&mut self) -> _Pmap455W {
                _Pmap455W { w: self }
            }
            # [ doc = "Bit 6 - PMAP45_6" ]
            # [ inline ( always ) ]
            pub fn pmap45_6(&mut self) -> _Pmap456W {
                _Pmap456W { w: self }
            }
            # [ doc = "Bit 7 - PMAP45_7" ]
            # [ inline ( always ) ]
            pub fn pmap45_7(&mut self) -> _Pmap457W {
                _Pmap457W { w: self }
            }
            # [ doc = "Bit 8 - PMAP45_8" ]
            # [ inline ( always ) ]
            pub fn pmap45_8(&mut self) -> _Pmap458W {
                _Pmap458W { w: self }
            }
            # [ doc = "Bit 9 - PMAP45_9" ]
            # [ inline ( always ) ]
            pub fn pmap45_9(&mut self) -> _Pmap459W {
                _Pmap459W { w: self }
            }
            # [ doc = "Bit 10 - PMAP45_10" ]
            # [ inline ( always ) ]
            pub fn pmap45_10(&mut self) -> _Pmap4510W {
                _Pmap4510W { w: self }
            }
            # [ doc = "Bit 11 - PMAP45_11" ]
            # [ inline ( always ) ]
            pub fn pmap45_11(&mut self) -> _Pmap4511W {
                _Pmap4511W { w: self }
            }
            # [ doc = "Bit 12 - PMAP45_12" ]
            # [ inline ( always ) ]
            pub fn pmap45_12(&mut self) -> _Pmap4512W {
                _Pmap4512W { w: self }
            }
            # [ doc = "Bit 13 - PMAP45_13" ]
            # [ inline ( always ) ]
            pub fn pmap45_13(&mut self) -> _Pmap4513W {
                _Pmap4513W { w: self }
            }
            # [ doc = "Bit 14 - PMAP45_14" ]
            # [ inline ( always ) ]
            pub fn pmap45_14(&mut self) -> _Pmap4514W {
                _Pmap4514W { w: self }
            }
            # [ doc = "Bit 15 - PMAP45_15" ]
            # [ inline ( always ) ]
            pub fn pmap45_15(&mut self) -> _Pmap4515W {
                _Pmap4515W { w: self }
            }
        }
    }
    # [ doc = "Port P3.6/7 mapping register" ]
    pub struct P3map67 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Port P3.6/7 mapping register" ]
    pub mod p3map67 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::P3map67 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap670R {
            bits: u8,
        }
        impl Pmap670R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap671R {
            bits: u8,
        }
        impl Pmap671R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap672R {
            bits: u8,
        }
        impl Pmap672R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap673R {
            bits: u8,
        }
        impl Pmap673R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap674R {
            bits: u8,
        }
        impl Pmap674R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap675R {
            bits: u8,
        }
        impl Pmap675R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap676R {
            bits: u8,
        }
        impl Pmap676R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap677R {
            bits: u8,
        }
        impl Pmap677R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap678R {
            bits: u8,
        }
        impl Pmap678R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap679R {
            bits: u8,
        }
        impl Pmap679R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6710R {
            bits: u8,
        }
        impl Pmap6710R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6711R {
            bits: u8,
        }
        impl Pmap6711R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6712R {
            bits: u8,
        }
        impl Pmap6712R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6713R {
            bits: u8,
        }
        impl Pmap6713R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6714R {
            bits: u8,
        }
        impl Pmap6714R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6715R {
            bits: u8,
        }
        impl Pmap6715R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap670W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap670W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap671W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap671W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap672W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap672W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap673W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap673W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap674W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap674W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap675W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap675W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap676W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap676W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap677W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap677W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap678W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap678W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap679W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap679W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6710W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6710W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6711W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6711W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6712W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6712W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6713W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6713W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6714W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6714W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6715W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6715W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP67_0" ]
            # [ inline ( always ) ]
            pub fn pmap67_0(&self) -> Pmap670R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap670R { bits }
            }
            # [ doc = "Bit 1 - PMAP67_1" ]
            # [ inline ( always ) ]
            pub fn pmap67_1(&self) -> Pmap671R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap671R { bits }
            }
            # [ doc = "Bit 2 - PMAP67_2" ]
            # [ inline ( always ) ]
            pub fn pmap67_2(&self) -> Pmap672R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap672R { bits }
            }
            # [ doc = "Bit 3 - PMAP67_3" ]
            # [ inline ( always ) ]
            pub fn pmap67_3(&self) -> Pmap673R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap673R { bits }
            }
            # [ doc = "Bit 4 - PMAP67_4" ]
            # [ inline ( always ) ]
            pub fn pmap67_4(&self) -> Pmap674R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap674R { bits }
            }
            # [ doc = "Bit 5 - PMAP67_5" ]
            # [ inline ( always ) ]
            pub fn pmap67_5(&self) -> Pmap675R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap675R { bits }
            }
            # [ doc = "Bit 6 - PMAP67_6" ]
            # [ inline ( always ) ]
            pub fn pmap67_6(&self) -> Pmap676R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap676R { bits }
            }
            # [ doc = "Bit 7 - PMAP67_7" ]
            # [ inline ( always ) ]
            pub fn pmap67_7(&self) -> Pmap677R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap677R { bits }
            }
            # [ doc = "Bit 8 - PMAP67_8" ]
            # [ inline ( always ) ]
            pub fn pmap67_8(&self) -> Pmap678R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap678R { bits }
            }
            # [ doc = "Bit 9 - PMAP67_9" ]
            # [ inline ( always ) ]
            pub fn pmap67_9(&self) -> Pmap679R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap679R { bits }
            }
            # [ doc = "Bit 10 - PMAP67_10" ]
            # [ inline ( always ) ]
            pub fn pmap67_10(&self) -> Pmap6710R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6710R { bits }
            }
            # [ doc = "Bit 11 - PMAP67_11" ]
            # [ inline ( always ) ]
            pub fn pmap67_11(&self) -> Pmap6711R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6711R { bits }
            }
            # [ doc = "Bit 12 - PMAP67_12" ]
            # [ inline ( always ) ]
            pub fn pmap67_12(&self) -> Pmap6712R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6712R { bits }
            }
            # [ doc = "Bit 13 - PMAP67_13" ]
            # [ inline ( always ) ]
            pub fn pmap67_13(&self) -> Pmap6713R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6713R { bits }
            }
            # [ doc = "Bit 14 - PMAP67_14" ]
            # [ inline ( always ) ]
            pub fn pmap67_14(&self) -> Pmap6714R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6714R { bits }
            }
            # [ doc = "Bit 15 - PMAP67_15" ]
            # [ inline ( always ) ]
            pub fn pmap67_15(&self) -> Pmap6715R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmap6715R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP67_0" ]
            # [ inline ( always ) ]
            pub fn pmap67_0(&mut self) -> _Pmap670W {
                _Pmap670W { w: self }
            }
            # [ doc = "Bit 1 - PMAP67_1" ]
            # [ inline ( always ) ]
            pub fn pmap67_1(&mut self) -> _Pmap671W {
                _Pmap671W { w: self }
            }
            # [ doc = "Bit 2 - PMAP67_2" ]
            # [ inline ( always ) ]
            pub fn pmap67_2(&mut self) -> _Pmap672W {
                _Pmap672W { w: self }
            }
            # [ doc = "Bit 3 - PMAP67_3" ]
            # [ inline ( always ) ]
            pub fn pmap67_3(&mut self) -> _Pmap673W {
                _Pmap673W { w: self }
            }
            # [ doc = "Bit 4 - PMAP67_4" ]
            # [ inline ( always ) ]
            pub fn pmap67_4(&mut self) -> _Pmap674W {
                _Pmap674W { w: self }
            }
            # [ doc = "Bit 5 - PMAP67_5" ]
            # [ inline ( always ) ]
            pub fn pmap67_5(&mut self) -> _Pmap675W {
                _Pmap675W { w: self }
            }
            # [ doc = "Bit 6 - PMAP67_6" ]
            # [ inline ( always ) ]
            pub fn pmap67_6(&mut self) -> _Pmap676W {
                _Pmap676W { w: self }
            }
            # [ doc = "Bit 7 - PMAP67_7" ]
            # [ inline ( always ) ]
            pub fn pmap67_7(&mut self) -> _Pmap677W {
                _Pmap677W { w: self }
            }
            # [ doc = "Bit 8 - PMAP67_8" ]
            # [ inline ( always ) ]
            pub fn pmap67_8(&mut self) -> _Pmap678W {
                _Pmap678W { w: self }
            }
            # [ doc = "Bit 9 - PMAP67_9" ]
            # [ inline ( always ) ]
            pub fn pmap67_9(&mut self) -> _Pmap679W {
                _Pmap679W { w: self }
            }
            # [ doc = "Bit 10 - PMAP67_10" ]
            # [ inline ( always ) ]
            pub fn pmap67_10(&mut self) -> _Pmap6710W {
                _Pmap6710W { w: self }
            }
            # [ doc = "Bit 11 - PMAP67_11" ]
            # [ inline ( always ) ]
            pub fn pmap67_11(&mut self) -> _Pmap6711W {
                _Pmap6711W { w: self }
            }
            # [ doc = "Bit 12 - PMAP67_12" ]
            # [ inline ( always ) ]
            pub fn pmap67_12(&mut self) -> _Pmap6712W {
                _Pmap6712W { w: self }
            }
            # [ doc = "Bit 13 - PMAP67_13" ]
            # [ inline ( always ) ]
            pub fn pmap67_13(&mut self) -> _Pmap6713W {
                _Pmap6713W { w: self }
            }
            # [ doc = "Bit 14 - PMAP67_14" ]
            # [ inline ( always ) ]
            pub fn pmap67_14(&mut self) -> _Pmap6714W {
                _Pmap6714W { w: self }
            }
            # [ doc = "Bit 15 - PMAP67_15" ]
            # [ inline ( always ) ]
            pub fn pmap67_15(&mut self) -> _Pmap6715W {
                _Pmap6715W { w: self }
            }
        }
    }
    # [ doc = "Port P3.0 mapping register" ]
    pub struct P3map0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.0 mapping register" ]
    pub mod p3map0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.1 mapping register" ]
    pub struct P3map1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.1 mapping register" ]
    pub mod p3map1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.2 mapping register" ]
    pub struct P3map2 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.2 mapping register" ]
    pub mod p3map2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.3 mapping register" ]
    pub struct P3map3 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.3 mapping register" ]
    pub mod p3map3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.4 mapping register" ]
    pub struct P3map4 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.4 mapping register" ]
    pub mod p3map4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.5 mapping register" ]
    pub struct P3map5 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.5 mapping register" ]
    pub mod p3map5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.6 mapping register" ]
    pub struct P3map6 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.6 mapping register" ]
    pub mod p3map6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
    # [ doc = "Port P3.7 mapping register" ]
    pub struct P3map7 {
        register: VolatileCell<u8>,
    }
    # [ doc = "Port P3.7 mapping register" ]
    pub mod p3map7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::P3map7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap0R {
            bits: u8,
        }
        impl Pmap0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap1R {
            bits: u8,
        }
        impl Pmap1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap2R {
            bits: u8,
        }
        impl Pmap2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap3R {
            bits: u8,
        }
        impl Pmap3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap4R {
            bits: u8,
        }
        impl Pmap4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap5R {
            bits: u8,
        }
        impl Pmap5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap6R {
            bits: u8,
        }
        impl Pmap6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmap7R {
            bits: u8,
        }
        impl Pmap7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmap7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmap7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&self) -> Pmap0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap0R { bits }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&self) -> Pmap1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap1R { bits }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&self) -> Pmap2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap2R { bits }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&self) -> Pmap3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap3R { bits }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&self) -> Pmap4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap4R { bits }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&self) -> Pmap5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap5R { bits }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&self) -> Pmap6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap6R { bits }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&self) -> Pmap7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Pmap7R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMAP0" ]
            # [ inline ( always ) ]
            pub fn pmap0(&mut self) -> _Pmap0W {
                _Pmap0W { w: self }
            }
            # [ doc = "Bit 1 - PMAP1" ]
            # [ inline ( always ) ]
            pub fn pmap1(&mut self) -> _Pmap1W {
                _Pmap1W { w: self }
            }
            # [ doc = "Bit 2 - PMAP2" ]
            # [ inline ( always ) ]
            pub fn pmap2(&mut self) -> _Pmap2W {
                _Pmap2W { w: self }
            }
            # [ doc = "Bit 3 - PMAP3" ]
            # [ inline ( always ) ]
            pub fn pmap3(&mut self) -> _Pmap3W {
                _Pmap3W { w: self }
            }
            # [ doc = "Bit 4 - PMAP4" ]
            # [ inline ( always ) ]
            pub fn pmap4(&mut self) -> _Pmap4W {
                _Pmap4W { w: self }
            }
            # [ doc = "Bit 5 - PMAP5" ]
            # [ inline ( always ) ]
            pub fn pmap5(&mut self) -> _Pmap5W {
                _Pmap5W { w: self }
            }
            # [ doc = "Bit 6 - PMAP6" ]
            # [ inline ( always ) ]
            pub fn pmap6(&mut self) -> _Pmap6W {
                _Pmap6W { w: self }
            }
            # [ doc = "Bit 7 - PMAP7" ]
            # [ inline ( always ) ]
            pub fn pmap7(&mut self) -> _Pmap7W {
                _Pmap7W { w: self }
            }
        }
    }
}
# [ doc = "Port Mapping Port 3" ]
pub struct PortMappingPort3 {
    register_block: port_mapping_port_3::RegisterBlock,
}
impl Deref for PortMappingPort3 {
    type Target = port_mapping_port_3::RegisterBlock;
    fn deref(&self) -> &port_mapping_port_3::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "PMM Power Management System" ]
pub const PMM_POWER_MANAGEMENT_SYSTEM: Peripheral<PmmPowerManagementSystem> =
    unsafe { Peripheral::new(0) };
# [ doc = "PMM Power Management System" ]
pub mod pmm_power_management_system {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 288usize],
        # [ doc = "0x120 - PMM Control 0" ]
        pub pmmctl0: Pmmctl0,
        # [ doc = "0x122 - PMM Control 1" ]
        pub pmmctl1: Pmmctl1,
        # [ doc = "0x124 - SVS and SVM high side control register" ]
        pub svsmhctl: Svsmhctl,
        # [ doc = "0x126 - SVS and SVM low side control register" ]
        pub svsmlctl: Svsmlctl,
        # [ doc = "0x128 - SVSIN and SVSOUT control register" ]
        pub svsmio: Svsmio,
        _reserved1: [u8; 2usize],
        # [ doc = "0x12c - PMM Interrupt Flag" ]
        pub pmmifg: Pmmifg,
        # [ doc = "0x12e - PMM and RESET Interrupt Enable" ]
        pub pmmrie: Pmmrie,
        # [ doc = "0x130 - PMM Power Mode 5 Control Register 0" ]
        pub pm5ctl0: Pm5ctl0,
    }
    # [ doc = "PMM Control 0" ]
    pub struct Pmmctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "PMM Control 0" ]
    pub mod pmmctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pmmctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `PMMCOREV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum PmmcorevR {
            # [ doc = "PMM Core Voltage 0 (1.35V)" ]
            Pmmcorev0,
            # [ doc = "PMM Core Voltage 1 (1.55V)" ]
            Pmmcorev1,
            # [ doc = "PMM Core Voltage 2 (1.75V)" ]
            Pmmcorev2,
            # [ doc = "PMM Core Voltage 3 (1.85V)" ]
            Pmmcorev3,
        }
        impl PmmcorevR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    PmmcorevR::Pmmcorev0 => 0,
                    PmmcorevR::Pmmcorev1 => 1,
                    PmmcorevR::Pmmcorev2 => 2,
                    PmmcorevR::Pmmcorev3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> PmmcorevR {
                match bits {
                    0 => PmmcorevR::Pmmcorev0,
                    1 => PmmcorevR::Pmmcorev1,
                    2 => PmmcorevR::Pmmcorev2,
                    3 => PmmcorevR::Pmmcorev3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Pmmcorev0`" ]
            # [ inline ( always ) ]
            pub fn is_pmmcorev_0(&self) -> bool {
                *self == PmmcorevR::Pmmcorev0
            }
            # [ doc = "Checks if the value of the field is `Pmmcorev1`" ]
            # [ inline ( always ) ]
            pub fn is_pmmcorev_1(&self) -> bool {
                *self == PmmcorevR::Pmmcorev1
            }
            # [ doc = "Checks if the value of the field is `Pmmcorev2`" ]
            # [ inline ( always ) ]
            pub fn is_pmmcorev_2(&self) -> bool {
                *self == PmmcorevR::Pmmcorev2
            }
            # [ doc = "Checks if the value of the field is `Pmmcorev3`" ]
            # [ inline ( always ) ]
            pub fn is_pmmcorev_3(&self) -> bool {
                *self == PmmcorevR::Pmmcorev3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmswborR {
            bits: u8,
        }
        impl PmmswborR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmswporR {
            bits: u8,
        }
        impl PmmswporR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmregoffR {
            bits: u8,
        }
        impl PmmregoffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmhpmreR {
            bits: u8,
        }
        impl PmmhpmreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `PMMCOREV`" ]
        pub enum PmmcorevW {
            # [ doc = "PMM Core Voltage 0 (1.35V)" ]
            Pmmcorev0,
            # [ doc = "PMM Core Voltage 1 (1.55V)" ]
            Pmmcorev1,
            # [ doc = "PMM Core Voltage 2 (1.75V)" ]
            Pmmcorev2,
            # [ doc = "PMM Core Voltage 3 (1.85V)" ]
            Pmmcorev3,
        }
        impl PmmcorevW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PmmcorevW::Pmmcorev0 => 0,
                    PmmcorevW::Pmmcorev1 => 1,
                    PmmcorevW::Pmmcorev2 => 2,
                    PmmcorevW::Pmmcorev3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmcorevW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmcorevW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: PmmcorevW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PMM Core Voltage 0 (1.35V)" ]
            # [ inline ( always ) ]
            pub fn pmmcorev_0(self) -> &'a mut W {
                self.variant(PmmcorevW::Pmmcorev0)
            }
            # [ doc = "PMM Core Voltage 1 (1.55V)" ]
            # [ inline ( always ) ]
            pub fn pmmcorev_1(self) -> &'a mut W {
                self.variant(PmmcorevW::Pmmcorev1)
            }
            # [ doc = "PMM Core Voltage 2 (1.75V)" ]
            # [ inline ( always ) ]
            pub fn pmmcorev_2(self) -> &'a mut W {
                self.variant(PmmcorevW::Pmmcorev2)
            }
            # [ doc = "PMM Core Voltage 3 (1.85V)" ]
            # [ inline ( always ) ]
            pub fn pmmcorev_3(self) -> &'a mut W {
                self.variant(PmmcorevW::Pmmcorev3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmswborW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmswborW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmswporW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmswporW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmregoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmregoffW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmhpmreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmhpmreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 1:2 - PMM Core Voltage Bit: 0" ]
            # [ inline ( always ) ]
            pub fn pmmcorev(&self) -> PmmcorevR {
                PmmcorevR::_from({
                                     const MASK: u8 = 3;
                                     const OFFSET: u8 = 1;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bit 2 - PMM Software BOR" ]
            # [ inline ( always ) ]
            pub fn pmmswbor(&self) -> PmmswborR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmswborR { bits }
            }
            # [ doc = "Bit 3 - PMM Software POR" ]
            # [ inline ( always ) ]
            pub fn pmmswpor(&self) -> PmmswporR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmswporR { bits }
            }
            # [ doc = "Bit 4 - PMM Turn Regulator off" ]
            # [ inline ( always ) ]
            pub fn pmmregoff(&self) -> PmmregoffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmregoffR { bits }
            }
            # [ doc = "Bit 7 - PMM Global High Power Module Request Enable" ]
            # [ inline ( always ) ]
            pub fn pmmhpmre(&self) -> PmmhpmreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmhpmreR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 1:2 - PMM Core Voltage Bit: 0" ]
            # [ inline ( always ) ]
            pub fn pmmcorev(&mut self) -> _PmmcorevW {
                _PmmcorevW { w: self }
            }
            # [ doc = "Bit 2 - PMM Software BOR" ]
            # [ inline ( always ) ]
            pub fn pmmswbor(&mut self) -> _PmmswborW {
                _PmmswborW { w: self }
            }
            # [ doc = "Bit 3 - PMM Software POR" ]
            # [ inline ( always ) ]
            pub fn pmmswpor(&mut self) -> _PmmswporW {
                _PmmswporW { w: self }
            }
            # [ doc = "Bit 4 - PMM Turn Regulator off" ]
            # [ inline ( always ) ]
            pub fn pmmregoff(&mut self) -> _PmmregoffW {
                _PmmregoffW { w: self }
            }
            # [ doc = "Bit 7 - PMM Global High Power Module Request Enable" ]
            # [ inline ( always ) ]
            pub fn pmmhpmre(&mut self) -> _PmmhpmreW {
                _PmmhpmreW { w: self }
            }
        }
    }
    # [ doc = "PMM Control 1" ]
    pub struct Pmmctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "PMM Control 1" ]
    pub mod pmmctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pmmctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmrefmdR {
            bits: u8,
        }
        impl PmmrefmdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmmcmd0R {
            bits: u8,
        }
        impl Pmmcmd0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmmcmd1R {
            bits: u8,
        }
        impl Pmmcmd1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmrefmdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmrefmdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmmcmd0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmmcmd0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmmcmd1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmmcmd1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - PMM Reference Mode" ]
            # [ inline ( always ) ]
            pub fn pmmrefmd(&self) -> PmmrefmdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmrefmdR { bits }
            }
            # [ doc = "Bit 4 - PMM Voltage Regulator Current Mode Bit: 0" ]
            # [ inline ( always ) ]
            pub fn pmmcmd0(&self) -> Pmmcmd0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmmcmd0R { bits }
            }
            # [ doc = "Bit 5 - PMM Voltage Regulator Current Mode Bit: 1" ]
            # [ inline ( always ) ]
            pub fn pmmcmd1(&self) -> Pmmcmd1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmmcmd1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - PMM Reference Mode" ]
            # [ inline ( always ) ]
            pub fn pmmrefmd(&mut self) -> _PmmrefmdW {
                _PmmrefmdW { w: self }
            }
            # [ doc = "Bit 4 - PMM Voltage Regulator Current Mode Bit: 0" ]
            # [ inline ( always ) ]
            pub fn pmmcmd0(&mut self) -> _Pmmcmd0W {
                _Pmmcmd0W { w: self }
            }
            # [ doc = "Bit 5 - PMM Voltage Regulator Current Mode Bit: 1" ]
            # [ inline ( always ) ]
            pub fn pmmcmd1(&mut self) -> _Pmmcmd1W {
                _Pmmcmd1W { w: self }
            }
        }
    }
    # [ doc = "SVS and SVM high side control register" ]
    pub struct Svsmhctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "SVS and SVM high side control register" ]
    pub mod svsmhctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Svsmhctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SVSMHRRL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SvsmhrrlR {
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 0" ]
            Svsmhrrl0,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 1" ]
            Svsmhrrl1,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 2" ]
            Svsmhrrl2,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 3" ]
            Svsmhrrl3,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 4" ]
            Svsmhrrl4,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 5" ]
            Svsmhrrl5,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 6" ]
            Svsmhrrl6,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 7" ]
            Svsmhrrl7,
        }
        impl SvsmhrrlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SvsmhrrlR::Svsmhrrl0 => 0,
                    SvsmhrrlR::Svsmhrrl1 => 1,
                    SvsmhrrlR::Svsmhrrl2 => 2,
                    SvsmhrrlR::Svsmhrrl3 => 3,
                    SvsmhrrlR::Svsmhrrl4 => 4,
                    SvsmhrrlR::Svsmhrrl5 => 5,
                    SvsmhrrlR::Svsmhrrl6 => 6,
                    SvsmhrrlR::Svsmhrrl7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SvsmhrrlR {
                match bits {
                    0 => SvsmhrrlR::Svsmhrrl0,
                    1 => SvsmhrrlR::Svsmhrrl1,
                    2 => SvsmhrrlR::Svsmhrrl2,
                    3 => SvsmhrrlR::Svsmhrrl3,
                    4 => SvsmhrrlR::Svsmhrrl4,
                    5 => SvsmhrrlR::Svsmhrrl5,
                    6 => SvsmhrrlR::Svsmhrrl6,
                    7 => SvsmhrrlR::Svsmhrrl7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl0`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_0(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl0
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl1`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_1(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl1
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl2`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_2(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl2
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl3`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_3(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl3
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl4`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_4(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl4
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl5`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_5(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl5
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl6`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_6(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl6
            }
            # [ doc = "Checks if the value of the field is `Svsmhrrl7`" ]
            # [ inline ( always ) ]
            pub fn is_svsmhrrl_7(&self) -> bool {
                *self == SvsmhrrlR::Svsmhrrl7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmhdlystR {
            bits: u8,
        }
        impl SvsmhdlystR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvshmdR {
            bits: u8,
        }
        impl SvshmdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmhevmR {
            bits: u8,
        }
        impl SvsmhevmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmhaceR {
            bits: u8,
        }
        impl SvsmhaceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `SVSHRVL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SvshrvlR {
            # [ doc = "SVS high side Reset Release Voltage Level 0" ]
            Svshrvl0,
            # [ doc = "SVS high side Reset Release Voltage Level 1" ]
            Svshrvl1,
            # [ doc = "SVS high side Reset Release Voltage Level 2" ]
            Svshrvl2,
            # [ doc = "SVS high side Reset Release Voltage Level 3" ]
            Svshrvl3,
        }
        impl SvshrvlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SvshrvlR::Svshrvl0 => 0,
                    SvshrvlR::Svshrvl1 => 1,
                    SvshrvlR::Svshrvl2 => 2,
                    SvshrvlR::Svshrvl3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SvshrvlR {
                match bits {
                    0 => SvshrvlR::Svshrvl0,
                    1 => SvshrvlR::Svshrvl1,
                    2 => SvshrvlR::Svshrvl2,
                    3 => SvshrvlR::Svshrvl3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Svshrvl0`" ]
            # [ inline ( always ) ]
            pub fn is_svshrvl_0(&self) -> bool {
                *self == SvshrvlR::Svshrvl0
            }
            # [ doc = "Checks if the value of the field is `Svshrvl1`" ]
            # [ inline ( always ) ]
            pub fn is_svshrvl_1(&self) -> bool {
                *self == SvshrvlR::Svshrvl1
            }
            # [ doc = "Checks if the value of the field is `Svshrvl2`" ]
            # [ inline ( always ) ]
            pub fn is_svshrvl_2(&self) -> bool {
                *self == SvshrvlR::Svshrvl2
            }
            # [ doc = "Checks if the value of the field is `Svshrvl3`" ]
            # [ inline ( always ) ]
            pub fn is_svshrvl_3(&self) -> bool {
                *self == SvshrvlR::Svshrvl3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsheR {
            bits: u8,
        }
        impl SvsheR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvshfpR {
            bits: u8,
        }
        impl SvshfpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhovpeR {
            bits: u8,
        }
        impl SvmhovpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmheR {
            bits: u8,
        }
        impl SvmheR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhfpR {
            bits: u8,
        }
        impl SvmhfpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `SVSMHRRL`" ]
        pub enum SvsmhrrlW {
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 0" ]
            Svsmhrrl0,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 1" ]
            Svsmhrrl1,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 2" ]
            Svsmhrrl2,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 3" ]
            Svsmhrrl3,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 4" ]
            Svsmhrrl4,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 5" ]
            Svsmhrrl5,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 6" ]
            Svsmhrrl6,
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 7" ]
            Svsmhrrl7,
        }
        impl SvsmhrrlW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SvsmhrrlW::Svsmhrrl0 => 0,
                    SvsmhrrlW::Svsmhrrl1 => 1,
                    SvsmhrrlW::Svsmhrrl2 => 2,
                    SvsmhrrlW::Svsmhrrl3 => 3,
                    SvsmhrrlW::Svsmhrrl4 => 4,
                    SvsmhrrlW::Svsmhrrl5 => 5,
                    SvsmhrrlW::Svsmhrrl6 => 6,
                    SvsmhrrlW::Svsmhrrl7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmhrrlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmhrrlW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SvsmhrrlW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 0" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_0(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl0)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 1" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_1(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl1)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 2" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_2(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl2)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 3" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_3(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl3)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 4" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_4(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl4)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 5" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_5(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl5)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 6" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_6(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl6)
            }
            # [ doc = "SVS and SVM high side Reset Release Voltage Level 7" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl_7(self) -> &'a mut W {
                self.variant(SvsmhrrlW::Svsmhrrl7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmhdlystW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmhdlystW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvshmdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvshmdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmhevmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmhevmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmhaceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmhaceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SVSHRVL`" ]
        pub enum SvshrvlW {
            # [ doc = "SVS high side Reset Release Voltage Level 0" ]
            Svshrvl0,
            # [ doc = "SVS high side Reset Release Voltage Level 1" ]
            Svshrvl1,
            # [ doc = "SVS high side Reset Release Voltage Level 2" ]
            Svshrvl2,
            # [ doc = "SVS high side Reset Release Voltage Level 3" ]
            Svshrvl3,
        }
        impl SvshrvlW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SvshrvlW::Svshrvl0 => 0,
                    SvshrvlW::Svshrvl1 => 1,
                    SvshrvlW::Svshrvl2 => 2,
                    SvshrvlW::Svshrvl3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvshrvlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvshrvlW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SvshrvlW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "SVS high side Reset Release Voltage Level 0" ]
            # [ inline ( always ) ]
            pub fn svshrvl_0(self) -> &'a mut W {
                self.variant(SvshrvlW::Svshrvl0)
            }
            # [ doc = "SVS high side Reset Release Voltage Level 1" ]
            # [ inline ( always ) ]
            pub fn svshrvl_1(self) -> &'a mut W {
                self.variant(SvshrvlW::Svshrvl1)
            }
            # [ doc = "SVS high side Reset Release Voltage Level 2" ]
            # [ inline ( always ) ]
            pub fn svshrvl_2(self) -> &'a mut W {
                self.variant(SvshrvlW::Svshrvl2)
            }
            # [ doc = "SVS high side Reset Release Voltage Level 3" ]
            # [ inline ( always ) ]
            pub fn svshrvl_3(self) -> &'a mut W {
                self.variant(SvshrvlW::Svshrvl3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsheW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsheW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvshfpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvshfpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhovpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhovpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmheW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmheW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhfpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhfpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - SVS and SVM high side Reset Release Voltage Level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl(&self) -> SvsmhrrlR {
                SvsmhrrlR::_from({
                                     const MASK: u8 = 7;
                                     const OFFSET: u8 = 2;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bit 3 - SVS and SVM high side delay status" ]
            # [ inline ( always ) ]
            pub fn svsmhdlyst(&self) -> SvsmhdlystR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmhdlystR { bits }
            }
            # [ doc = "Bit 4 - SVS high side mode" ]
            # [ inline ( always ) ]
            pub fn svshmd(&self) -> SvshmdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvshmdR { bits }
            }
            # [ doc = "Bit 6 - SVS and SVM high side event mask" ]
            # [ inline ( always ) ]
            pub fn svsmhevm(&self) -> SvsmhevmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmhevmR { bits }
            }
            # [ doc = "Bit 7 - SVS and SVM high side auto control enable" ]
            # [ inline ( always ) ]
            pub fn svsmhace(&self) -> SvsmhaceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmhaceR { bits }
            }
            # [ doc = "Bits 9:10 - SVS high side reset voltage level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svshrvl(&self) -> SvshrvlR {
                SvshrvlR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 9;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 10 - SVS high side enable" ]
            # [ inline ( always ) ]
            pub fn svshe(&self) -> SvsheR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsheR { bits }
            }
            # [ doc = "Bit 11 - SVS high side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svshfp(&self) -> SvshfpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvshfpR { bits }
            }
            # [ doc = "Bit 12 - SVM high side over-voltage enable" ]
            # [ inline ( always ) ]
            pub fn svmhovpe(&self) -> SvmhovpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhovpeR { bits }
            }
            # [ doc = "Bit 14 - SVM high side enable" ]
            # [ inline ( always ) ]
            pub fn svmhe(&self) -> SvmheR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmheR { bits }
            }
            # [ doc = "Bit 15 - SVM high side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svmhfp(&self) -> SvmhfpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhfpR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - SVS and SVM high side Reset Release Voltage Level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svsmhrrl(&mut self) -> _SvsmhrrlW {
                _SvsmhrrlW { w: self }
            }
            # [ doc = "Bit 3 - SVS and SVM high side delay status" ]
            # [ inline ( always ) ]
            pub fn svsmhdlyst(&mut self) -> _SvsmhdlystW {
                _SvsmhdlystW { w: self }
            }
            # [ doc = "Bit 4 - SVS high side mode" ]
            # [ inline ( always ) ]
            pub fn svshmd(&mut self) -> _SvshmdW {
                _SvshmdW { w: self }
            }
            # [ doc = "Bit 6 - SVS and SVM high side event mask" ]
            # [ inline ( always ) ]
            pub fn svsmhevm(&mut self) -> _SvsmhevmW {
                _SvsmhevmW { w: self }
            }
            # [ doc = "Bit 7 - SVS and SVM high side auto control enable" ]
            # [ inline ( always ) ]
            pub fn svsmhace(&mut self) -> _SvsmhaceW {
                _SvsmhaceW { w: self }
            }
            # [ doc = "Bits 9:10 - SVS high side reset voltage level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svshrvl(&mut self) -> _SvshrvlW {
                _SvshrvlW { w: self }
            }
            # [ doc = "Bit 10 - SVS high side enable" ]
            # [ inline ( always ) ]
            pub fn svshe(&mut self) -> _SvsheW {
                _SvsheW { w: self }
            }
            # [ doc = "Bit 11 - SVS high side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svshfp(&mut self) -> _SvshfpW {
                _SvshfpW { w: self }
            }
            # [ doc = "Bit 12 - SVM high side over-voltage enable" ]
            # [ inline ( always ) ]
            pub fn svmhovpe(&mut self) -> _SvmhovpeW {
                _SvmhovpeW { w: self }
            }
            # [ doc = "Bit 14 - SVM high side enable" ]
            # [ inline ( always ) ]
            pub fn svmhe(&mut self) -> _SvmheW {
                _SvmheW { w: self }
            }
            # [ doc = "Bit 15 - SVM high side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svmhfp(&mut self) -> _SvmhfpW {
                _SvmhfpW { w: self }
            }
        }
    }
    # [ doc = "SVS and SVM low side control register" ]
    pub struct Svsmlctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "SVS and SVM low side control register" ]
    pub mod svsmlctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Svsmlctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SVSMLRRL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SvsmlrrlR {
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 0" ]
            Svsmlrrl0,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 1" ]
            Svsmlrrl1,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 2" ]
            Svsmlrrl2,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 3" ]
            Svsmlrrl3,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 4" ]
            Svsmlrrl4,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 5" ]
            Svsmlrrl5,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 6" ]
            Svsmlrrl6,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 7" ]
            Svsmlrrl7,
        }
        impl SvsmlrrlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SvsmlrrlR::Svsmlrrl0 => 0,
                    SvsmlrrlR::Svsmlrrl1 => 1,
                    SvsmlrrlR::Svsmlrrl2 => 2,
                    SvsmlrrlR::Svsmlrrl3 => 3,
                    SvsmlrrlR::Svsmlrrl4 => 4,
                    SvsmlrrlR::Svsmlrrl5 => 5,
                    SvsmlrrlR::Svsmlrrl6 => 6,
                    SvsmlrrlR::Svsmlrrl7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SvsmlrrlR {
                match bits {
                    0 => SvsmlrrlR::Svsmlrrl0,
                    1 => SvsmlrrlR::Svsmlrrl1,
                    2 => SvsmlrrlR::Svsmlrrl2,
                    3 => SvsmlrrlR::Svsmlrrl3,
                    4 => SvsmlrrlR::Svsmlrrl4,
                    5 => SvsmlrrlR::Svsmlrrl5,
                    6 => SvsmlrrlR::Svsmlrrl6,
                    7 => SvsmlrrlR::Svsmlrrl7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl0`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_0(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl0
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl1`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_1(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl1
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl2`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_2(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl2
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl3`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_3(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl3
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl4`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_4(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl4
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl5`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_5(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl5
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl6`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_6(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl6
            }
            # [ doc = "Checks if the value of the field is `Svsmlrrl7`" ]
            # [ inline ( always ) ]
            pub fn is_svsmlrrl_7(&self) -> bool {
                *self == SvsmlrrlR::Svsmlrrl7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmldlystR {
            bits: u8,
        }
        impl SvsmldlystR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvslmdR {
            bits: u8,
        }
        impl SvslmdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmlevmR {
            bits: u8,
        }
        impl SvsmlevmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmlaceR {
            bits: u8,
        }
        impl SvsmlaceR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `SVSLRVL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SvslrvlR {
            # [ doc = "SVS low side Reset Release Voltage Level 0" ]
            Svslrvl0,
            # [ doc = "SVS low side Reset Release Voltage Level 1" ]
            Svslrvl1,
            # [ doc = "SVS low side Reset Release Voltage Level 2" ]
            Svslrvl2,
            # [ doc = "SVS low side Reset Release Voltage Level 3" ]
            Svslrvl3,
        }
        impl SvslrvlR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SvslrvlR::Svslrvl0 => 0,
                    SvslrvlR::Svslrvl1 => 1,
                    SvslrvlR::Svslrvl2 => 2,
                    SvslrvlR::Svslrvl3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SvslrvlR {
                match bits {
                    0 => SvslrvlR::Svslrvl0,
                    1 => SvslrvlR::Svslrvl1,
                    2 => SvslrvlR::Svslrvl2,
                    3 => SvslrvlR::Svslrvl3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Svslrvl0`" ]
            # [ inline ( always ) ]
            pub fn is_svslrvl_0(&self) -> bool {
                *self == SvslrvlR::Svslrvl0
            }
            # [ doc = "Checks if the value of the field is `Svslrvl1`" ]
            # [ inline ( always ) ]
            pub fn is_svslrvl_1(&self) -> bool {
                *self == SvslrvlR::Svslrvl1
            }
            # [ doc = "Checks if the value of the field is `Svslrvl2`" ]
            # [ inline ( always ) ]
            pub fn is_svslrvl_2(&self) -> bool {
                *self == SvslrvlR::Svslrvl2
            }
            # [ doc = "Checks if the value of the field is `Svslrvl3`" ]
            # [ inline ( always ) ]
            pub fn is_svslrvl_3(&self) -> bool {
                *self == SvslrvlR::Svslrvl3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsleR {
            bits: u8,
        }
        impl SvsleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvslfpR {
            bits: u8,
        }
        impl SvslfpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlovpeR {
            bits: u8,
        }
        impl SvmlovpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmleR {
            bits: u8,
        }
        impl SvmleR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlfpR {
            bits: u8,
        }
        impl SvmlfpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `SVSMLRRL`" ]
        pub enum SvsmlrrlW {
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 0" ]
            Svsmlrrl0,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 1" ]
            Svsmlrrl1,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 2" ]
            Svsmlrrl2,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 3" ]
            Svsmlrrl3,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 4" ]
            Svsmlrrl4,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 5" ]
            Svsmlrrl5,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 6" ]
            Svsmlrrl6,
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 7" ]
            Svsmlrrl7,
        }
        impl SvsmlrrlW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SvsmlrrlW::Svsmlrrl0 => 0,
                    SvsmlrrlW::Svsmlrrl1 => 1,
                    SvsmlrrlW::Svsmlrrl2 => 2,
                    SvsmlrrlW::Svsmlrrl3 => 3,
                    SvsmlrrlW::Svsmlrrl4 => 4,
                    SvsmlrrlW::Svsmlrrl5 => 5,
                    SvsmlrrlW::Svsmlrrl6 => 6,
                    SvsmlrrlW::Svsmlrrl7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmlrrlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmlrrlW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SvsmlrrlW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 0" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_0(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl0)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 1" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_1(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl1)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 2" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_2(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl2)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 3" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_3(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl3)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 4" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_4(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl4)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 5" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_5(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl5)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 6" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_6(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl6)
            }
            # [ doc = "SVS and SVM low side Reset Release Voltage Level 7" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl_7(self) -> &'a mut W {
                self.variant(SvsmlrrlW::Svsmlrrl7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmldlystW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmldlystW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvslmdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvslmdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmlevmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmlevmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmlaceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmlaceW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SVSLRVL`" ]
        pub enum SvslrvlW {
            # [ doc = "SVS low side Reset Release Voltage Level 0" ]
            Svslrvl0,
            # [ doc = "SVS low side Reset Release Voltage Level 1" ]
            Svslrvl1,
            # [ doc = "SVS low side Reset Release Voltage Level 2" ]
            Svslrvl2,
            # [ doc = "SVS low side Reset Release Voltage Level 3" ]
            Svslrvl3,
        }
        impl SvslrvlW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SvslrvlW::Svslrvl0 => 0,
                    SvslrvlW::Svslrvl1 => 1,
                    SvslrvlW::Svslrvl2 => 2,
                    SvslrvlW::Svslrvl3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvslrvlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvslrvlW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SvslrvlW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "SVS low side Reset Release Voltage Level 0" ]
            # [ inline ( always ) ]
            pub fn svslrvl_0(self) -> &'a mut W {
                self.variant(SvslrvlW::Svslrvl0)
            }
            # [ doc = "SVS low side Reset Release Voltage Level 1" ]
            # [ inline ( always ) ]
            pub fn svslrvl_1(self) -> &'a mut W {
                self.variant(SvslrvlW::Svslrvl1)
            }
            # [ doc = "SVS low side Reset Release Voltage Level 2" ]
            # [ inline ( always ) ]
            pub fn svslrvl_2(self) -> &'a mut W {
                self.variant(SvslrvlW::Svslrvl2)
            }
            # [ doc = "SVS low side Reset Release Voltage Level 3" ]
            # [ inline ( always ) ]
            pub fn svslrvl_3(self) -> &'a mut W {
                self.variant(SvslrvlW::Svslrvl3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsleW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsleW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvslfpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvslfpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlovpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlovpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmleW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmleW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlfpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlfpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - SVS and SVM low side Reset Release Voltage Level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl(&self) -> SvsmlrrlR {
                SvsmlrrlR::_from({
                                     const MASK: u8 = 7;
                                     const OFFSET: u8 = 2;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bit 3 - SVS and SVM low side delay status" ]
            # [ inline ( always ) ]
            pub fn svsmldlyst(&self) -> SvsmldlystR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmldlystR { bits }
            }
            # [ doc = "Bit 4 - SVS low side mode" ]
            # [ inline ( always ) ]
            pub fn svslmd(&self) -> SvslmdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvslmdR { bits }
            }
            # [ doc = "Bit 6 - SVS and SVM low side event mask" ]
            # [ inline ( always ) ]
            pub fn svsmlevm(&self) -> SvsmlevmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmlevmR { bits }
            }
            # [ doc = "Bit 7 - SVS and SVM low side auto control enable" ]
            # [ inline ( always ) ]
            pub fn svsmlace(&self) -> SvsmlaceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmlaceR { bits }
            }
            # [ doc = "Bits 9:10 - SVS low side reset voltage level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svslrvl(&self) -> SvslrvlR {
                SvslrvlR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 9;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 10 - SVS low side enable" ]
            # [ inline ( always ) ]
            pub fn svsle(&self) -> SvsleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsleR { bits }
            }
            # [ doc = "Bit 11 - SVS low side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svslfp(&self) -> SvslfpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvslfpR { bits }
            }
            # [ doc = "Bit 12 - SVM low side over-voltage enable" ]
            # [ inline ( always ) ]
            pub fn svmlovpe(&self) -> SvmlovpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlovpeR { bits }
            }
            # [ doc = "Bit 14 - SVM low side enable" ]
            # [ inline ( always ) ]
            pub fn svmle(&self) -> SvmleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmleR { bits }
            }
            # [ doc = "Bit 15 - SVM low side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svmlfp(&self) -> SvmlfpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlfpR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - SVS and SVM low side Reset Release Voltage Level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svsmlrrl(&mut self) -> _SvsmlrrlW {
                _SvsmlrrlW { w: self }
            }
            # [ doc = "Bit 3 - SVS and SVM low side delay status" ]
            # [ inline ( always ) ]
            pub fn svsmldlyst(&mut self) -> _SvsmldlystW {
                _SvsmldlystW { w: self }
            }
            # [ doc = "Bit 4 - SVS low side mode" ]
            # [ inline ( always ) ]
            pub fn svslmd(&mut self) -> _SvslmdW {
                _SvslmdW { w: self }
            }
            # [ doc = "Bit 6 - SVS and SVM low side event mask" ]
            # [ inline ( always ) ]
            pub fn svsmlevm(&mut self) -> _SvsmlevmW {
                _SvsmlevmW { w: self }
            }
            # [ doc = "Bit 7 - SVS and SVM low side auto control enable" ]
            # [ inline ( always ) ]
            pub fn svsmlace(&mut self) -> _SvsmlaceW {
                _SvsmlaceW { w: self }
            }
            # [ doc = "Bits 9:10 - SVS low side reset voltage level Bit: 0" ]
            # [ inline ( always ) ]
            pub fn svslrvl(&mut self) -> _SvslrvlW {
                _SvslrvlW { w: self }
            }
            # [ doc = "Bit 10 - SVS low side enable" ]
            # [ inline ( always ) ]
            pub fn svsle(&mut self) -> _SvsleW {
                _SvsleW { w: self }
            }
            # [ doc = "Bit 11 - SVS low side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svslfp(&mut self) -> _SvslfpW {
                _SvslfpW { w: self }
            }
            # [ doc = "Bit 12 - SVM low side over-voltage enable" ]
            # [ inline ( always ) ]
            pub fn svmlovpe(&mut self) -> _SvmlovpeW {
                _SvmlovpeW { w: self }
            }
            # [ doc = "Bit 14 - SVM low side enable" ]
            # [ inline ( always ) ]
            pub fn svmle(&mut self) -> _SvmleW {
                _SvmleW { w: self }
            }
            # [ doc = "Bit 15 - SVM low side full performace mode" ]
            # [ inline ( always ) ]
            pub fn svmlfp(&mut self) -> _SvmlfpW {
                _SvmlfpW { w: self }
            }
        }
    }
    # [ doc = "SVSIN and SVSOUT control register" ]
    pub struct Svsmio {
        register: VolatileCell<u16>,
    }
    # [ doc = "SVSIN and SVSOUT control register" ]
    pub mod svsmio {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Svsmio {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmloeR {
            bits: u8,
        }
        impl SvmloeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlvlroeR {
            bits: u8,
        }
        impl SvmlvlroeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmoutpolR {
            bits: u8,
        }
        impl SvmoutpolR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhoeR {
            bits: u8,
        }
        impl SvmhoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhvlroeR {
            bits: u8,
        }
        impl SvmhvlroeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmloeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmloeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlvlroeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlvlroeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmoutpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmoutpolW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhvlroeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhvlroeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 3 - SVM low side output enable" ]
            # [ inline ( always ) ]
            pub fn svmloe(&self) -> SvmloeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmloeR { bits }
            }
            # [ doc = "Bit 4 - SVM low side voltage level reached output enable" ]
            # [ inline ( always ) ]
            pub fn svmlvlroe(&self) -> SvmlvlroeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlvlroeR { bits }
            }
            # [ doc = "Bit 5 - SVMOUT pin polarity" ]
            # [ inline ( always ) ]
            pub fn svmoutpol(&self) -> SvmoutpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmoutpolR { bits }
            }
            # [ doc = "Bit 11 - SVM high side output enable" ]
            # [ inline ( always ) ]
            pub fn svmhoe(&self) -> SvmhoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhoeR { bits }
            }
            # [ doc = "Bit 12 - SVM high side voltage level reached output enable" ]
            # [ inline ( always ) ]
            pub fn svmhvlroe(&self) -> SvmhvlroeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhvlroeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 3 - SVM low side output enable" ]
            # [ inline ( always ) ]
            pub fn svmloe(&mut self) -> _SvmloeW {
                _SvmloeW { w: self }
            }
            # [ doc = "Bit 4 - SVM low side voltage level reached output enable" ]
            # [ inline ( always ) ]
            pub fn svmlvlroe(&mut self) -> _SvmlvlroeW {
                _SvmlvlroeW { w: self }
            }
            # [ doc = "Bit 5 - SVMOUT pin polarity" ]
            # [ inline ( always ) ]
            pub fn svmoutpol(&mut self) -> _SvmoutpolW {
                _SvmoutpolW { w: self }
            }
            # [ doc = "Bit 11 - SVM high side output enable" ]
            # [ inline ( always ) ]
            pub fn svmhoe(&mut self) -> _SvmhoeW {
                _SvmhoeW { w: self }
            }
            # [ doc = "Bit 12 - SVM high side voltage level reached output enable" ]
            # [ inline ( always ) ]
            pub fn svmhvlroe(&mut self) -> _SvmhvlroeW {
                _SvmhvlroeW { w: self }
            }
        }
    }
    # [ doc = "PMM Interrupt Flag" ]
    pub struct Pmmifg {
        register: VolatileCell<u16>,
    }
    # [ doc = "PMM Interrupt Flag" ]
    pub mod pmmifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pmmifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmldlyifgR {
            bits: u8,
        }
        impl SvsmldlyifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlifgR {
            bits: u8,
        }
        impl SvmlifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlvlrifgR {
            bits: u8,
        }
        impl SvmlvlrifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmhdlyifgR {
            bits: u8,
        }
        impl SvsmhdlyifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhifgR {
            bits: u8,
        }
        impl SvmhifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhvlrifgR {
            bits: u8,
        }
        impl SvmhvlrifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmborifgR {
            bits: u8,
        }
        impl PmmborifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmrstifgR {
            bits: u8,
        }
        impl PmmrstifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct PmmporifgR {
            bits: u8,
        }
        impl PmmporifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvshifgR {
            bits: u8,
        }
        impl SvshifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvslifgR {
            bits: u8,
        }
        impl SvslifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Pmmlpm5ifgR {
            bits: u8,
        }
        impl Pmmlpm5ifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmldlyifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmldlyifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlvlrifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlvlrifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmhdlyifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmhdlyifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhvlrifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhvlrifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmborifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmborifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmrstifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmrstifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _PmmporifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmmporifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvshifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvshifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvslifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvslifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Pmmlpm5ifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pmmlpm5ifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - SVS and SVM low side Delay expired interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svsmldlyifg(&self) -> SvsmldlyifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmldlyifgR { bits }
            }
            # [ doc = "Bit 1 - SVM low side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmlifg(&self) -> SvmlifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlifgR { bits }
            }
            # [ doc = "Bit 2 - SVM low side Voltage Level Reached interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmlvlrifg(&self) -> SvmlvlrifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlvlrifgR { bits }
            }
            # [ doc = "Bit 4 - SVS and SVM high side Delay expired interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svsmhdlyifg(&self) -> SvsmhdlyifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmhdlyifgR { bits }
            }
            # [ doc = "Bit 5 - SVM high side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmhifg(&self) -> SvmhifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhifgR { bits }
            }
            # [ doc = "Bit 6 - SVM high side Voltage Level Reached interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmhvlrifg(&self) -> SvmhvlrifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhvlrifgR { bits }
            }
            # [ doc = "Bit 8 - PMM Software BOR interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pmmborifg(&self) -> PmmborifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmborifgR { bits }
            }
            # [ doc = "Bit 9 - PMM RESET pin interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pmmrstifg(&self) -> PmmrstifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmrstifgR { bits }
            }
            # [ doc = "Bit 10 - PMM Software POR interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pmmporifg(&self) -> PmmporifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                PmmporifgR { bits }
            }
            # [ doc = "Bit 12 - SVS low side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svshifg(&self) -> SvshifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvshifgR { bits }
            }
            # [ doc = "Bit 13 - SVS high side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svslifg(&self) -> SvslifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvslifgR { bits }
            }
            # [ doc = "Bit 15 - LPM5 indication Flag" ]
            # [ inline ( always ) ]
            pub fn pmmlpm5ifg(&self) -> Pmmlpm5ifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Pmmlpm5ifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SVS and SVM low side Delay expired interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svsmldlyifg(&mut self) -> _SvsmldlyifgW {
                _SvsmldlyifgW { w: self }
            }
            # [ doc = "Bit 1 - SVM low side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmlifg(&mut self) -> _SvmlifgW {
                _SvmlifgW { w: self }
            }
            # [ doc = "Bit 2 - SVM low side Voltage Level Reached interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmlvlrifg(&mut self) -> _SvmlvlrifgW {
                _SvmlvlrifgW { w: self }
            }
            # [ doc = "Bit 4 - SVS and SVM high side Delay expired interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svsmhdlyifg(&mut self) -> _SvsmhdlyifgW {
                _SvsmhdlyifgW { w: self }
            }
            # [ doc = "Bit 5 - SVM high side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmhifg(&mut self) -> _SvmhifgW {
                _SvmhifgW { w: self }
            }
            # [ doc = "Bit 6 - SVM high side Voltage Level Reached interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svmhvlrifg(&mut self) -> _SvmhvlrifgW {
                _SvmhvlrifgW { w: self }
            }
            # [ doc = "Bit 8 - PMM Software BOR interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pmmborifg(&mut self) -> _PmmborifgW {
                _PmmborifgW { w: self }
            }
            # [ doc = "Bit 9 - PMM RESET pin interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pmmrstifg(&mut self) -> _PmmrstifgW {
                _PmmrstifgW { w: self }
            }
            # [ doc = "Bit 10 - PMM Software POR interrupt flag" ]
            # [ inline ( always ) ]
            pub fn pmmporifg(&mut self) -> _PmmporifgW {
                _PmmporifgW { w: self }
            }
            # [ doc = "Bit 12 - SVS low side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svshifg(&mut self) -> _SvshifgW {
                _SvshifgW { w: self }
            }
            # [ doc = "Bit 13 - SVS high side interrupt flag" ]
            # [ inline ( always ) ]
            pub fn svslifg(&mut self) -> _SvslifgW {
                _SvslifgW { w: self }
            }
            # [ doc = "Bit 15 - LPM5 indication Flag" ]
            # [ inline ( always ) ]
            pub fn pmmlpm5ifg(&mut self) -> _Pmmlpm5ifgW {
                _Pmmlpm5ifgW { w: self }
            }
        }
    }
    # [ doc = "PMM and RESET Interrupt Enable" ]
    pub struct Pmmrie {
        register: VolatileCell<u16>,
    }
    # [ doc = "PMM and RESET Interrupt Enable" ]
    pub mod pmmrie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pmmrie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmldlyieR {
            bits: u8,
        }
        impl SvsmldlyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlieR {
            bits: u8,
        }
        impl SvmlieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlvlrieR {
            bits: u8,
        }
        impl SvmlvlrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvsmhdlyieR {
            bits: u8,
        }
        impl SvsmhdlyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhieR {
            bits: u8,
        }
        impl SvmhieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhvlrieR {
            bits: u8,
        }
        impl SvmhvlrieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvslpeR {
            bits: u8,
        }
        impl SvslpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmlvlrpeR {
            bits: u8,
        }
        impl SvmlvlrpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvshpeR {
            bits: u8,
        }
        impl SvshpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SvmhvlrpeR {
            bits: u8,
        }
        impl SvmhvlrpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmldlyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmldlyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlvlrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlvlrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvsmhdlyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvsmhdlyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhvlrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhvlrieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvslpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvslpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmlvlrpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmlvlrpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvshpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvshpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SvmhvlrpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SvmhvlrpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - SVS and SVM low side Delay expired interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svsmldlyie(&self) -> SvsmldlyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmldlyieR { bits }
            }
            # [ doc = "Bit 1 - SVM low side interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmlie(&self) -> SvmlieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlieR { bits }
            }
            # [ doc = "Bit 2 - SVM low side Voltage Level Reached interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmlvlrie(&self) -> SvmlvlrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlvlrieR { bits }
            }
            # [ doc = "Bit 4 - SVS and SVM high side Delay expired interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svsmhdlyie(&self) -> SvsmhdlyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvsmhdlyieR { bits }
            }
            # [ doc = "Bit 5 - SVM high side interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmhie(&self) -> SvmhieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhieR { bits }
            }
            # [ doc = "Bit 6 - SVM high side Voltage Level Reached interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmhvlrie(&self) -> SvmhvlrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhvlrieR { bits }
            }
            # [ doc = "Bit 8 - SVS low side POR enable" ]
            # [ inline ( always ) ]
            pub fn svslpe(&self) -> SvslpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvslpeR { bits }
            }
            # [ doc = "Bit 9 - SVM low side Voltage Level reached POR enable" ]
            # [ inline ( always ) ]
            pub fn svmlvlrpe(&self) -> SvmlvlrpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmlvlrpeR { bits }
            }
            # [ doc = "Bit 12 - SVS high side POR enable" ]
            # [ inline ( always ) ]
            pub fn svshpe(&self) -> SvshpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvshpeR { bits }
            }
            # [ doc = "Bit 13 - SVM high side Voltage Level reached POR enable" ]
            # [ inline ( always ) ]
            pub fn svmhvlrpe(&self) -> SvmhvlrpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SvmhvlrpeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SVS and SVM low side Delay expired interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svsmldlyie(&mut self) -> _SvsmldlyieW {
                _SvsmldlyieW { w: self }
            }
            # [ doc = "Bit 1 - SVM low side interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmlie(&mut self) -> _SvmlieW {
                _SvmlieW { w: self }
            }
            # [ doc = "Bit 2 - SVM low side Voltage Level Reached interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmlvlrie(&mut self) -> _SvmlvlrieW {
                _SvmlvlrieW { w: self }
            }
            # [ doc = "Bit 4 - SVS and SVM high side Delay expired interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svsmhdlyie(&mut self) -> _SvsmhdlyieW {
                _SvsmhdlyieW { w: self }
            }
            # [ doc = "Bit 5 - SVM high side interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmhie(&mut self) -> _SvmhieW {
                _SvmhieW { w: self }
            }
            # [ doc = "Bit 6 - SVM high side Voltage Level Reached interrupt enable" ]
            # [ inline ( always ) ]
            pub fn svmhvlrie(&mut self) -> _SvmhvlrieW {
                _SvmhvlrieW { w: self }
            }
            # [ doc = "Bit 8 - SVS low side POR enable" ]
            # [ inline ( always ) ]
            pub fn svslpe(&mut self) -> _SvslpeW {
                _SvslpeW { w: self }
            }
            # [ doc = "Bit 9 - SVM low side Voltage Level reached POR enable" ]
            # [ inline ( always ) ]
            pub fn svmlvlrpe(&mut self) -> _SvmlvlrpeW {
                _SvmlvlrpeW { w: self }
            }
            # [ doc = "Bit 12 - SVS high side POR enable" ]
            # [ inline ( always ) ]
            pub fn svshpe(&mut self) -> _SvshpeW {
                _SvshpeW { w: self }
            }
            # [ doc = "Bit 13 - SVM high side Voltage Level reached POR enable" ]
            # [ inline ( always ) ]
            pub fn svmhvlrpe(&mut self) -> _SvmhvlrpeW {
                _SvmhvlrpeW { w: self }
            }
        }
    }
    # [ doc = "PMM Power Mode 5 Control Register 0" ]
    pub struct Pm5ctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "PMM Power Mode 5 Control Register 0" ]
    pub mod pm5ctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Pm5ctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Locklpm5R {
            bits: u8,
        }
        impl Locklpm5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Locklpm5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Locklpm5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Lock I/O pin configuration upon entry/exit to/from LPM5" ]
            # [ inline ( always ) ]
            pub fn locklpm5(&self) -> Locklpm5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Locklpm5R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Lock I/O pin configuration upon entry/exit to/from LPM5" ]
            # [ inline ( always ) ]
            pub fn locklpm5(&mut self) -> _Locklpm5W {
                _Locklpm5W { w: self }
            }
        }
    }
}
# [ doc = "PMM Power Management System" ]
pub struct PmmPowerManagementSystem {
    register_block: pmm_power_management_system::RegisterBlock,
}
impl Deref for PmmPowerManagementSystem {
    type Target = pmm_power_management_system::RegisterBlock;
    fn deref(&self) -> &pmm_power_management_system::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "RC RAM Control Module" ]
pub const RC_RAM_CONTROL_MODULE: Peripheral<RcRamControlModule> = unsafe { Peripheral::new(0) };
# [ doc = "RC RAM Control Module" ]
pub mod rc_ram_control_module {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 344usize],
        # [ doc = "0x158 - Ram Controller Control Register" ]
        pub rcctl0: Rcctl0,
    }
    # [ doc = "Ram Controller Control Register" ]
    pub struct Rcctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Ram Controller Control Register" ]
    pub mod rcctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rcctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rcrs0offR {
            bits: u8,
        }
        impl Rcrs0offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rcrs1offR {
            bits: u8,
        }
        impl Rcrs1offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rcrs2offR {
            bits: u8,
        }
        impl Rcrs2offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rcrs3offR {
            bits: u8,
        }
        impl Rcrs3offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rcrs0offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rcrs0offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rcrs1offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rcrs1offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rcrs2offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rcrs2offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rcrs3offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rcrs3offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - RAM Controller RAM Sector 0 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs0off(&self) -> Rcrs0offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rcrs0offR { bits }
            }
            # [ doc = "Bit 1 - RAM Controller RAM Sector 1 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs1off(&self) -> Rcrs1offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rcrs1offR { bits }
            }
            # [ doc = "Bit 2 - RAM Controller RAM Sector 2 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs2off(&self) -> Rcrs2offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rcrs2offR { bits }
            }
            # [ doc = "Bit 3 - RAM Controller RAM Sector 3 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs3off(&self) -> Rcrs3offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rcrs3offR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RAM Controller RAM Sector 0 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs0off(&mut self) -> _Rcrs0offW {
                _Rcrs0offW { w: self }
            }
            # [ doc = "Bit 1 - RAM Controller RAM Sector 1 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs1off(&mut self) -> _Rcrs1offW {
                _Rcrs1offW { w: self }
            }
            # [ doc = "Bit 2 - RAM Controller RAM Sector 2 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs2off(&mut self) -> _Rcrs2offW {
                _Rcrs2offW { w: self }
            }
            # [ doc = "Bit 3 - RAM Controller RAM Sector 3 Off" ]
            # [ inline ( always ) ]
            pub fn rcrs3off(&mut self) -> _Rcrs3offW {
                _Rcrs3offW { w: self }
            }
        }
    }
}
# [ doc = "RC RAM Control Module" ]
pub struct RcRamControlModule {
    register_block: rc_ram_control_module::RegisterBlock,
}
impl Deref for RcRamControlModule {
    type Target = rc_ram_control_module::RegisterBlock;
    fn deref(&self) -> &rc_ram_control_module::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Shared Reference" ]
pub const SHARED_REFERENCE: Peripheral<SharedReference> = unsafe { Peripheral::new(0) };
# [ doc = "Shared Reference" ]
pub mod shared_reference {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 432usize],
        # [ doc = "0x1b0 - REF Shared Reference control register 0" ]
        pub refctl0: Refctl0,
    }
    # [ doc = "REF Shared Reference control register 0" ]
    pub struct Refctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "REF Shared Reference control register 0" ]
    pub mod refctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Refctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RefonR {
            bits: u8,
        }
        impl RefonR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RefoutR {
            bits: u8,
        }
        impl RefoutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ReftcoffR {
            bits: u8,
        }
        impl ReftcoffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `REFVSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RefvselR {
            # [ doc = "REF Reference Voltage Level Select 1.5V" ]
            Refvsel0,
            # [ doc = "REF Reference Voltage Level Select 2.0V" ]
            Refvsel1,
            # [ doc = "REF Reference Voltage Level Select 2.5V" ]
            Refvsel2,
            # [ doc = "REF Reference Voltage Level Select 2.5V" ]
            Refvsel3,
        }
        impl RefvselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RefvselR::Refvsel0 => 0,
                    RefvselR::Refvsel1 => 1,
                    RefvselR::Refvsel2 => 2,
                    RefvselR::Refvsel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RefvselR {
                match bits {
                    0 => RefvselR::Refvsel0,
                    1 => RefvselR::Refvsel1,
                    2 => RefvselR::Refvsel2,
                    3 => RefvselR::Refvsel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Refvsel0`" ]
            # [ inline ( always ) ]
            pub fn is_refvsel_0(&self) -> bool {
                *self == RefvselR::Refvsel0
            }
            # [ doc = "Checks if the value of the field is `Refvsel1`" ]
            # [ inline ( always ) ]
            pub fn is_refvsel_1(&self) -> bool {
                *self == RefvselR::Refvsel1
            }
            # [ doc = "Checks if the value of the field is `Refvsel2`" ]
            # [ inline ( always ) ]
            pub fn is_refvsel_2(&self) -> bool {
                *self == RefvselR::Refvsel2
            }
            # [ doc = "Checks if the value of the field is `Refvsel3`" ]
            # [ inline ( always ) ]
            pub fn is_refvsel_3(&self) -> bool {
                *self == RefvselR::Refvsel3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RefmstrR {
            bits: u8,
        }
        impl RefmstrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RefgenactR {
            bits: u8,
        }
        impl RefgenactR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RefbgactR {
            bits: u8,
        }
        impl RefbgactR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RefgenbusyR {
            bits: u8,
        }
        impl RefgenbusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct BgmodeR {
            bits: u8,
        }
        impl BgmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefonW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefoutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ReftcoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReftcoffW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `REFVSEL`" ]
        pub enum RefvselW {
            # [ doc = "REF Reference Voltage Level Select 1.5V" ]
            Refvsel0,
            # [ doc = "REF Reference Voltage Level Select 2.0V" ]
            Refvsel1,
            # [ doc = "REF Reference Voltage Level Select 2.5V" ]
            Refvsel2,
            # [ doc = "REF Reference Voltage Level Select 2.5V" ]
            Refvsel3,
        }
        impl RefvselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RefvselW::Refvsel0 => 0,
                    RefvselW::Refvsel1 => 1,
                    RefvselW::Refvsel2 => 2,
                    RefvselW::Refvsel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefvselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefvselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RefvselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "REF Reference Voltage Level Select 1.5V" ]
            # [ inline ( always ) ]
            pub fn refvsel_0(self) -> &'a mut W {
                self.variant(RefvselW::Refvsel0)
            }
            # [ doc = "REF Reference Voltage Level Select 2.0V" ]
            # [ inline ( always ) ]
            pub fn refvsel_1(self) -> &'a mut W {
                self.variant(RefvselW::Refvsel1)
            }
            # [ doc = "REF Reference Voltage Level Select 2.5V" ]
            # [ inline ( always ) ]
            pub fn refvsel_2(self) -> &'a mut W {
                self.variant(RefvselW::Refvsel2)
            }
            # [ doc = "REF Reference Voltage Level Select 2.5V" ]
            # [ inline ( always ) ]
            pub fn refvsel_3(self) -> &'a mut W {
                self.variant(RefvselW::Refvsel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefmstrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefmstrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefgenactW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefgenactW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefbgactW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefbgactW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RefgenbusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefgenbusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _BgmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgmodeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - REF Reference On" ]
            # [ inline ( always ) ]
            pub fn refon(&self) -> RefonR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RefonR { bits }
            }
            # [ doc = "Bit 1 - REF Reference output Buffer On" ]
            # [ inline ( always ) ]
            pub fn refout(&self) -> RefoutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RefoutR { bits }
            }
            # [ doc = "Bit 3 - REF Temp.Sensor off" ]
            # [ inline ( always ) ]
            pub fn reftcoff(&self) -> ReftcoffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ReftcoffR { bits }
            }
            # [ doc = "Bits 5:6 - REF Reference Voltage Level Select Bit:0" ]
            # [ inline ( always ) ]
            pub fn refvsel(&self) -> RefvselR {
                RefvselR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 5;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 7 - REF Master Control" ]
            # [ inline ( always ) ]
            pub fn refmstr(&self) -> RefmstrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RefmstrR { bits }
            }
            # [ doc = "Bit 8 - REF Reference generator active" ]
            # [ inline ( always ) ]
            pub fn refgenact(&self) -> RefgenactR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RefgenactR { bits }
            }
            # [ doc = "Bit 9 - REF Reference bandgap active" ]
            # [ inline ( always ) ]
            pub fn refbgact(&self) -> RefbgactR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RefbgactR { bits }
            }
            # [ doc = "Bit 10 - REF Reference generator busy" ]
            # [ inline ( always ) ]
            pub fn refgenbusy(&self) -> RefgenbusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RefgenbusyR { bits }
            }
            # [ doc = "Bit 11 - REF Bandgap mode" ]
            # [ inline ( always ) ]
            pub fn bgmode(&self) -> BgmodeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                BgmodeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - REF Reference On" ]
            # [ inline ( always ) ]
            pub fn refon(&mut self) -> _RefonW {
                _RefonW { w: self }
            }
            # [ doc = "Bit 1 - REF Reference output Buffer On" ]
            # [ inline ( always ) ]
            pub fn refout(&mut self) -> _RefoutW {
                _RefoutW { w: self }
            }
            # [ doc = "Bit 3 - REF Temp.Sensor off" ]
            # [ inline ( always ) ]
            pub fn reftcoff(&mut self) -> _ReftcoffW {
                _ReftcoffW { w: self }
            }
            # [ doc = "Bits 5:6 - REF Reference Voltage Level Select Bit:0" ]
            # [ inline ( always ) ]
            pub fn refvsel(&mut self) -> _RefvselW {
                _RefvselW { w: self }
            }
            # [ doc = "Bit 7 - REF Master Control" ]
            # [ inline ( always ) ]
            pub fn refmstr(&mut self) -> _RefmstrW {
                _RefmstrW { w: self }
            }
            # [ doc = "Bit 8 - REF Reference generator active" ]
            # [ inline ( always ) ]
            pub fn refgenact(&mut self) -> _RefgenactW {
                _RefgenactW { w: self }
            }
            # [ doc = "Bit 9 - REF Reference bandgap active" ]
            # [ inline ( always ) ]
            pub fn refbgact(&mut self) -> _RefbgactW {
                _RefbgactW { w: self }
            }
            # [ doc = "Bit 10 - REF Reference generator busy" ]
            # [ inline ( always ) ]
            pub fn refgenbusy(&mut self) -> _RefgenbusyW {
                _RefgenbusyW { w: self }
            }
            # [ doc = "Bit 11 - REF Bandgap mode" ]
            # [ inline ( always ) ]
            pub fn bgmode(&mut self) -> _BgmodeW {
                _BgmodeW { w: self }
            }
        }
    }
}
# [ doc = "Shared Reference" ]
pub struct SharedReference {
    register_block: shared_reference::RegisterBlock,
}
impl Deref for SharedReference {
    type Target = shared_reference::RegisterBlock;
    fn deref(&self) -> &shared_reference::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "RTC_D Real Time Clock" ]
pub const RTC_D_REAL_TIME_CLOCK: Peripheral<RtcDRealTimeClock> = unsafe { Peripheral::new(0) };
# [ doc = "RTC_D Real Time Clock" ]
pub mod rtc_d_real_time_clock {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1184usize],
        # [ doc = "0x4a0 - Real Timer Control 0/1" ]
        pub rtcctl01: Rtcctl01,
        # [ doc = "0x4a2 - Real Timer Control 2/3" ]
        pub rtcctl23: Rtcctl23,
        _reserved1: [u8; 4usize],
        # [ doc = "0x4a8 - Real Timer Prescale Timer 0 Control" ]
        pub rtcps0ctl: Rtcps0ctl,
        # [ doc = "0x4aa - Real Timer Prescale Timer 1 Control" ]
        pub rtcps1ctl: Rtcps1ctl,
        # [ doc = "0x4ac - Real Timer Prescale Timer Control" ]
        pub rtcps: Rtcps,
        # [ doc = "0x4ae - Real Time Clock Interrupt Vector" ]
        pub rtciv: Rtciv,
        # [ doc = "0x4b0 - Real Time Clock Time 0" ]
        pub rtctim0: Rtctim0,
        # [ doc = "0x4b2 - Real Time Clock Time 1" ]
        pub rtctim1: Rtctim1,
        # [ doc = "0x4b4 - Real Time Clock Date" ]
        pub rtcdate: Rtcdate,
        # [ doc = "0x4b6 - Real Time Clock Year" ]
        pub rtcyear: Rtcyear,
        # [ doc = "0x4b8 - Real Time Clock Alarm Min/Hour" ]
        pub rtcaminhr: Rtcaminhr,
        # [ doc = "0x4ba - Real Time Clock Alarm day of week/day" ]
        pub rtcadowday: Rtcadowday,
        # [ doc = "0x4bc - Real Time Binary-to-BCD conversion register" ]
        pub bin2bcd: Bin2bcd,
        # [ doc = "0x4be - Real Time BCD-to-binary conversion register" ]
        pub bcd2bin: Bcd2bin,
    }
    # [ doc = "Real Timer Control 0/1" ]
    pub struct Rtcctl01 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Timer Control 0/1" ]
    pub mod rtcctl01 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcctl01 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcrdyifgR {
            bits: u8,
        }
        impl RtcrdyifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcaifgR {
            bits: u8,
        }
        impl RtcaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtctevifgR {
            bits: u8,
        }
        impl RtctevifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcofifgR {
            bits: u8,
        }
        impl RtcofifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcrdyieR {
            bits: u8,
        }
        impl RtcrdyieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcaieR {
            bits: u8,
        }
        impl RtcaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtctevieR {
            bits: u8,
        }
        impl RtctevieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcofieR {
            bits: u8,
        }
        impl RtcofieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `RTCTEV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RtctevR {
            # [ doc = "RTC Time Event: 0 (Min. changed)" ]
            Rtctev0,
            # [ doc = "RTC Time Event: 1 (Hour changed)" ]
            Rtctev1,
            # [ doc = "RTC Time Event: 2 (12:00 changed)" ]
            Rtctev2,
            # [ doc = "RTC Time Event: 3 (00:00 changed)" ]
            Rtctev3,
        }
        impl RtctevR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RtctevR::Rtctev0 => 0,
                    RtctevR::Rtctev1 => 1,
                    RtctevR::Rtctev2 => 2,
                    RtctevR::Rtctev3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RtctevR {
                match bits {
                    0 => RtctevR::Rtctev0,
                    1 => RtctevR::Rtctev1,
                    2 => RtctevR::Rtctev2,
                    3 => RtctevR::Rtctev3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rtctev0`" ]
            # [ inline ( always ) ]
            pub fn is_rtctev_0(&self) -> bool {
                *self == RtctevR::Rtctev0
            }
            # [ doc = "Checks if the value of the field is `Rtctev1`" ]
            # [ inline ( always ) ]
            pub fn is_rtctev_1(&self) -> bool {
                *self == RtctevR::Rtctev1
            }
            # [ doc = "Checks if the value of the field is `Rtctev2`" ]
            # [ inline ( always ) ]
            pub fn is_rtctev_2(&self) -> bool {
                *self == RtctevR::Rtctev2
            }
            # [ doc = "Checks if the value of the field is `Rtctev3`" ]
            # [ inline ( always ) ]
            pub fn is_rtctev_3(&self) -> bool {
                *self == RtctevR::Rtctev3
            }
        }
        # [ doc = "Possible values of the field `RTCSSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RtcsselR {
            # [ doc = "RTC Source Select ACLK" ]
            Rtcssel0,
            # [ doc = "RTC Source Select SMCLK" ]
            Rtcssel1,
            # [ doc = "RTC Source Select RT1PS" ]
            Rtcssel2,
            # [ doc = "RTC Source Select RT1PS" ]
            Rtcssel3,
        }
        impl RtcsselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RtcsselR::Rtcssel0 => 0,
                    RtcsselR::Rtcssel1 => 1,
                    RtcsselR::Rtcssel2 => 2,
                    RtcsselR::Rtcssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RtcsselR {
                match bits {
                    0 => RtcsselR::Rtcssel0,
                    1 => RtcsselR::Rtcssel1,
                    2 => RtcsselR::Rtcssel2,
                    3 => RtcsselR::Rtcssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rtcssel0`" ]
            # [ inline ( always ) ]
            pub fn is_rtcssel_0(&self) -> bool {
                *self == RtcsselR::Rtcssel0
            }
            # [ doc = "Checks if the value of the field is `Rtcssel1`" ]
            # [ inline ( always ) ]
            pub fn is_rtcssel_1(&self) -> bool {
                *self == RtcsselR::Rtcssel1
            }
            # [ doc = "Checks if the value of the field is `Rtcssel2`" ]
            # [ inline ( always ) ]
            pub fn is_rtcssel_2(&self) -> bool {
                *self == RtcsselR::Rtcssel2
            }
            # [ doc = "Checks if the value of the field is `Rtcssel3`" ]
            # [ inline ( always ) ]
            pub fn is_rtcssel_3(&self) -> bool {
                *self == RtcsselR::Rtcssel3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcrdyR {
            bits: u8,
        }
        impl RtcrdyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcmodeR {
            bits: u8,
        }
        impl RtcmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcholdR {
            bits: u8,
        }
        impl RtcholdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcbcdR {
            bits: u8,
        }
        impl RtcbcdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcrdyifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcrdyifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtctevifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtctevifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcofifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcofifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcrdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcrdyieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtctevieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtctevieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcofieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcofieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RTCTEV`" ]
        pub enum RtctevW {
            # [ doc = "RTC Time Event: 0 (Min. changed)" ]
            Rtctev0,
            # [ doc = "RTC Time Event: 1 (Hour changed)" ]
            Rtctev1,
            # [ doc = "RTC Time Event: 2 (12:00 changed)" ]
            Rtctev2,
            # [ doc = "RTC Time Event: 3 (00:00 changed)" ]
            Rtctev3,
        }
        impl RtctevW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RtctevW::Rtctev0 => 0,
                    RtctevW::Rtctev1 => 1,
                    RtctevW::Rtctev2 => 2,
                    RtctevW::Rtctev3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtctevW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtctevW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RtctevW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Time Event: 0 (Min. changed)" ]
            # [ inline ( always ) ]
            pub fn rtctev_0(self) -> &'a mut W {
                self.variant(RtctevW::Rtctev0)
            }
            # [ doc = "RTC Time Event: 1 (Hour changed)" ]
            # [ inline ( always ) ]
            pub fn rtctev_1(self) -> &'a mut W {
                self.variant(RtctevW::Rtctev1)
            }
            # [ doc = "RTC Time Event: 2 (12:00 changed)" ]
            # [ inline ( always ) ]
            pub fn rtctev_2(self) -> &'a mut W {
                self.variant(RtctevW::Rtctev2)
            }
            # [ doc = "RTC Time Event: 3 (00:00 changed)" ]
            # [ inline ( always ) ]
            pub fn rtctev_3(self) -> &'a mut W {
                self.variant(RtctevW::Rtctev3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RTCSSEL`" ]
        pub enum RtcsselW {
            # [ doc = "RTC Source Select ACLK" ]
            Rtcssel0,
            # [ doc = "RTC Source Select SMCLK" ]
            Rtcssel1,
            # [ doc = "RTC Source Select RT1PS" ]
            Rtcssel2,
            # [ doc = "RTC Source Select RT1PS" ]
            Rtcssel3,
        }
        impl RtcsselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RtcsselW::Rtcssel0 => 0,
                    RtcsselW::Rtcssel1 => 1,
                    RtcsselW::Rtcssel2 => 2,
                    RtcsselW::Rtcssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcsselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcsselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RtcsselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Source Select ACLK" ]
            # [ inline ( always ) ]
            pub fn rtcssel_0(self) -> &'a mut W {
                self.variant(RtcsselW::Rtcssel0)
            }
            # [ doc = "RTC Source Select SMCLK" ]
            # [ inline ( always ) ]
            pub fn rtcssel_1(self) -> &'a mut W {
                self.variant(RtcsselW::Rtcssel1)
            }
            # [ doc = "RTC Source Select RT1PS" ]
            # [ inline ( always ) ]
            pub fn rtcssel_2(self) -> &'a mut W {
                self.variant(RtcsselW::Rtcssel2)
            }
            # [ doc = "RTC Source Select RT1PS" ]
            # [ inline ( always ) ]
            pub fn rtcssel_3(self) -> &'a mut W {
                self.variant(RtcsselW::Rtcssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcrdyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcmodeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcholdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcholdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcbcdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcbcdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - RTC Ready Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rtcrdyifg(&self) -> RtcrdyifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcrdyifgR { bits }
            }
            # [ doc = "Bit 1 - RTC Alarm Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rtcaifg(&self) -> RtcaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcaifgR { bits }
            }
            # [ doc = "Bit 2 - RTC Time Event Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rtctevifg(&self) -> RtctevifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtctevifgR { bits }
            }
            # [ doc = "Bit 3 - RTC 32kHz cyrstal oscillator fault interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rtcofifg(&self) -> RtcofifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcofifgR { bits }
            }
            # [ doc = "Bit 4 - RTC Ready Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rtcrdyie(&self) -> RtcrdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcrdyieR { bits }
            }
            # [ doc = "Bit 5 - RTC Alarm Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rtcaie(&self) -> RtcaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcaieR { bits }
            }
            # [ doc = "Bit 6 - RTC Time Event Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rtctevie(&self) -> RtctevieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtctevieR { bits }
            }
            # [ doc = "Bit 7 - RTC 32kHz cyrstal oscillator fault interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rtcofie(&self) -> RtcofieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcofieR { bits }
            }
            # [ doc = "Bits 9:10 - RTC Time Event 1" ]
            # [ inline ( always ) ]
            pub fn rtctev(&self) -> RtctevR {
                RtctevR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 9;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bits 11:12 - RTC Source Select 1" ]
            # [ inline ( always ) ]
            pub fn rtcssel(&self) -> RtcsselR {
                RtcsselR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 11;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 12 - RTC Ready" ]
            # [ inline ( always ) ]
            pub fn rtcrdy(&self) -> RtcrdyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcrdyR { bits }
            }
            # [ doc = "Bit 13 - RTC Mode 0:Counter / 1: Calendar" ]
            # [ inline ( always ) ]
            pub fn rtcmode(&self) -> RtcmodeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcmodeR { bits }
            }
            # [ doc = "Bit 14 - RTC Hold" ]
            # [ inline ( always ) ]
            pub fn rtchold(&self) -> RtcholdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcholdR { bits }
            }
            # [ doc = "Bit 15 - RTC BCD 0:Binary / 1:BCD" ]
            # [ inline ( always ) ]
            pub fn rtcbcd(&self) -> RtcbcdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtcbcdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RTC Ready Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rtcrdyifg(&mut self) -> _RtcrdyifgW {
                _RtcrdyifgW { w: self }
            }
            # [ doc = "Bit 1 - RTC Alarm Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rtcaifg(&mut self) -> _RtcaifgW {
                _RtcaifgW { w: self }
            }
            # [ doc = "Bit 2 - RTC Time Event Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rtctevifg(&mut self) -> _RtctevifgW {
                _RtctevifgW { w: self }
            }
            # [ doc = "Bit 3 - RTC 32kHz cyrstal oscillator fault interrupt flag" ]
            # [ inline ( always ) ]
            pub fn rtcofifg(&mut self) -> _RtcofifgW {
                _RtcofifgW { w: self }
            }
            # [ doc = "Bit 4 - RTC Ready Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rtcrdyie(&mut self) -> _RtcrdyieW {
                _RtcrdyieW { w: self }
            }
            # [ doc = "Bit 5 - RTC Alarm Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rtcaie(&mut self) -> _RtcaieW {
                _RtcaieW { w: self }
            }
            # [ doc = "Bit 6 - RTC Time Event Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rtctevie(&mut self) -> _RtctevieW {
                _RtctevieW { w: self }
            }
            # [ doc = "Bit 7 - RTC 32kHz cyrstal oscillator fault interrupt enable" ]
            # [ inline ( always ) ]
            pub fn rtcofie(&mut self) -> _RtcofieW {
                _RtcofieW { w: self }
            }
            # [ doc = "Bits 9:10 - RTC Time Event 1" ]
            # [ inline ( always ) ]
            pub fn rtctev(&mut self) -> _RtctevW {
                _RtctevW { w: self }
            }
            # [ doc = "Bits 11:12 - RTC Source Select 1" ]
            # [ inline ( always ) ]
            pub fn rtcssel(&mut self) -> _RtcsselW {
                _RtcsselW { w: self }
            }
            # [ doc = "Bit 12 - RTC Ready" ]
            # [ inline ( always ) ]
            pub fn rtcrdy(&mut self) -> _RtcrdyW {
                _RtcrdyW { w: self }
            }
            # [ doc = "Bit 13 - RTC Mode 0:Counter / 1: Calendar" ]
            # [ inline ( always ) ]
            pub fn rtcmode(&mut self) -> _RtcmodeW {
                _RtcmodeW { w: self }
            }
            # [ doc = "Bit 14 - RTC Hold" ]
            # [ inline ( always ) ]
            pub fn rtchold(&mut self) -> _RtcholdW {
                _RtcholdW { w: self }
            }
            # [ doc = "Bit 15 - RTC BCD 0:Binary / 1:BCD" ]
            # [ inline ( always ) ]
            pub fn rtcbcd(&mut self) -> _RtcbcdW {
                _RtcbcdW { w: self }
            }
        }
    }
    # [ doc = "Real Timer Control 2/3" ]
    pub struct Rtcctl23 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Timer Control 2/3" ]
    pub mod rtcctl23 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcctl23 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rtccal0R {
            bits: u8,
        }
        impl Rtccal0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rtccal1R {
            bits: u8,
        }
        impl Rtccal1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rtccal2R {
            bits: u8,
        }
        impl Rtccal2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rtccal3R {
            bits: u8,
        }
        impl Rtccal3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rtccal4R {
            bits: u8,
        }
        impl Rtccal4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rtccal5R {
            bits: u8,
        }
        impl Rtccal5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtccalsR {
            bits: u8,
        }
        impl RtccalsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `RTCCALF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum RtccalfR {
            # [ doc = "RTC Calibration Frequency: No Output" ]
            Rtccalf0,
            # [ doc = "RTC Calibration Frequency: 512 Hz" ]
            Rtccalf1,
            # [ doc = "RTC Calibration Frequency: 256 Hz" ]
            Rtccalf2,
            # [ doc = "RTC Calibration Frequency: 1 Hz" ]
            Rtccalf3,
        }
        impl RtccalfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    RtccalfR::Rtccalf0 => 0,
                    RtccalfR::Rtccalf1 => 1,
                    RtccalfR::Rtccalf2 => 2,
                    RtccalfR::Rtccalf3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> RtccalfR {
                match bits {
                    0 => RtccalfR::Rtccalf0,
                    1 => RtccalfR::Rtccalf1,
                    2 => RtccalfR::Rtccalf2,
                    3 => RtccalfR::Rtccalf3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rtccalf0`" ]
            # [ inline ( always ) ]
            pub fn is_rtccalf_0(&self) -> bool {
                *self == RtccalfR::Rtccalf0
            }
            # [ doc = "Checks if the value of the field is `Rtccalf1`" ]
            # [ inline ( always ) ]
            pub fn is_rtccalf_1(&self) -> bool {
                *self == RtccalfR::Rtccalf1
            }
            # [ doc = "Checks if the value of the field is `Rtccalf2`" ]
            # [ inline ( always ) ]
            pub fn is_rtccalf_2(&self) -> bool {
                *self == RtccalfR::Rtccalf2
            }
            # [ doc = "Checks if the value of the field is `Rtccalf3`" ]
            # [ inline ( always ) ]
            pub fn is_rtccalf_3(&self) -> bool {
                *self == RtccalfR::Rtccalf3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtccal0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtccal0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtccal1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtccal1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtccal2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtccal2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtccal3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtccal3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtccal4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtccal4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rtccal5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rtccal5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtccalsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtccalsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RTCCALF`" ]
        pub enum RtccalfW {
            # [ doc = "RTC Calibration Frequency: No Output" ]
            Rtccalf0,
            # [ doc = "RTC Calibration Frequency: 512 Hz" ]
            Rtccalf1,
            # [ doc = "RTC Calibration Frequency: 256 Hz" ]
            Rtccalf2,
            # [ doc = "RTC Calibration Frequency: 1 Hz" ]
            Rtccalf3,
        }
        impl RtccalfW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RtccalfW::Rtccalf0 => 0,
                    RtccalfW::Rtccalf1 => 1,
                    RtccalfW::Rtccalf2 => 2,
                    RtccalfW::Rtccalf3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtccalfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtccalfW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: RtccalfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Calibration Frequency: No Output" ]
            # [ inline ( always ) ]
            pub fn rtccalf_0(self) -> &'a mut W {
                self.variant(RtccalfW::Rtccalf0)
            }
            # [ doc = "RTC Calibration Frequency: 512 Hz" ]
            # [ inline ( always ) ]
            pub fn rtccalf_1(self) -> &'a mut W {
                self.variant(RtccalfW::Rtccalf1)
            }
            # [ doc = "RTC Calibration Frequency: 256 Hz" ]
            # [ inline ( always ) ]
            pub fn rtccalf_2(self) -> &'a mut W {
                self.variant(RtccalfW::Rtccalf2)
            }
            # [ doc = "RTC Calibration Frequency: 1 Hz" ]
            # [ inline ( always ) ]
            pub fn rtccalf_3(self) -> &'a mut W {
                self.variant(RtccalfW::Rtccalf3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - RTC Calibration Bit 0" ]
            # [ inline ( always ) ]
            pub fn rtccal0(&self) -> Rtccal0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rtccal0R { bits }
            }
            # [ doc = "Bit 1 - RTC Calibration Bit 1" ]
            # [ inline ( always ) ]
            pub fn rtccal1(&self) -> Rtccal1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rtccal1R { bits }
            }
            # [ doc = "Bit 2 - RTC Calibration Bit 2" ]
            # [ inline ( always ) ]
            pub fn rtccal2(&self) -> Rtccal2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rtccal2R { bits }
            }
            # [ doc = "Bit 3 - RTC Calibration Bit 3" ]
            # [ inline ( always ) ]
            pub fn rtccal3(&self) -> Rtccal3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rtccal3R { bits }
            }
            # [ doc = "Bit 4 - RTC Calibration Bit 4" ]
            # [ inline ( always ) ]
            pub fn rtccal4(&self) -> Rtccal4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rtccal4R { bits }
            }
            # [ doc = "Bit 5 - RTC Calibration Bit 5" ]
            # [ inline ( always ) ]
            pub fn rtccal5(&self) -> Rtccal5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rtccal5R { bits }
            }
            # [ doc = "Bit 7 - RTC Calibration Sign" ]
            # [ inline ( always ) ]
            pub fn rtccals(&self) -> RtccalsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                RtccalsR { bits }
            }
            # [ doc = "Bits 9:10 - RTC Calibration Frequency Bit 1" ]
            # [ inline ( always ) ]
            pub fn rtccalf(&self) -> RtccalfR {
                RtccalfR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 9;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RTC Calibration Bit 0" ]
            # [ inline ( always ) ]
            pub fn rtccal0(&mut self) -> _Rtccal0W {
                _Rtccal0W { w: self }
            }
            # [ doc = "Bit 1 - RTC Calibration Bit 1" ]
            # [ inline ( always ) ]
            pub fn rtccal1(&mut self) -> _Rtccal1W {
                _Rtccal1W { w: self }
            }
            # [ doc = "Bit 2 - RTC Calibration Bit 2" ]
            # [ inline ( always ) ]
            pub fn rtccal2(&mut self) -> _Rtccal2W {
                _Rtccal2W { w: self }
            }
            # [ doc = "Bit 3 - RTC Calibration Bit 3" ]
            # [ inline ( always ) ]
            pub fn rtccal3(&mut self) -> _Rtccal3W {
                _Rtccal3W { w: self }
            }
            # [ doc = "Bit 4 - RTC Calibration Bit 4" ]
            # [ inline ( always ) ]
            pub fn rtccal4(&mut self) -> _Rtccal4W {
                _Rtccal4W { w: self }
            }
            # [ doc = "Bit 5 - RTC Calibration Bit 5" ]
            # [ inline ( always ) ]
            pub fn rtccal5(&mut self) -> _Rtccal5W {
                _Rtccal5W { w: self }
            }
            # [ doc = "Bit 7 - RTC Calibration Sign" ]
            # [ inline ( always ) ]
            pub fn rtccals(&mut self) -> _RtccalsW {
                _RtccalsW { w: self }
            }
            # [ doc = "Bits 9:10 - RTC Calibration Frequency Bit 1" ]
            # [ inline ( always ) ]
            pub fn rtccalf(&mut self) -> _RtccalfW {
                _RtccalfW { w: self }
            }
        }
    }
    # [ doc = "Real Timer Prescale Timer 0 Control" ]
    pub struct Rtcps0ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Timer Prescale Timer 0 Control" ]
    pub mod rtcps0ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcps0ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rt0psifgR {
            bits: u8,
        }
        impl Rt0psifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rt0psieR {
            bits: u8,
        }
        impl Rt0psieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `RT0IP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rt0ipR {
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /2" ]
            Rt0ip0,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /4" ]
            Rt0ip1,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /8" ]
            Rt0ip2,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /16" ]
            Rt0ip3,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /32" ]
            Rt0ip4,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /64" ]
            Rt0ip5,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /128" ]
            Rt0ip6,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /256" ]
            Rt0ip7,
        }
        impl Rt0ipR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rt0ipR::Rt0ip0 => 0,
                    Rt0ipR::Rt0ip1 => 1,
                    Rt0ipR::Rt0ip2 => 2,
                    Rt0ipR::Rt0ip3 => 3,
                    Rt0ipR::Rt0ip4 => 4,
                    Rt0ipR::Rt0ip5 => 5,
                    Rt0ipR::Rt0ip6 => 6,
                    Rt0ipR::Rt0ip7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rt0ipR {
                match bits {
                    0 => Rt0ipR::Rt0ip0,
                    1 => Rt0ipR::Rt0ip1,
                    2 => Rt0ipR::Rt0ip2,
                    3 => Rt0ipR::Rt0ip3,
                    4 => Rt0ipR::Rt0ip4,
                    5 => Rt0ipR::Rt0ip5,
                    6 => Rt0ipR::Rt0ip6,
                    7 => Rt0ipR::Rt0ip7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rt0ip0`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_0(&self) -> bool {
                *self == Rt0ipR::Rt0ip0
            }
            # [ doc = "Checks if the value of the field is `Rt0ip1`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_1(&self) -> bool {
                *self == Rt0ipR::Rt0ip1
            }
            # [ doc = "Checks if the value of the field is `Rt0ip2`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_2(&self) -> bool {
                *self == Rt0ipR::Rt0ip2
            }
            # [ doc = "Checks if the value of the field is `Rt0ip3`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_3(&self) -> bool {
                *self == Rt0ipR::Rt0ip3
            }
            # [ doc = "Checks if the value of the field is `Rt0ip4`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_4(&self) -> bool {
                *self == Rt0ipR::Rt0ip4
            }
            # [ doc = "Checks if the value of the field is `Rt0ip5`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_5(&self) -> bool {
                *self == Rt0ipR::Rt0ip5
            }
            # [ doc = "Checks if the value of the field is `Rt0ip6`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_6(&self) -> bool {
                *self == Rt0ipR::Rt0ip6
            }
            # [ doc = "Checks if the value of the field is `Rt0ip7`" ]
            # [ inline ( always ) ]
            pub fn is_rt0ip_7(&self) -> bool {
                *self == Rt0ipR::Rt0ip7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rt0psholdR {
            bits: u8,
        }
        impl Rt0psholdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `RT0PSDIV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rt0psdivR {
            # [ doc = "RTC Prescale Timer 0 Clock Divide /2" ]
            Rt0psdiv0,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /4" ]
            Rt0psdiv1,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /8" ]
            Rt0psdiv2,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /16" ]
            Rt0psdiv3,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /32" ]
            Rt0psdiv4,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /64" ]
            Rt0psdiv5,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /128" ]
            Rt0psdiv6,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /256" ]
            Rt0psdiv7,
        }
        impl Rt0psdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rt0psdivR::Rt0psdiv0 => 0,
                    Rt0psdivR::Rt0psdiv1 => 1,
                    Rt0psdivR::Rt0psdiv2 => 2,
                    Rt0psdivR::Rt0psdiv3 => 3,
                    Rt0psdivR::Rt0psdiv4 => 4,
                    Rt0psdivR::Rt0psdiv5 => 5,
                    Rt0psdivR::Rt0psdiv6 => 6,
                    Rt0psdivR::Rt0psdiv7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rt0psdivR {
                match bits {
                    0 => Rt0psdivR::Rt0psdiv0,
                    1 => Rt0psdivR::Rt0psdiv1,
                    2 => Rt0psdivR::Rt0psdiv2,
                    3 => Rt0psdivR::Rt0psdiv3,
                    4 => Rt0psdivR::Rt0psdiv4,
                    5 => Rt0psdivR::Rt0psdiv5,
                    6 => Rt0psdivR::Rt0psdiv6,
                    7 => Rt0psdivR::Rt0psdiv7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv0`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_0(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv0
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv1`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_1(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv1
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv2`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_2(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv2
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv3`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_3(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv3
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv4`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_4(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv4
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv5`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_5(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv5
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv6`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_6(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv6
            }
            # [ doc = "Checks if the value of the field is `Rt0psdiv7`" ]
            # [ inline ( always ) ]
            pub fn is_rt0psdiv_7(&self) -> bool {
                *self == Rt0psdivR::Rt0psdiv7
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt0psifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt0psifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt0psieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt0psieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RT0IP`" ]
        pub enum Rt0ipW {
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /2" ]
            Rt0ip0,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /4" ]
            Rt0ip1,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /8" ]
            Rt0ip2,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /16" ]
            Rt0ip3,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /32" ]
            Rt0ip4,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /64" ]
            Rt0ip5,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /128" ]
            Rt0ip6,
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /256" ]
            Rt0ip7,
        }
        impl Rt0ipW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rt0ipW::Rt0ip0 => 0,
                    Rt0ipW::Rt0ip1 => 1,
                    Rt0ipW::Rt0ip2 => 2,
                    Rt0ipW::Rt0ip3 => 3,
                    Rt0ipW::Rt0ip4 => 4,
                    Rt0ipW::Rt0ip5 => 5,
                    Rt0ipW::Rt0ip6 => 6,
                    Rt0ipW::Rt0ip7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt0ipW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt0ipW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rt0ipW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /2" ]
            # [ inline ( always ) ]
            pub fn rt0ip_0(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip0)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /4" ]
            # [ inline ( always ) ]
            pub fn rt0ip_1(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip1)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /8" ]
            # [ inline ( always ) ]
            pub fn rt0ip_2(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip2)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /16" ]
            # [ inline ( always ) ]
            pub fn rt0ip_3(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip3)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /32" ]
            # [ inline ( always ) ]
            pub fn rt0ip_4(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip4)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /64" ]
            # [ inline ( always ) ]
            pub fn rt0ip_5(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip5)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /128" ]
            # [ inline ( always ) ]
            pub fn rt0ip_6(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip6)
            }
            # [ doc = "RTC Prescale Timer 0 Interrupt Interval /256" ]
            # [ inline ( always ) ]
            pub fn rt0ip_7(self) -> &'a mut W {
                self.variant(Rt0ipW::Rt0ip7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt0psholdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt0psholdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RT0PSDIV`" ]
        pub enum Rt0psdivW {
            # [ doc = "RTC Prescale Timer 0 Clock Divide /2" ]
            Rt0psdiv0,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /4" ]
            Rt0psdiv1,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /8" ]
            Rt0psdiv2,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /16" ]
            Rt0psdiv3,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /32" ]
            Rt0psdiv4,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /64" ]
            Rt0psdiv5,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /128" ]
            Rt0psdiv6,
            # [ doc = "RTC Prescale Timer 0 Clock Divide /256" ]
            Rt0psdiv7,
        }
        impl Rt0psdivW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rt0psdivW::Rt0psdiv0 => 0,
                    Rt0psdivW::Rt0psdiv1 => 1,
                    Rt0psdivW::Rt0psdiv2 => 2,
                    Rt0psdivW::Rt0psdiv3 => 3,
                    Rt0psdivW::Rt0psdiv4 => 4,
                    Rt0psdivW::Rt0psdiv5 => 5,
                    Rt0psdivW::Rt0psdiv6 => 6,
                    Rt0psdivW::Rt0psdiv7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt0psdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt0psdivW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rt0psdivW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /2" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_0(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv0)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /4" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_1(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv1)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /8" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_2(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv2)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /16" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_3(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv3)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /32" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_4(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv4)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /64" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_5(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv5)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /128" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_6(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv6)
            }
            # [ doc = "RTC Prescale Timer 0 Clock Divide /256" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv_7(self) -> &'a mut W {
                self.variant(Rt0psdivW::Rt0psdiv7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - RTC Prescale Timer 0 Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rt0psifg(&self) -> Rt0psifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rt0psifgR { bits }
            }
            # [ doc = "Bit 1 - RTC Prescale Timer 0 Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rt0psie(&self) -> Rt0psieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rt0psieR { bits }
            }
            # [ doc = "Bits 4:6 - RTC Prescale Timer 0 Interrupt Interval Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt0ip(&self) -> Rt0ipR {
                Rt0ipR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 4;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
            # [ doc = "Bit 8 - RTC Prescale Timer 0 Hold" ]
            # [ inline ( always ) ]
            pub fn rt0pshold(&self) -> Rt0psholdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rt0psholdR { bits }
            }
            # [ doc = "Bits 13:15 - RTC Prescale Timer 0 Clock Divide Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv(&self) -> Rt0psdivR {
                Rt0psdivR::_from({
                                     const MASK: u8 = 7;
                                     const OFFSET: u8 = 13;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RTC Prescale Timer 0 Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rt0psifg(&mut self) -> _Rt0psifgW {
                _Rt0psifgW { w: self }
            }
            # [ doc = "Bit 1 - RTC Prescale Timer 0 Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rt0psie(&mut self) -> _Rt0psieW {
                _Rt0psieW { w: self }
            }
            # [ doc = "Bits 4:6 - RTC Prescale Timer 0 Interrupt Interval Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt0ip(&mut self) -> _Rt0ipW {
                _Rt0ipW { w: self }
            }
            # [ doc = "Bit 8 - RTC Prescale Timer 0 Hold" ]
            # [ inline ( always ) ]
            pub fn rt0pshold(&mut self) -> _Rt0psholdW {
                _Rt0psholdW { w: self }
            }
            # [ doc = "Bits 13:15 - RTC Prescale Timer 0 Clock Divide Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt0psdiv(&mut self) -> _Rt0psdivW {
                _Rt0psdivW { w: self }
            }
        }
    }
    # [ doc = "Real Timer Prescale Timer 1 Control" ]
    pub struct Rtcps1ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Timer Prescale Timer 1 Control" ]
    pub mod rtcps1ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcps1ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rt1psifgR {
            bits: u8,
        }
        impl Rt1psifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rt1psieR {
            bits: u8,
        }
        impl Rt1psieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `RT1IP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rt1ipR {
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /2" ]
            Rt1ip0,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /4" ]
            Rt1ip1,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /8" ]
            Rt1ip2,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /16" ]
            Rt1ip3,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /32" ]
            Rt1ip4,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /64" ]
            Rt1ip5,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /128" ]
            Rt1ip6,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /256" ]
            Rt1ip7,
        }
        impl Rt1ipR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rt1ipR::Rt1ip0 => 0,
                    Rt1ipR::Rt1ip1 => 1,
                    Rt1ipR::Rt1ip2 => 2,
                    Rt1ipR::Rt1ip3 => 3,
                    Rt1ipR::Rt1ip4 => 4,
                    Rt1ipR::Rt1ip5 => 5,
                    Rt1ipR::Rt1ip6 => 6,
                    Rt1ipR::Rt1ip7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rt1ipR {
                match bits {
                    0 => Rt1ipR::Rt1ip0,
                    1 => Rt1ipR::Rt1ip1,
                    2 => Rt1ipR::Rt1ip2,
                    3 => Rt1ipR::Rt1ip3,
                    4 => Rt1ipR::Rt1ip4,
                    5 => Rt1ipR::Rt1ip5,
                    6 => Rt1ipR::Rt1ip6,
                    7 => Rt1ipR::Rt1ip7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rt1ip0`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_0(&self) -> bool {
                *self == Rt1ipR::Rt1ip0
            }
            # [ doc = "Checks if the value of the field is `Rt1ip1`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_1(&self) -> bool {
                *self == Rt1ipR::Rt1ip1
            }
            # [ doc = "Checks if the value of the field is `Rt1ip2`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_2(&self) -> bool {
                *self == Rt1ipR::Rt1ip2
            }
            # [ doc = "Checks if the value of the field is `Rt1ip3`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_3(&self) -> bool {
                *self == Rt1ipR::Rt1ip3
            }
            # [ doc = "Checks if the value of the field is `Rt1ip4`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_4(&self) -> bool {
                *self == Rt1ipR::Rt1ip4
            }
            # [ doc = "Checks if the value of the field is `Rt1ip5`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_5(&self) -> bool {
                *self == Rt1ipR::Rt1ip5
            }
            # [ doc = "Checks if the value of the field is `Rt1ip6`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_6(&self) -> bool {
                *self == Rt1ipR::Rt1ip6
            }
            # [ doc = "Checks if the value of the field is `Rt1ip7`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ip_7(&self) -> bool {
                *self == Rt1ipR::Rt1ip7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Rt1psholdR {
            bits: u8,
        }
        impl Rt1psholdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `RT1PSDIV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rt1psdivR {
            # [ doc = "RTC Prescale Timer 1 Clock Divide /2" ]
            Rt1psdiv0,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /4" ]
            Rt1psdiv1,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /8" ]
            Rt1psdiv2,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /16" ]
            Rt1psdiv3,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /32" ]
            Rt1psdiv4,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /64" ]
            Rt1psdiv5,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /128" ]
            Rt1psdiv6,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /256" ]
            Rt1psdiv7,
        }
        impl Rt1psdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rt1psdivR::Rt1psdiv0 => 0,
                    Rt1psdivR::Rt1psdiv1 => 1,
                    Rt1psdivR::Rt1psdiv2 => 2,
                    Rt1psdivR::Rt1psdiv3 => 3,
                    Rt1psdivR::Rt1psdiv4 => 4,
                    Rt1psdivR::Rt1psdiv5 => 5,
                    Rt1psdivR::Rt1psdiv6 => 6,
                    Rt1psdivR::Rt1psdiv7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rt1psdivR {
                match bits {
                    0 => Rt1psdivR::Rt1psdiv0,
                    1 => Rt1psdivR::Rt1psdiv1,
                    2 => Rt1psdivR::Rt1psdiv2,
                    3 => Rt1psdivR::Rt1psdiv3,
                    4 => Rt1psdivR::Rt1psdiv4,
                    5 => Rt1psdivR::Rt1psdiv5,
                    6 => Rt1psdivR::Rt1psdiv6,
                    7 => Rt1psdivR::Rt1psdiv7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv0`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_0(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv0
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv1`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_1(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv1
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv2`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_2(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv2
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv3`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_3(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv3
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv4`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_4(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv4
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv5`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_5(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv5
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv6`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_6(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv6
            }
            # [ doc = "Checks if the value of the field is `Rt1psdiv7`" ]
            # [ inline ( always ) ]
            pub fn is_rt1psdiv_7(&self) -> bool {
                *self == Rt1psdivR::Rt1psdiv7
            }
        }
        # [ doc = "Possible values of the field `RT1SSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Rt1sselR {
            # [ doc = "RTC Prescale Timer Source Select ACLK" ]
            Rt1ssel0,
            # [ doc = "RTC Prescale Timer Source Select SMCLK" ]
            Rt1ssel1,
            # [ doc = "RTC Prescale Timer Source Select RT0PS" ]
            Rt1ssel2,
            # [ doc = "RTC Prescale Timer Source Select RT0PS" ]
            Rt1ssel3,
        }
        impl Rt1sselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Rt1sselR::Rt1ssel0 => 0,
                    Rt1sselR::Rt1ssel1 => 1,
                    Rt1sselR::Rt1ssel2 => 2,
                    Rt1sselR::Rt1ssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Rt1sselR {
                match bits {
                    0 => Rt1sselR::Rt1ssel0,
                    1 => Rt1sselR::Rt1ssel1,
                    2 => Rt1sselR::Rt1ssel2,
                    3 => Rt1sselR::Rt1ssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Rt1ssel0`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ssel_0(&self) -> bool {
                *self == Rt1sselR::Rt1ssel0
            }
            # [ doc = "Checks if the value of the field is `Rt1ssel1`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ssel_1(&self) -> bool {
                *self == Rt1sselR::Rt1ssel1
            }
            # [ doc = "Checks if the value of the field is `Rt1ssel2`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ssel_2(&self) -> bool {
                *self == Rt1sselR::Rt1ssel2
            }
            # [ doc = "Checks if the value of the field is `Rt1ssel3`" ]
            # [ inline ( always ) ]
            pub fn is_rt1ssel_3(&self) -> bool {
                *self == Rt1sselR::Rt1ssel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt1psifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt1psifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt1psieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt1psieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RT1IP`" ]
        pub enum Rt1ipW {
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /2" ]
            Rt1ip0,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /4" ]
            Rt1ip1,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /8" ]
            Rt1ip2,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /16" ]
            Rt1ip3,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /32" ]
            Rt1ip4,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /64" ]
            Rt1ip5,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /128" ]
            Rt1ip6,
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /256" ]
            Rt1ip7,
        }
        impl Rt1ipW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rt1ipW::Rt1ip0 => 0,
                    Rt1ipW::Rt1ip1 => 1,
                    Rt1ipW::Rt1ip2 => 2,
                    Rt1ipW::Rt1ip3 => 3,
                    Rt1ipW::Rt1ip4 => 4,
                    Rt1ipW::Rt1ip5 => 5,
                    Rt1ipW::Rt1ip6 => 6,
                    Rt1ipW::Rt1ip7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt1ipW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt1ipW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rt1ipW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /2" ]
            # [ inline ( always ) ]
            pub fn rt1ip_0(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip0)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /4" ]
            # [ inline ( always ) ]
            pub fn rt1ip_1(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip1)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /8" ]
            # [ inline ( always ) ]
            pub fn rt1ip_2(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip2)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /16" ]
            # [ inline ( always ) ]
            pub fn rt1ip_3(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip3)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /32" ]
            # [ inline ( always ) ]
            pub fn rt1ip_4(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip4)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /64" ]
            # [ inline ( always ) ]
            pub fn rt1ip_5(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip5)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /128" ]
            # [ inline ( always ) ]
            pub fn rt1ip_6(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip6)
            }
            # [ doc = "RTC Prescale Timer 1 Interrupt Interval /256" ]
            # [ inline ( always ) ]
            pub fn rt1ip_7(self) -> &'a mut W {
                self.variant(Rt1ipW::Rt1ip7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt1psholdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt1psholdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RT1PSDIV`" ]
        pub enum Rt1psdivW {
            # [ doc = "RTC Prescale Timer 1 Clock Divide /2" ]
            Rt1psdiv0,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /4" ]
            Rt1psdiv1,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /8" ]
            Rt1psdiv2,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /16" ]
            Rt1psdiv3,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /32" ]
            Rt1psdiv4,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /64" ]
            Rt1psdiv5,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /128" ]
            Rt1psdiv6,
            # [ doc = "RTC Prescale Timer 1 Clock Divide /256" ]
            Rt1psdiv7,
        }
        impl Rt1psdivW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rt1psdivW::Rt1psdiv0 => 0,
                    Rt1psdivW::Rt1psdiv1 => 1,
                    Rt1psdivW::Rt1psdiv2 => 2,
                    Rt1psdivW::Rt1psdiv3 => 3,
                    Rt1psdivW::Rt1psdiv4 => 4,
                    Rt1psdivW::Rt1psdiv5 => 5,
                    Rt1psdivW::Rt1psdiv6 => 6,
                    Rt1psdivW::Rt1psdiv7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt1psdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt1psdivW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rt1psdivW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /2" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_0(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv0)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /4" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_1(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv1)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /8" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_2(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv2)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /16" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_3(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv3)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /32" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_4(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv4)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /64" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_5(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv5)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /128" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_6(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv6)
            }
            # [ doc = "RTC Prescale Timer 1 Clock Divide /256" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv_7(self) -> &'a mut W {
                self.variant(Rt1psdivW::Rt1psdiv7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `RT1SSEL`" ]
        pub enum Rt1sselW {
            # [ doc = "RTC Prescale Timer Source Select ACLK" ]
            Rt1ssel0,
            # [ doc = "RTC Prescale Timer Source Select SMCLK" ]
            Rt1ssel1,
            # [ doc = "RTC Prescale Timer Source Select RT0PS" ]
            Rt1ssel2,
            # [ doc = "RTC Prescale Timer Source Select RT0PS" ]
            Rt1ssel3,
        }
        impl Rt1sselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Rt1sselW::Rt1ssel0 => 0,
                    Rt1sselW::Rt1ssel1 => 1,
                    Rt1sselW::Rt1ssel2 => 2,
                    Rt1sselW::Rt1ssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Rt1sselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Rt1sselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Rt1sselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "RTC Prescale Timer Source Select ACLK" ]
            # [ inline ( always ) ]
            pub fn rt1ssel_0(self) -> &'a mut W {
                self.variant(Rt1sselW::Rt1ssel0)
            }
            # [ doc = "RTC Prescale Timer Source Select SMCLK" ]
            # [ inline ( always ) ]
            pub fn rt1ssel_1(self) -> &'a mut W {
                self.variant(Rt1sselW::Rt1ssel1)
            }
            # [ doc = "RTC Prescale Timer Source Select RT0PS" ]
            # [ inline ( always ) ]
            pub fn rt1ssel_2(self) -> &'a mut W {
                self.variant(Rt1sselW::Rt1ssel2)
            }
            # [ doc = "RTC Prescale Timer Source Select RT0PS" ]
            # [ inline ( always ) ]
            pub fn rt1ssel_3(self) -> &'a mut W {
                self.variant(Rt1sselW::Rt1ssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - RTC Prescale Timer 1 Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rt1psifg(&self) -> Rt1psifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rt1psifgR { bits }
            }
            # [ doc = "Bit 1 - RTC Prescale Timer 1 Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rt1psie(&self) -> Rt1psieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rt1psieR { bits }
            }
            # [ doc = "Bits 4:6 - RTC Prescale Timer 1 Interrupt Interval Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt1ip(&self) -> Rt1ipR {
                Rt1ipR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 4;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
            # [ doc = "Bit 8 - RTC Prescale Timer 1 Hold" ]
            # [ inline ( always ) ]
            pub fn rt1pshold(&self) -> Rt1psholdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Rt1psholdR { bits }
            }
            # [ doc = "Bits 13:15 - RTC Prescale Timer 1 Clock Divide Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv(&self) -> Rt1psdivR {
                Rt1psdivR::_from({
                                     const MASK: u8 = 7;
                                     const OFFSET: u8 = 13;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bits 15:16 - RTC Prescale Timer 1 Source Select Bit 1" ]
            # [ inline ( always ) ]
            pub fn rt1ssel(&self) -> Rt1sselR {
                Rt1sselR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 15;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - RTC Prescale Timer 1 Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn rt1psifg(&mut self) -> _Rt1psifgW {
                _Rt1psifgW { w: self }
            }
            # [ doc = "Bit 1 - RTC Prescale Timer 1 Interrupt Enable Flag" ]
            # [ inline ( always ) ]
            pub fn rt1psie(&mut self) -> _Rt1psieW {
                _Rt1psieW { w: self }
            }
            # [ doc = "Bits 4:6 - RTC Prescale Timer 1 Interrupt Interval Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt1ip(&mut self) -> _Rt1ipW {
                _Rt1ipW { w: self }
            }
            # [ doc = "Bit 8 - RTC Prescale Timer 1 Hold" ]
            # [ inline ( always ) ]
            pub fn rt1pshold(&mut self) -> _Rt1psholdW {
                _Rt1psholdW { w: self }
            }
            # [ doc = "Bits 13:15 - RTC Prescale Timer 1 Clock Divide Bit: 2" ]
            # [ inline ( always ) ]
            pub fn rt1psdiv(&mut self) -> _Rt1psdivW {
                _Rt1psdivW { w: self }
            }
            # [ doc = "Bits 15:16 - RTC Prescale Timer 1 Source Select Bit 1" ]
            # [ inline ( always ) ]
            pub fn rt1ssel(&mut self) -> _Rt1sselW {
                _Rt1sselW { w: self }
            }
        }
    }
    # [ doc = "Real Timer Prescale Timer Control" ]
    pub struct Rtcps {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Timer Prescale Timer Control" ]
    pub mod rtcps {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcps {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Interrupt Vector" ]
    pub struct Rtciv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Interrupt Vector" ]
    pub mod rtciv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtciv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Time 0" ]
    pub struct Rtctim0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Time 0" ]
    pub mod rtctim0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtctim0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Time 1" ]
    pub struct Rtctim1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Time 1" ]
    pub mod rtctim1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtctim1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Date" ]
    pub struct Rtcdate {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Date" ]
    pub mod rtcdate {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcdate {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Year" ]
    pub struct Rtcyear {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Year" ]
    pub mod rtcyear {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcyear {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Alarm Min/Hour" ]
    pub struct Rtcaminhr {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Alarm Min/Hour" ]
    pub mod rtcaminhr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcaminhr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Alarm day of week/day" ]
    pub struct Rtcadowday {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Alarm day of week/day" ]
    pub mod rtcadowday {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcadowday {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Binary-to-BCD conversion register" ]
    pub struct Bin2bcd {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Binary-to-BCD conversion register" ]
    pub mod bin2bcd {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Bin2bcd {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time BCD-to-binary conversion register" ]
    pub struct Bcd2bin {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time BCD-to-binary conversion register" ]
    pub mod bcd2bin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Bcd2bin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Seconds" ]
    pub struct Rtcsec {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Seconds" ]
    pub mod rtcsec {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcsec {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds0R {
            bits: u8,
        }
        impl Seconds0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds1R {
            bits: u8,
        }
        impl Seconds1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds2R {
            bits: u8,
        }
        impl Seconds2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds3R {
            bits: u8,
        }
        impl Seconds3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds4R {
            bits: u8,
        }
        impl Seconds4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds5R {
            bits: u8,
        }
        impl Seconds5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Seconds6R {
            bits: u8,
        }
        impl Seconds6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Seconds6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Seconds6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Seconds Bit: 0" ]
            # [ inline ( always ) ]
            pub fn seconds0(&self) -> Seconds0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Seconds Bit: 1" ]
            # [ inline ( always ) ]
            pub fn seconds1(&self) -> Seconds1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Seconds Bit: 2" ]
            # [ inline ( always ) ]
            pub fn seconds2(&self) -> Seconds2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Seconds Bit: 3" ]
            # [ inline ( always ) ]
            pub fn seconds3(&self) -> Seconds3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Seconds Bit: 4" ]
            # [ inline ( always ) ]
            pub fn seconds4(&self) -> Seconds4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Seconds Bit: 5" ]
            # [ inline ( always ) ]
            pub fn seconds5(&self) -> Seconds5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Seconds Bit: 6" ]
            # [ inline ( always ) ]
            pub fn seconds6(&self) -> Seconds6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Seconds6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Seconds Bit: 0" ]
            # [ inline ( always ) ]
            pub fn seconds0(&mut self) -> _Seconds0W {
                _Seconds0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Seconds Bit: 1" ]
            # [ inline ( always ) ]
            pub fn seconds1(&mut self) -> _Seconds1W {
                _Seconds1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Seconds Bit: 2" ]
            # [ inline ( always ) ]
            pub fn seconds2(&mut self) -> _Seconds2W {
                _Seconds2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Seconds Bit: 3" ]
            # [ inline ( always ) ]
            pub fn seconds3(&mut self) -> _Seconds3W {
                _Seconds3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Seconds Bit: 4" ]
            # [ inline ( always ) ]
            pub fn seconds4(&mut self) -> _Seconds4W {
                _Seconds4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Seconds Bit: 5" ]
            # [ inline ( always ) ]
            pub fn seconds5(&mut self) -> _Seconds5W {
                _Seconds5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Seconds Bit: 6" ]
            # [ inline ( always ) ]
            pub fn seconds6(&mut self) -> _Seconds6W {
                _Seconds6W { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Minutes" ]
    pub struct Rtcmin {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Minutes" ]
    pub mod rtcmin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcmin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes0R {
            bits: u8,
        }
        impl Minutes0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes1R {
            bits: u8,
        }
        impl Minutes1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes2R {
            bits: u8,
        }
        impl Minutes2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes3R {
            bits: u8,
        }
        impl Minutes3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes4R {
            bits: u8,
        }
        impl Minutes4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes5R {
            bits: u8,
        }
        impl Minutes5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes6R {
            bits: u8,
        }
        impl Minutes6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Minutes Bit: 0" ]
            # [ inline ( always ) ]
            pub fn minutes0(&self) -> Minutes0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Minutes Bit: 1" ]
            # [ inline ( always ) ]
            pub fn minutes1(&self) -> Minutes1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Minutes Bit: 2" ]
            # [ inline ( always ) ]
            pub fn minutes2(&self) -> Minutes2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Minutes Bit: 3" ]
            # [ inline ( always ) ]
            pub fn minutes3(&self) -> Minutes3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Minutes Bit: 4" ]
            # [ inline ( always ) ]
            pub fn minutes4(&self) -> Minutes4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Minutes Bit: 5" ]
            # [ inline ( always ) ]
            pub fn minutes5(&self) -> Minutes5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Minutes Bit: 6" ]
            # [ inline ( always ) ]
            pub fn minutes6(&self) -> Minutes6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Minutes Bit: 0" ]
            # [ inline ( always ) ]
            pub fn minutes0(&mut self) -> _Minutes0W {
                _Minutes0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Minutes Bit: 1" ]
            # [ inline ( always ) ]
            pub fn minutes1(&mut self) -> _Minutes1W {
                _Minutes1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Minutes Bit: 2" ]
            # [ inline ( always ) ]
            pub fn minutes2(&mut self) -> _Minutes2W {
                _Minutes2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Minutes Bit: 3" ]
            # [ inline ( always ) ]
            pub fn minutes3(&mut self) -> _Minutes3W {
                _Minutes3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Minutes Bit: 4" ]
            # [ inline ( always ) ]
            pub fn minutes4(&mut self) -> _Minutes4W {
                _Minutes4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Minutes Bit: 5" ]
            # [ inline ( always ) ]
            pub fn minutes5(&mut self) -> _Minutes5W {
                _Minutes5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Minutes Bit: 6" ]
            # [ inline ( always ) ]
            pub fn minutes6(&mut self) -> _Minutes6W {
                _Minutes6W { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Hour" ]
    pub struct Rtchour {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Hour" ]
    pub mod rtchour {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtchour {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour0R {
            bits: u8,
        }
        impl Hour0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour1R {
            bits: u8,
        }
        impl Hour1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour2R {
            bits: u8,
        }
        impl Hour2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour3R {
            bits: u8,
        }
        impl Hour3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour4R {
            bits: u8,
        }
        impl Hour4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour5R {
            bits: u8,
        }
        impl Hour5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour6R {
            bits: u8,
        }
        impl Hour6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Hour Bit: 0" ]
            # [ inline ( always ) ]
            pub fn hour0(&self) -> Hour0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Hour Bit: 1" ]
            # [ inline ( always ) ]
            pub fn hour1(&self) -> Hour1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Hour Bit: 2" ]
            # [ inline ( always ) ]
            pub fn hour2(&self) -> Hour2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Hour Bit: 3" ]
            # [ inline ( always ) ]
            pub fn hour3(&self) -> Hour3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Hour Bit: 4" ]
            # [ inline ( always ) ]
            pub fn hour4(&self) -> Hour4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Hour Bit: 5" ]
            # [ inline ( always ) ]
            pub fn hour5(&self) -> Hour5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Hour Bit: 6" ]
            # [ inline ( always ) ]
            pub fn hour6(&self) -> Hour6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Hour Bit: 0" ]
            # [ inline ( always ) ]
            pub fn hour0(&mut self) -> _Hour0W {
                _Hour0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Hour Bit: 1" ]
            # [ inline ( always ) ]
            pub fn hour1(&mut self) -> _Hour1W {
                _Hour1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Hour Bit: 2" ]
            # [ inline ( always ) ]
            pub fn hour2(&mut self) -> _Hour2W {
                _Hour2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Hour Bit: 3" ]
            # [ inline ( always ) ]
            pub fn hour3(&mut self) -> _Hour3W {
                _Hour3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Hour Bit: 4" ]
            # [ inline ( always ) ]
            pub fn hour4(&mut self) -> _Hour4W {
                _Hour4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Hour Bit: 5" ]
            # [ inline ( always ) ]
            pub fn hour5(&mut self) -> _Hour5W {
                _Hour5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Hour Bit: 6" ]
            # [ inline ( always ) ]
            pub fn hour6(&mut self) -> _Hour6W {
                _Hour6W { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Day of week" ]
    pub struct Rtcdow {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Day of week" ]
    pub mod rtcdow {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcdow {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow0R {
            bits: u8,
        }
        impl Dow0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow1R {
            bits: u8,
        }
        impl Dow1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow2R {
            bits: u8,
        }
        impl Dow2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow3R {
            bits: u8,
        }
        impl Dow3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow4R {
            bits: u8,
        }
        impl Dow4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow5R {
            bits: u8,
        }
        impl Dow5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow6R {
            bits: u8,
        }
        impl Dow6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock DOW Bit: 0" ]
            # [ inline ( always ) ]
            pub fn dow0(&self) -> Dow0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock DOW Bit: 1" ]
            # [ inline ( always ) ]
            pub fn dow1(&self) -> Dow1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock DOW Bit: 2" ]
            # [ inline ( always ) ]
            pub fn dow2(&self) -> Dow2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock DOW Bit: 3" ]
            # [ inline ( always ) ]
            pub fn dow3(&self) -> Dow3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock DOW Bit: 4" ]
            # [ inline ( always ) ]
            pub fn dow4(&self) -> Dow4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock DOW Bit: 5" ]
            # [ inline ( always ) ]
            pub fn dow5(&self) -> Dow5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock DOW Bit: 6" ]
            # [ inline ( always ) ]
            pub fn dow6(&self) -> Dow6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock DOW Bit: 0" ]
            # [ inline ( always ) ]
            pub fn dow0(&mut self) -> _Dow0W {
                _Dow0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock DOW Bit: 1" ]
            # [ inline ( always ) ]
            pub fn dow1(&mut self) -> _Dow1W {
                _Dow1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock DOW Bit: 2" ]
            # [ inline ( always ) ]
            pub fn dow2(&mut self) -> _Dow2W {
                _Dow2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock DOW Bit: 3" ]
            # [ inline ( always ) ]
            pub fn dow3(&mut self) -> _Dow3W {
                _Dow3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock DOW Bit: 4" ]
            # [ inline ( always ) ]
            pub fn dow4(&mut self) -> _Dow4W {
                _Dow4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock DOW Bit: 5" ]
            # [ inline ( always ) ]
            pub fn dow5(&mut self) -> _Dow5W {
                _Dow5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock DOW Bit: 6" ]
            # [ inline ( always ) ]
            pub fn dow6(&mut self) -> _Dow6W {
                _Dow6W { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Day" ]
    pub struct Rtcday {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Day" ]
    pub mod rtcday {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcday {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day0R {
            bits: u8,
        }
        impl Day0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day1R {
            bits: u8,
        }
        impl Day1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day2R {
            bits: u8,
        }
        impl Day2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day3R {
            bits: u8,
        }
        impl Day3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day4R {
            bits: u8,
        }
        impl Day4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day5R {
            bits: u8,
        }
        impl Day5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day6R {
            bits: u8,
        }
        impl Day6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Day Bit: 0" ]
            # [ inline ( always ) ]
            pub fn day0(&self) -> Day0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Day Bit: 1" ]
            # [ inline ( always ) ]
            pub fn day1(&self) -> Day1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Day Bit: 2" ]
            # [ inline ( always ) ]
            pub fn day2(&self) -> Day2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Day Bit: 3" ]
            # [ inline ( always ) ]
            pub fn day3(&self) -> Day3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Day Bit: 4" ]
            # [ inline ( always ) ]
            pub fn day4(&self) -> Day4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Day Bit: 5" ]
            # [ inline ( always ) ]
            pub fn day5(&self) -> Day5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Day Bit: 6" ]
            # [ inline ( always ) ]
            pub fn day6(&self) -> Day6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Day Bit: 0" ]
            # [ inline ( always ) ]
            pub fn day0(&mut self) -> _Day0W {
                _Day0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Day Bit: 1" ]
            # [ inline ( always ) ]
            pub fn day1(&mut self) -> _Day1W {
                _Day1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Day Bit: 2" ]
            # [ inline ( always ) ]
            pub fn day2(&mut self) -> _Day2W {
                _Day2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Day Bit: 3" ]
            # [ inline ( always ) ]
            pub fn day3(&mut self) -> _Day3W {
                _Day3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Day Bit: 4" ]
            # [ inline ( always ) ]
            pub fn day4(&mut self) -> _Day4W {
                _Day4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Day Bit: 5" ]
            # [ inline ( always ) ]
            pub fn day5(&mut self) -> _Day5W {
                _Day5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Day Bit: 6" ]
            # [ inline ( always ) ]
            pub fn day6(&mut self) -> _Day6W {
                _Day6W { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Month" ]
    pub struct Rtcmon {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Month" ]
    pub mod rtcmon {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcmon {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month0R {
            bits: u8,
        }
        impl Month0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month1R {
            bits: u8,
        }
        impl Month1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month2R {
            bits: u8,
        }
        impl Month2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month3R {
            bits: u8,
        }
        impl Month3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month4R {
            bits: u8,
        }
        impl Month4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month5R {
            bits: u8,
        }
        impl Month5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Month6R {
            bits: u8,
        }
        impl Month6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Month6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Month6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Month Bit: 0" ]
            # [ inline ( always ) ]
            pub fn month0(&self) -> Month0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Month Bit: 1" ]
            # [ inline ( always ) ]
            pub fn month1(&self) -> Month1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Month Bit: 2" ]
            # [ inline ( always ) ]
            pub fn month2(&self) -> Month2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Month Bit: 3" ]
            # [ inline ( always ) ]
            pub fn month3(&self) -> Month3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Month Bit: 4" ]
            # [ inline ( always ) ]
            pub fn month4(&self) -> Month4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Month Bit: 5" ]
            # [ inline ( always ) ]
            pub fn month5(&self) -> Month5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Month Bit: 6" ]
            # [ inline ( always ) ]
            pub fn month6(&self) -> Month6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Month6R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Month Bit: 0" ]
            # [ inline ( always ) ]
            pub fn month0(&mut self) -> _Month0W {
                _Month0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Month Bit: 1" ]
            # [ inline ( always ) ]
            pub fn month1(&mut self) -> _Month1W {
                _Month1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Month Bit: 2" ]
            # [ inline ( always ) ]
            pub fn month2(&mut self) -> _Month2W {
                _Month2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Month Bit: 3" ]
            # [ inline ( always ) ]
            pub fn month3(&mut self) -> _Month3W {
                _Month3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Month Bit: 4" ]
            # [ inline ( always ) ]
            pub fn month4(&mut self) -> _Month4W {
                _Month4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Month Bit: 5" ]
            # [ inline ( always ) ]
            pub fn month5(&mut self) -> _Month5W {
                _Month5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Month Bit: 6" ]
            # [ inline ( always ) ]
            pub fn month6(&mut self) -> _Month6W {
                _Month6W { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Alarm Min" ]
    pub struct Rtcamin {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Alarm Min" ]
    pub mod rtcamin {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcamin {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes0R {
            bits: u8,
        }
        impl Minutes0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes1R {
            bits: u8,
        }
        impl Minutes1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes2R {
            bits: u8,
        }
        impl Minutes2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes3R {
            bits: u8,
        }
        impl Minutes3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes4R {
            bits: u8,
        }
        impl Minutes4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes5R {
            bits: u8,
        }
        impl Minutes5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Minutes6R {
            bits: u8,
        }
        impl Minutes6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcaeR {
            bits: u8,
        }
        impl RtcaeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Minutes6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Minutes6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcaeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcaeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Minutes Bit: 0" ]
            # [ inline ( always ) ]
            pub fn minutes0(&self) -> Minutes0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Minutes Bit: 1" ]
            # [ inline ( always ) ]
            pub fn minutes1(&self) -> Minutes1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Minutes Bit: 2" ]
            # [ inline ( always ) ]
            pub fn minutes2(&self) -> Minutes2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Minutes Bit: 3" ]
            # [ inline ( always ) ]
            pub fn minutes3(&self) -> Minutes3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Minutes Bit: 4" ]
            # [ inline ( always ) ]
            pub fn minutes4(&self) -> Minutes4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Minutes Bit: 5" ]
            # [ inline ( always ) ]
            pub fn minutes5(&self) -> Minutes5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Minutes Bit: 6" ]
            # [ inline ( always ) ]
            pub fn minutes6(&self) -> Minutes6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Minutes6R { bits }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&self) -> RtcaeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                RtcaeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Minutes Bit: 0" ]
            # [ inline ( always ) ]
            pub fn minutes0(&mut self) -> _Minutes0W {
                _Minutes0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Minutes Bit: 1" ]
            # [ inline ( always ) ]
            pub fn minutes1(&mut self) -> _Minutes1W {
                _Minutes1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Minutes Bit: 2" ]
            # [ inline ( always ) ]
            pub fn minutes2(&mut self) -> _Minutes2W {
                _Minutes2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Minutes Bit: 3" ]
            # [ inline ( always ) ]
            pub fn minutes3(&mut self) -> _Minutes3W {
                _Minutes3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Minutes Bit: 4" ]
            # [ inline ( always ) ]
            pub fn minutes4(&mut self) -> _Minutes4W {
                _Minutes4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Minutes Bit: 5" ]
            # [ inline ( always ) ]
            pub fn minutes5(&mut self) -> _Minutes5W {
                _Minutes5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Minutes Bit: 6" ]
            # [ inline ( always ) ]
            pub fn minutes6(&mut self) -> _Minutes6W {
                _Minutes6W { w: self }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&mut self) -> _RtcaeW {
                _RtcaeW { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Alarm Hour" ]
    pub struct Rtcahour {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Alarm Hour" ]
    pub mod rtcahour {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcahour {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour0R {
            bits: u8,
        }
        impl Hour0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour1R {
            bits: u8,
        }
        impl Hour1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour2R {
            bits: u8,
        }
        impl Hour2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour3R {
            bits: u8,
        }
        impl Hour3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour4R {
            bits: u8,
        }
        impl Hour4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour5R {
            bits: u8,
        }
        impl Hour5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Hour6R {
            bits: u8,
        }
        impl Hour6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcaeR {
            bits: u8,
        }
        impl RtcaeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Hour6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hour6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcaeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcaeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Hour Bit: 0" ]
            # [ inline ( always ) ]
            pub fn hour0(&self) -> Hour0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Hour Bit: 1" ]
            # [ inline ( always ) ]
            pub fn hour1(&self) -> Hour1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Hour Bit: 2" ]
            # [ inline ( always ) ]
            pub fn hour2(&self) -> Hour2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Hour Bit: 3" ]
            # [ inline ( always ) ]
            pub fn hour3(&self) -> Hour3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Hour Bit: 4" ]
            # [ inline ( always ) ]
            pub fn hour4(&self) -> Hour4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Hour Bit: 5" ]
            # [ inline ( always ) ]
            pub fn hour5(&self) -> Hour5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Hour Bit: 6" ]
            # [ inline ( always ) ]
            pub fn hour6(&self) -> Hour6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Hour6R { bits }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&self) -> RtcaeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                RtcaeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Hour Bit: 0" ]
            # [ inline ( always ) ]
            pub fn hour0(&mut self) -> _Hour0W {
                _Hour0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Hour Bit: 1" ]
            # [ inline ( always ) ]
            pub fn hour1(&mut self) -> _Hour1W {
                _Hour1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Hour Bit: 2" ]
            # [ inline ( always ) ]
            pub fn hour2(&mut self) -> _Hour2W {
                _Hour2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Hour Bit: 3" ]
            # [ inline ( always ) ]
            pub fn hour3(&mut self) -> _Hour3W {
                _Hour3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Hour Bit: 4" ]
            # [ inline ( always ) ]
            pub fn hour4(&mut self) -> _Hour4W {
                _Hour4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Hour Bit: 5" ]
            # [ inline ( always ) ]
            pub fn hour5(&mut self) -> _Hour5W {
                _Hour5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Hour Bit: 6" ]
            # [ inline ( always ) ]
            pub fn hour6(&mut self) -> _Hour6W {
                _Hour6W { w: self }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&mut self) -> _RtcaeW {
                _RtcaeW { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Alarm Day of week" ]
    pub struct Rtcadow {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Alarm Day of week" ]
    pub mod rtcadow {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcadow {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow0R {
            bits: u8,
        }
        impl Dow0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow1R {
            bits: u8,
        }
        impl Dow1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow2R {
            bits: u8,
        }
        impl Dow2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow3R {
            bits: u8,
        }
        impl Dow3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow4R {
            bits: u8,
        }
        impl Dow4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow5R {
            bits: u8,
        }
        impl Dow5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dow6R {
            bits: u8,
        }
        impl Dow6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcaeR {
            bits: u8,
        }
        impl RtcaeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dow6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dow6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcaeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcaeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock DOW Bit: 0" ]
            # [ inline ( always ) ]
            pub fn dow0(&self) -> Dow0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock DOW Bit: 1" ]
            # [ inline ( always ) ]
            pub fn dow1(&self) -> Dow1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock DOW Bit: 2" ]
            # [ inline ( always ) ]
            pub fn dow2(&self) -> Dow2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock DOW Bit: 3" ]
            # [ inline ( always ) ]
            pub fn dow3(&self) -> Dow3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock DOW Bit: 4" ]
            # [ inline ( always ) ]
            pub fn dow4(&self) -> Dow4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock DOW Bit: 5" ]
            # [ inline ( always ) ]
            pub fn dow5(&self) -> Dow5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock DOW Bit: 6" ]
            # [ inline ( always ) ]
            pub fn dow6(&self) -> Dow6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Dow6R { bits }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&self) -> RtcaeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                RtcaeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock DOW Bit: 0" ]
            # [ inline ( always ) ]
            pub fn dow0(&mut self) -> _Dow0W {
                _Dow0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock DOW Bit: 1" ]
            # [ inline ( always ) ]
            pub fn dow1(&mut self) -> _Dow1W {
                _Dow1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock DOW Bit: 2" ]
            # [ inline ( always ) ]
            pub fn dow2(&mut self) -> _Dow2W {
                _Dow2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock DOW Bit: 3" ]
            # [ inline ( always ) ]
            pub fn dow3(&mut self) -> _Dow3W {
                _Dow3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock DOW Bit: 4" ]
            # [ inline ( always ) ]
            pub fn dow4(&mut self) -> _Dow4W {
                _Dow4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock DOW Bit: 5" ]
            # [ inline ( always ) ]
            pub fn dow5(&mut self) -> _Dow5W {
                _Dow5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock DOW Bit: 6" ]
            # [ inline ( always ) ]
            pub fn dow6(&mut self) -> _Dow6W {
                _Dow6W { w: self }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&mut self) -> _RtcaeW {
                _RtcaeW { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Alarm Day" ]
    pub struct Rtcaday {
        register: VolatileCell<u8>,
    }
    # [ doc = "Real Time Clock Alarm Day" ]
    pub mod rtcaday {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Rtcaday {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day0R {
            bits: u8,
        }
        impl Day0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day1R {
            bits: u8,
        }
        impl Day1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day2R {
            bits: u8,
        }
        impl Day2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day3R {
            bits: u8,
        }
        impl Day3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day4R {
            bits: u8,
        }
        impl Day4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day5R {
            bits: u8,
        }
        impl Day5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Day6R {
            bits: u8,
        }
        impl Day6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct RtcaeR {
            bits: u8,
        }
        impl RtcaeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Day6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Day6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _RtcaeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcaeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Real Time Clock Day Bit: 0" ]
            # [ inline ( always ) ]
            pub fn day0(&self) -> Day0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day0R { bits }
            }
            # [ doc = "Bit 1 - Real Time Clock Day Bit: 1" ]
            # [ inline ( always ) ]
            pub fn day1(&self) -> Day1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day1R { bits }
            }
            # [ doc = "Bit 2 - Real Time Clock Day Bit: 2" ]
            # [ inline ( always ) ]
            pub fn day2(&self) -> Day2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day2R { bits }
            }
            # [ doc = "Bit 3 - Real Time Clock Day Bit: 3" ]
            # [ inline ( always ) ]
            pub fn day3(&self) -> Day3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day3R { bits }
            }
            # [ doc = "Bit 4 - Real Time Clock Day Bit: 4" ]
            # [ inline ( always ) ]
            pub fn day4(&self) -> Day4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day4R { bits }
            }
            # [ doc = "Bit 5 - Real Time Clock Day Bit: 5" ]
            # [ inline ( always ) ]
            pub fn day5(&self) -> Day5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day5R { bits }
            }
            # [ doc = "Bit 6 - Real Time Clock Day Bit: 6" ]
            # [ inline ( always ) ]
            pub fn day6(&self) -> Day6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Day6R { bits }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&self) -> RtcaeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                RtcaeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Real Time Clock Day Bit: 0" ]
            # [ inline ( always ) ]
            pub fn day0(&mut self) -> _Day0W {
                _Day0W { w: self }
            }
            # [ doc = "Bit 1 - Real Time Clock Day Bit: 1" ]
            # [ inline ( always ) ]
            pub fn day1(&mut self) -> _Day1W {
                _Day1W { w: self }
            }
            # [ doc = "Bit 2 - Real Time Clock Day Bit: 2" ]
            # [ inline ( always ) ]
            pub fn day2(&mut self) -> _Day2W {
                _Day2W { w: self }
            }
            # [ doc = "Bit 3 - Real Time Clock Day Bit: 3" ]
            # [ inline ( always ) ]
            pub fn day3(&mut self) -> _Day3W {
                _Day3W { w: self }
            }
            # [ doc = "Bit 4 - Real Time Clock Day Bit: 4" ]
            # [ inline ( always ) ]
            pub fn day4(&mut self) -> _Day4W {
                _Day4W { w: self }
            }
            # [ doc = "Bit 5 - Real Time Clock Day Bit: 5" ]
            # [ inline ( always ) ]
            pub fn day5(&mut self) -> _Day5W {
                _Day5W { w: self }
            }
            # [ doc = "Bit 6 - Real Time Clock Day Bit: 6" ]
            # [ inline ( always ) ]
            pub fn day6(&mut self) -> _Day6W {
                _Day6W { w: self }
            }
            # [ doc = "Bit 7 - Real Time Clock Alarm enable" ]
            # [ inline ( always ) ]
            pub fn rtcae(&mut self) -> _RtcaeW {
                _RtcaeW { w: self }
            }
        }
    }
    # [ doc = "Real Time Clock Time 0" ]
    pub struct Rtcnt12 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Time 0" ]
    pub mod rtcnt12 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcnt12 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Real Time Clock Time 1" ]
    pub struct Rtcnt34 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Real Time Clock Time 1" ]
    pub mod rtcnt34 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Rtcnt34 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "RTC_D Real Time Clock" ]
pub struct RtcDRealTimeClock {
    register_block: rtc_d_real_time_clock::RegisterBlock,
}
impl Deref for RtcDRealTimeClock {
    type Target = rtc_d_real_time_clock::RegisterBlock;
    fn deref(&self) -> &rtc_d_real_time_clock::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SFR Special Function Registers" ]
pub const SFR_SPECIAL_FUNCTION_REGISTERS: Peripheral<SfrSpecialFunctionRegisters> =
    unsafe { Peripheral::new(0) };
# [ doc = "SFR Special Function Registers" ]
pub mod sfr_special_function_registers {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 256usize],
        # [ doc = "0x100 - Interrupt Enable 1" ]
        pub sfrie1: Sfrie1,
        # [ doc = "0x102 - Interrupt Flag 1" ]
        pub sfrifg1: Sfrifg1,
        # [ doc = "0x104 - RESET Pin Control Register" ]
        pub sfrrpcr: Sfrrpcr,
    }
    # [ doc = "Interrupt Enable 1" ]
    pub struct Sfrie1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Interrupt Enable 1" ]
    pub mod sfrie1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sfrie1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdtieR {
            bits: u8,
        }
        impl WdtieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OfieR {
            bits: u8,
        }
        impl OfieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct VmaieR {
            bits: u8,
        }
        impl VmaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NmiieR {
            bits: u8,
        }
        impl NmiieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AccvieR {
            bits: u8,
        }
        impl AccvieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JmbinieR {
            bits: u8,
        }
        impl JmbinieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JmboutieR {
            bits: u8,
        }
        impl JmboutieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OfieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OfieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _VmaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VmaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NmiieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NmiieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AccvieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AccvieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JmbinieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JmbinieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JmboutieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JmboutieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - WDT Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn wdtie(&self) -> WdtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WdtieR { bits }
            }
            # [ doc = "Bit 1 - Osc Fault Enable" ]
            # [ inline ( always ) ]
            pub fn ofie(&self) -> OfieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OfieR { bits }
            }
            # [ doc = "Bit 3 - Vacant Memory Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn vmaie(&self) -> VmaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                VmaieR { bits }
            }
            # [ doc = "Bit 4 - NMI Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn nmiie(&self) -> NmiieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                NmiieR { bits }
            }
            # [ doc = "Bit 5 - Flash Access Violation Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn accvie(&self) -> AccvieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AccvieR { bits }
            }
            # [ doc = "Bit 6 - JTAG Mail Box input Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn jmbinie(&self) -> JmbinieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                JmbinieR { bits }
            }
            # [ doc = "Bit 7 - JTAG Mail Box output Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn jmboutie(&self) -> JmboutieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                JmboutieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - WDT Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn wdtie(&mut self) -> _WdtieW {
                _WdtieW { w: self }
            }
            # [ doc = "Bit 1 - Osc Fault Enable" ]
            # [ inline ( always ) ]
            pub fn ofie(&mut self) -> _OfieW {
                _OfieW { w: self }
            }
            # [ doc = "Bit 3 - Vacant Memory Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn vmaie(&mut self) -> _VmaieW {
                _VmaieW { w: self }
            }
            # [ doc = "Bit 4 - NMI Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn nmiie(&mut self) -> _NmiieW {
                _NmiieW { w: self }
            }
            # [ doc = "Bit 5 - Flash Access Violation Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn accvie(&mut self) -> _AccvieW {
                _AccvieW { w: self }
            }
            # [ doc = "Bit 6 - JTAG Mail Box input Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn jmbinie(&mut self) -> _JmbinieW {
                _JmbinieW { w: self }
            }
            # [ doc = "Bit 7 - JTAG Mail Box output Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn jmboutie(&mut self) -> _JmboutieW {
                _JmboutieW { w: self }
            }
        }
    }
    # [ doc = "Interrupt Flag 1" ]
    pub struct Sfrifg1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Interrupt Flag 1" ]
    pub mod sfrifg1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sfrifg1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdtifgR {
            bits: u8,
        }
        impl WdtifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OfifgR {
            bits: u8,
        }
        impl OfifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct VmaifgR {
            bits: u8,
        }
        impl VmaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct NmiifgR {
            bits: u8,
        }
        impl NmiifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JmbinifgR {
            bits: u8,
        }
        impl JmbinifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JmboutifgR {
            bits: u8,
        }
        impl JmboutifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OfifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OfifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _VmaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VmaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _NmiifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NmiifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JmbinifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JmbinifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JmboutifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JmboutifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - WDT Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn wdtifg(&self) -> WdtifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WdtifgR { bits }
            }
            # [ doc = "Bit 1 - Osc Fault Flag" ]
            # [ inline ( always ) ]
            pub fn ofifg(&self) -> OfifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OfifgR { bits }
            }
            # [ doc = "Bit 3 - Vacant Memory Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn vmaifg(&self) -> VmaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                VmaifgR { bits }
            }
            # [ doc = "Bit 4 - NMI Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn nmiifg(&self) -> NmiifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                NmiifgR { bits }
            }
            # [ doc = "Bit 6 - JTAG Mail Box input Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn jmbinifg(&self) -> JmbinifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                JmbinifgR { bits }
            }
            # [ doc = "Bit 7 - JTAG Mail Box output Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn jmboutifg(&self) -> JmboutifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                JmboutifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - WDT Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn wdtifg(&mut self) -> _WdtifgW {
                _WdtifgW { w: self }
            }
            # [ doc = "Bit 1 - Osc Fault Flag" ]
            # [ inline ( always ) ]
            pub fn ofifg(&mut self) -> _OfifgW {
                _OfifgW { w: self }
            }
            # [ doc = "Bit 3 - Vacant Memory Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn vmaifg(&mut self) -> _VmaifgW {
                _VmaifgW { w: self }
            }
            # [ doc = "Bit 4 - NMI Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn nmiifg(&mut self) -> _NmiifgW {
                _NmiifgW { w: self }
            }
            # [ doc = "Bit 6 - JTAG Mail Box input Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn jmbinifg(&mut self) -> _JmbinifgW {
                _JmbinifgW { w: self }
            }
            # [ doc = "Bit 7 - JTAG Mail Box output Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn jmboutifg(&mut self) -> _JmboutifgW {
                _JmboutifgW { w: self }
            }
        }
    }
    # [ doc = "RESET Pin Control Register" ]
    pub struct Sfrrpcr {
        register: VolatileCell<u16>,
    }
    # [ doc = "RESET Pin Control Register" ]
    pub mod sfrrpcr {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sfrrpcr {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysnmiR {
            bits: u8,
        }
        impl SysnmiR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysnmiiesR {
            bits: u8,
        }
        impl SysnmiiesR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysrstupR {
            bits: u8,
        }
        impl SysrstupR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysrstreR {
            bits: u8,
        }
        impl SysrstreR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysnmiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysnmiW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysnmiiesW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysnmiiesW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysrstupW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysrstupW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysrstreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysrstreW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - NMI select" ]
            # [ inline ( always ) ]
            pub fn sysnmi(&self) -> SysnmiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysnmiR { bits }
            }
            # [ doc = "Bit 1 - NMI edge select" ]
            # [ inline ( always ) ]
            pub fn sysnmiies(&self) -> SysnmiiesR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysnmiiesR { bits }
            }
            # [ doc = "Bit 2 - RESET Pin pull down/up select" ]
            # [ inline ( always ) ]
            pub fn sysrstup(&self) -> SysrstupR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysrstupR { bits }
            }
            # [ doc = "Bit 3 - RESET Pin Resistor enable" ]
            # [ inline ( always ) ]
            pub fn sysrstre(&self) -> SysrstreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysrstreR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - NMI select" ]
            # [ inline ( always ) ]
            pub fn sysnmi(&mut self) -> _SysnmiW {
                _SysnmiW { w: self }
            }
            # [ doc = "Bit 1 - NMI edge select" ]
            # [ inline ( always ) ]
            pub fn sysnmiies(&mut self) -> _SysnmiiesW {
                _SysnmiiesW { w: self }
            }
            # [ doc = "Bit 2 - RESET Pin pull down/up select" ]
            # [ inline ( always ) ]
            pub fn sysrstup(&mut self) -> _SysrstupW {
                _SysrstupW { w: self }
            }
            # [ doc = "Bit 3 - RESET Pin Resistor enable" ]
            # [ inline ( always ) ]
            pub fn sysrstre(&mut self) -> _SysrstreW {
                _SysrstreW { w: self }
            }
        }
    }
}
# [ doc = "SFR Special Function Registers" ]
pub struct SfrSpecialFunctionRegisters {
    register_block: sfr_special_function_registers::RegisterBlock,
}
impl Deref for SfrSpecialFunctionRegisters {
    type Target = sfr_special_function_registers::RegisterBlock;
    fn deref(&self) -> &sfr_special_function_registers::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "SYS System Module" ]
pub const SYS_SYSTEM_MODULE: Peripheral<SysSystemModule> = unsafe { Peripheral::new(0) };
# [ doc = "SYS System Module" ]
pub mod sys_system_module {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 384usize],
        # [ doc = "0x180 - System control" ]
        pub sysctl: Sysctl,
        # [ doc = "0x182 - Boot strap configuration area" ]
        pub sysbslc: Sysbslc,
        _reserved1: [u8; 2usize],
        # [ doc = "0x186 - JTAG mailbox control" ]
        pub sysjmbc: Sysjmbc,
        # [ doc = "0x188 - JTAG mailbox input 0" ]
        pub sysjmbi0: Sysjmbi0,
        # [ doc = "0x18a - JTAG mailbox input 1" ]
        pub sysjmbi1: Sysjmbi1,
        # [ doc = "0x18c - JTAG mailbox output 0" ]
        pub sysjmbo0: Sysjmbo0,
        # [ doc = "0x18e - JTAG mailbox output 1" ]
        pub sysjmbo1: Sysjmbo1,
        _reserved2: [u8; 8usize],
        # [ doc = "0x198 - Bus Error vector generator" ]
        pub sysberriv: Sysberriv,
        # [ doc = "0x19a - User NMI vector generator" ]
        pub sysuniv: Sysuniv,
        # [ doc = "0x19c - System NMI vector generator" ]
        pub syssniv: Syssniv,
        # [ doc = "0x19e - Reset vector generator" ]
        pub sysrstiv: Sysrstiv,
    }
    # [ doc = "System control" ]
    pub struct Sysctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "System control" ]
    pub mod sysctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysrivectR {
            bits: u8,
        }
        impl SysrivectR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SyspmmpeR {
            bits: u8,
        }
        impl SyspmmpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysbslindR {
            bits: u8,
        }
        impl SysbslindR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysjtagpinR {
            bits: u8,
        }
        impl SysjtagpinR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysrivectW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysrivectW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SyspmmpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SyspmmpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysbslindW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysbslindW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysjtagpinW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysjtagpinW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - SYS - RAM based interrupt vectors" ]
            # [ inline ( always ) ]
            pub fn sysrivect(&self) -> SysrivectR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysrivectR { bits }
            }
            # [ doc = "Bit 2 - SYS - PMM access protect" ]
            # [ inline ( always ) ]
            pub fn syspmmpe(&self) -> SyspmmpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SyspmmpeR { bits }
            }
            # [ doc = "Bit 4 - SYS - TCK/RST indication detected" ]
            # [ inline ( always ) ]
            pub fn sysbslind(&self) -> SysbslindR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysbslindR { bits }
            }
            # [ doc = "Bit 5 - SYS - Dedicated JTAG pins enabled" ]
            # [ inline ( always ) ]
            pub fn sysjtagpin(&self) -> SysjtagpinR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysjtagpinR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SYS - RAM based interrupt vectors" ]
            # [ inline ( always ) ]
            pub fn sysrivect(&mut self) -> _SysrivectW {
                _SysrivectW { w: self }
            }
            # [ doc = "Bit 2 - SYS - PMM access protect" ]
            # [ inline ( always ) ]
            pub fn syspmmpe(&mut self) -> _SyspmmpeW {
                _SyspmmpeW { w: self }
            }
            # [ doc = "Bit 4 - SYS - TCK/RST indication detected" ]
            # [ inline ( always ) ]
            pub fn sysbslind(&mut self) -> _SysbslindW {
                _SysbslindW { w: self }
            }
            # [ doc = "Bit 5 - SYS - Dedicated JTAG pins enabled" ]
            # [ inline ( always ) ]
            pub fn sysjtagpin(&mut self) -> _SysjtagpinW {
                _SysjtagpinW { w: self }
            }
        }
    }
    # [ doc = "Boot strap configuration area" ]
    pub struct Sysbslc {
        register: VolatileCell<u16>,
    }
    # [ doc = "Boot strap configuration area" ]
    pub mod sysbslc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysbslc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sysbslsize0R {
            bits: u8,
        }
        impl Sysbslsize0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Sysbslsize1R {
            bits: u8,
        }
        impl Sysbslsize1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysbslrR {
            bits: u8,
        }
        impl SysbslrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysbsloffR {
            bits: u8,
        }
        impl SysbsloffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SysbslpeR {
            bits: u8,
        }
        impl SysbslpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sysbslsize0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sysbslsize0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Sysbslsize1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sysbslsize1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysbslrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysbslrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysbsloffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysbsloffW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SysbslpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SysbslpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - SYS - BSL Protection Size 0" ]
            # [ inline ( always ) ]
            pub fn sysbslsize0(&self) -> Sysbslsize0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Sysbslsize0R { bits }
            }
            # [ doc = "Bit 1 - SYS - BSL Protection Size 1" ]
            # [ inline ( always ) ]
            pub fn sysbslsize1(&self) -> Sysbslsize1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Sysbslsize1R { bits }
            }
            # [ doc = "Bit 2 - SYS - RAM assigned to BSL" ]
            # [ inline ( always ) ]
            pub fn sysbslr(&self) -> SysbslrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysbslrR { bits }
            }
            # [ doc = "Bit 14 - SYS - BSL Memory disabled" ]
            # [ inline ( always ) ]
            pub fn sysbsloff(&self) -> SysbsloffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysbsloffR { bits }
            }
            # [ doc = "Bit 15 - SYS - BSL Memory protection enabled" ]
            # [ inline ( always ) ]
            pub fn sysbslpe(&self) -> SysbslpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SysbslpeR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SYS - BSL Protection Size 0" ]
            # [ inline ( always ) ]
            pub fn sysbslsize0(&mut self) -> _Sysbslsize0W {
                _Sysbslsize0W { w: self }
            }
            # [ doc = "Bit 1 - SYS - BSL Protection Size 1" ]
            # [ inline ( always ) ]
            pub fn sysbslsize1(&mut self) -> _Sysbslsize1W {
                _Sysbslsize1W { w: self }
            }
            # [ doc = "Bit 2 - SYS - RAM assigned to BSL" ]
            # [ inline ( always ) ]
            pub fn sysbslr(&mut self) -> _SysbslrW {
                _SysbslrW { w: self }
            }
            # [ doc = "Bit 14 - SYS - BSL Memory disabled" ]
            # [ inline ( always ) ]
            pub fn sysbsloff(&mut self) -> _SysbsloffW {
                _SysbsloffW { w: self }
            }
            # [ doc = "Bit 15 - SYS - BSL Memory protection enabled" ]
            # [ inline ( always ) ]
            pub fn sysbslpe(&mut self) -> _SysbslpeW {
                _SysbslpeW { w: self }
            }
        }
    }
    # [ doc = "JTAG mailbox control" ]
    pub struct Sysjmbc {
        register: VolatileCell<u16>,
    }
    # [ doc = "JTAG mailbox control" ]
    pub mod sysjmbc {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysjmbc {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jmbin0fgR {
            bits: u8,
        }
        impl Jmbin0fgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jmbin1fgR {
            bits: u8,
        }
        impl Jmbin1fgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jmbout0fgR {
            bits: u8,
        }
        impl Jmbout0fgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jmbout1fgR {
            bits: u8,
        }
        impl Jmbout1fgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct JmbmodeR {
            bits: u8,
        }
        impl JmbmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jmbclr0offR {
            bits: u8,
        }
        impl Jmbclr0offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Jmbclr1offR {
            bits: u8,
        }
        impl Jmbclr1offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jmbin0fgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jmbin0fgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jmbin1fgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jmbin1fgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jmbout0fgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jmbout0fgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jmbout1fgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jmbout1fgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _JmbmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _JmbmodeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jmbclr0offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jmbclr0offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Jmbclr1offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Jmbclr1offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - SYS - Incoming JTAG Mailbox 0 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbin0fg(&self) -> Jmbin0fgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Jmbin0fgR { bits }
            }
            # [ doc = "Bit 1 - SYS - Incoming JTAG Mailbox 1 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbin1fg(&self) -> Jmbin1fgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Jmbin1fgR { bits }
            }
            # [ doc = "Bit 2 - SYS - Outgoing JTAG Mailbox 0 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbout0fg(&self) -> Jmbout0fgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Jmbout0fgR { bits }
            }
            # [ doc = "Bit 3 - SYS - Outgoing JTAG Mailbox 1 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbout1fg(&self) -> Jmbout1fgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Jmbout1fgR { bits }
            }
            # [ doc = "Bit 4 - SYS - JMB 16/32 Bit Mode" ]
            # [ inline ( always ) ]
            pub fn jmbmode(&self) -> JmbmodeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                JmbmodeR { bits }
            }
            # [ doc = "Bit 6 - SYS - Incoming JTAG Mailbox 0 Flag auto-clear disalbe" ]
            # [ inline ( always ) ]
            pub fn jmbclr0off(&self) -> Jmbclr0offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Jmbclr0offR { bits }
            }
            # [ doc = "Bit 7 - SYS - Incoming JTAG Mailbox 1 Flag auto-clear disalbe" ]
            # [ inline ( always ) ]
            pub fn jmbclr1off(&self) -> Jmbclr1offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Jmbclr1offR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - SYS - Incoming JTAG Mailbox 0 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbin0fg(&mut self) -> _Jmbin0fgW {
                _Jmbin0fgW { w: self }
            }
            # [ doc = "Bit 1 - SYS - Incoming JTAG Mailbox 1 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbin1fg(&mut self) -> _Jmbin1fgW {
                _Jmbin1fgW { w: self }
            }
            # [ doc = "Bit 2 - SYS - Outgoing JTAG Mailbox 0 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbout0fg(&mut self) -> _Jmbout0fgW {
                _Jmbout0fgW { w: self }
            }
            # [ doc = "Bit 3 - SYS - Outgoing JTAG Mailbox 1 Flag" ]
            # [ inline ( always ) ]
            pub fn jmbout1fg(&mut self) -> _Jmbout1fgW {
                _Jmbout1fgW { w: self }
            }
            # [ doc = "Bit 4 - SYS - JMB 16/32 Bit Mode" ]
            # [ inline ( always ) ]
            pub fn jmbmode(&mut self) -> _JmbmodeW {
                _JmbmodeW { w: self }
            }
            # [ doc = "Bit 6 - SYS - Incoming JTAG Mailbox 0 Flag auto-clear disalbe" ]
            # [ inline ( always ) ]
            pub fn jmbclr0off(&mut self) -> _Jmbclr0offW {
                _Jmbclr0offW { w: self }
            }
            # [ doc = "Bit 7 - SYS - Incoming JTAG Mailbox 1 Flag auto-clear disalbe" ]
            # [ inline ( always ) ]
            pub fn jmbclr1off(&mut self) -> _Jmbclr1offW {
                _Jmbclr1offW { w: self }
            }
        }
    }
    # [ doc = "JTAG mailbox input 0" ]
    pub struct Sysjmbi0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "JTAG mailbox input 0" ]
    pub mod sysjmbi0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysjmbi0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "JTAG mailbox input 1" ]
    pub struct Sysjmbi1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "JTAG mailbox input 1" ]
    pub mod sysjmbi1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysjmbi1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "JTAG mailbox output 0" ]
    pub struct Sysjmbo0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "JTAG mailbox output 0" ]
    pub mod sysjmbo0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysjmbo0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "JTAG mailbox output 1" ]
    pub struct Sysjmbo1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "JTAG mailbox output 1" ]
    pub mod sysjmbo1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysjmbo1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Bus Error vector generator" ]
    pub struct Sysberriv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Bus Error vector generator" ]
    pub mod sysberriv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysberriv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "User NMI vector generator" ]
    pub struct Sysuniv {
        register: VolatileCell<u16>,
    }
    # [ doc = "User NMI vector generator" ]
    pub mod sysuniv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysuniv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "System NMI vector generator" ]
    pub struct Syssniv {
        register: VolatileCell<u16>,
    }
    # [ doc = "System NMI vector generator" ]
    pub mod syssniv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Syssniv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Reset vector generator" ]
    pub struct Sysrstiv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Reset vector generator" ]
    pub mod sysrstiv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Sysrstiv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "SYS System Module" ]
pub struct SysSystemModule {
    register_block: sys_system_module::RegisterBlock,
}
impl Deref for SysSystemModule {
    type Target = sys_system_module::RegisterBlock;
    fn deref(&self) -> &sys_system_module::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Timer0_A5" ]
pub const TIMER0_A5: Peripheral<Timer0A5> = unsafe { Peripheral::new(0) };
# [ doc = "Timer0_A5" ]
pub mod timer0_a5 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 832usize],
        # [ doc = "0x340 - Timer0_A5 Control" ]
        pub ta0ctl: Ta0ctl,
        # [ doc = "0x342 - Timer0_A5 Capture/Compare Control 0" ]
        pub ta0cctl0: Ta0cctl0,
        # [ doc = "0x344 - Timer0_A5 Capture/Compare Control 1" ]
        pub ta0cctl1: Ta0cctl1,
        # [ doc = "0x346 - Timer0_A5 Capture/Compare Control 2" ]
        pub ta0cctl2: Ta0cctl2,
        # [ doc = "0x348 - Timer0_A5 Capture/Compare Control 3" ]
        pub ta0cctl3: Ta0cctl3,
        # [ doc = "0x34a - Timer0_A5 Capture/Compare Control 4" ]
        pub ta0cctl4: Ta0cctl4,
        _reserved1: [u8; 4usize],
        # [ doc = "0x350 - Timer0_A5" ]
        pub ta0r: Ta0r,
        # [ doc = "0x352 - Timer0_A5 Capture/Compare 0" ]
        pub ta0ccr0: Ta0ccr0,
        # [ doc = "0x354 - Timer0_A5 Capture/Compare 1" ]
        pub ta0ccr1: Ta0ccr1,
        # [ doc = "0x356 - Timer0_A5 Capture/Compare 2" ]
        pub ta0ccr2: Ta0ccr2,
        # [ doc = "0x358 - Timer0_A5 Capture/Compare 3" ]
        pub ta0ccr3: Ta0ccr3,
        # [ doc = "0x35a - Timer0_A5 Capture/Compare 4" ]
        pub ta0ccr4: Ta0ccr4,
        _reserved2: [u8; 4usize],
        # [ doc = "0x360 - Timer0_A5 Expansion Register 0" ]
        pub ta0ex0: Ta0ex0,
        _reserved3: [u8; 12usize],
        # [ doc = "0x36e - Timer0_A5 Interrupt Vector Word" ]
        pub ta0iv: Ta0iv,
    }
    # [ doc = "Timer0_A5 Control" ]
    pub struct Ta0ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Control" ]
    pub mod ta0ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TaifgR {
            bits: u8,
        }
        impl TaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TaieR {
            bits: u8,
        }
        impl TaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TaclrR {
            bits: u8,
        }
        impl TaclrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `MC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum McR {
            # [ doc = "Timer A mode control: 0 - Stop" ]
            Mc0,
            # [ doc = "Timer A mode control: 1 - Up to CCR0" ]
            Mc1,
            # [ doc = "Timer A mode control: 2 - Continuous up" ]
            Mc2,
            # [ doc = "Timer A mode control: 3 - Up/Down" ]
            Mc3,
        }
        impl McR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    McR::Mc0 => 0,
                    McR::Mc1 => 1,
                    McR::Mc2 => 2,
                    McR::Mc3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> McR {
                match bits {
                    0 => McR::Mc0,
                    1 => McR::Mc1,
                    2 => McR::Mc2,
                    3 => McR::Mc3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Mc0`" ]
            # [ inline ( always ) ]
            pub fn is_mc_0(&self) -> bool {
                *self == McR::Mc0
            }
            # [ doc = "Checks if the value of the field is `Mc1`" ]
            # [ inline ( always ) ]
            pub fn is_mc_1(&self) -> bool {
                *self == McR::Mc1
            }
            # [ doc = "Checks if the value of the field is `Mc2`" ]
            # [ inline ( always ) ]
            pub fn is_mc_2(&self) -> bool {
                *self == McR::Mc2
            }
            # [ doc = "Checks if the value of the field is `Mc3`" ]
            # [ inline ( always ) ]
            pub fn is_mc_3(&self) -> bool {
                *self == McR::Mc3
            }
        }
        # [ doc = "Possible values of the field `ID`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum IdR {
            # [ doc = "Timer A input divider: 0 - /1" ]
            Id0,
            # [ doc = "Timer A input divider: 1 - /2" ]
            Id1,
            # [ doc = "Timer A input divider: 2 - /4" ]
            Id2,
            # [ doc = "Timer A input divider: 3 - /8" ]
            Id3,
        }
        impl IdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    IdR::Id0 => 0,
                    IdR::Id1 => 1,
                    IdR::Id2 => 2,
                    IdR::Id3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> IdR {
                match bits {
                    0 => IdR::Id0,
                    1 => IdR::Id1,
                    2 => IdR::Id2,
                    3 => IdR::Id3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Id0`" ]
            # [ inline ( always ) ]
            pub fn is_id_0(&self) -> bool {
                *self == IdR::Id0
            }
            # [ doc = "Checks if the value of the field is `Id1`" ]
            # [ inline ( always ) ]
            pub fn is_id_1(&self) -> bool {
                *self == IdR::Id1
            }
            # [ doc = "Checks if the value of the field is `Id2`" ]
            # [ inline ( always ) ]
            pub fn is_id_2(&self) -> bool {
                *self == IdR::Id2
            }
            # [ doc = "Checks if the value of the field is `Id3`" ]
            # [ inline ( always ) ]
            pub fn is_id_3(&self) -> bool {
                *self == IdR::Id3
            }
        }
        # [ doc = "Possible values of the field `TASSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TasselR {
            # [ doc = "Timer A clock source select: 0 - TACLK" ]
            Tassel0,
            # [ doc = "Timer A clock source select: 1 - ACLK" ]
            Tassel1,
            # [ doc = "Timer A clock source select: 2 - SMCLK" ]
            Tassel2,
            # [ doc = "Timer A clock source select: 3 - INCLK" ]
            Tassel3,
        }
        impl TasselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TasselR::Tassel0 => 0,
                    TasselR::Tassel1 => 1,
                    TasselR::Tassel2 => 2,
                    TasselR::Tassel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TasselR {
                match bits {
                    0 => TasselR::Tassel0,
                    1 => TasselR::Tassel1,
                    2 => TasselR::Tassel2,
                    3 => TasselR::Tassel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Tassel0`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_0(&self) -> bool {
                *self == TasselR::Tassel0
            }
            # [ doc = "Checks if the value of the field is `Tassel1`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_1(&self) -> bool {
                *self == TasselR::Tassel1
            }
            # [ doc = "Checks if the value of the field is `Tassel2`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_2(&self) -> bool {
                *self == TasselR::Tassel2
            }
            # [ doc = "Checks if the value of the field is `Tassel3`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_3(&self) -> bool {
                *self == TasselR::Tassel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaclrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaclrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MC`" ]
        pub enum McW {
            # [ doc = "Timer A mode control: 0 - Stop" ]
            Mc0,
            # [ doc = "Timer A mode control: 1 - Up to CCR0" ]
            Mc1,
            # [ doc = "Timer A mode control: 2 - Continuous up" ]
            Mc2,
            # [ doc = "Timer A mode control: 3 - Up/Down" ]
            Mc3,
        }
        impl McW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    McW::Mc0 => 0,
                    McW::Mc1 => 1,
                    McW::Mc2 => 2,
                    McW::Mc3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _McW<'a> {
            w: &'a mut W,
        }
        impl<'a> _McW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: McW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A mode control: 0 - Stop" ]
            # [ inline ( always ) ]
            pub fn mc_0(self) -> &'a mut W {
                self.variant(McW::Mc0)
            }
            # [ doc = "Timer A mode control: 1 - Up to CCR0" ]
            # [ inline ( always ) ]
            pub fn mc_1(self) -> &'a mut W {
                self.variant(McW::Mc1)
            }
            # [ doc = "Timer A mode control: 2 - Continuous up" ]
            # [ inline ( always ) ]
            pub fn mc_2(self) -> &'a mut W {
                self.variant(McW::Mc2)
            }
            # [ doc = "Timer A mode control: 3 - Up/Down" ]
            # [ inline ( always ) ]
            pub fn mc_3(self) -> &'a mut W {
                self.variant(McW::Mc3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ID`" ]
        pub enum IdW {
            # [ doc = "Timer A input divider: 0 - /1" ]
            Id0,
            # [ doc = "Timer A input divider: 1 - /2" ]
            Id1,
            # [ doc = "Timer A input divider: 2 - /4" ]
            Id2,
            # [ doc = "Timer A input divider: 3 - /8" ]
            Id3,
        }
        impl IdW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IdW::Id0 => 0,
                    IdW::Id1 => 1,
                    IdW::Id2 => 2,
                    IdW::Id3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IdW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A input divider: 0 - /1" ]
            # [ inline ( always ) ]
            pub fn id_0(self) -> &'a mut W {
                self.variant(IdW::Id0)
            }
            # [ doc = "Timer A input divider: 1 - /2" ]
            # [ inline ( always ) ]
            pub fn id_1(self) -> &'a mut W {
                self.variant(IdW::Id1)
            }
            # [ doc = "Timer A input divider: 2 - /4" ]
            # [ inline ( always ) ]
            pub fn id_2(self) -> &'a mut W {
                self.variant(IdW::Id2)
            }
            # [ doc = "Timer A input divider: 3 - /8" ]
            # [ inline ( always ) ]
            pub fn id_3(self) -> &'a mut W {
                self.variant(IdW::Id3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TASSEL`" ]
        pub enum TasselW {
            # [ doc = "Timer A clock source select: 0 - TACLK" ]
            Tassel0,
            # [ doc = "Timer A clock source select: 1 - ACLK" ]
            Tassel1,
            # [ doc = "Timer A clock source select: 2 - SMCLK" ]
            Tassel2,
            # [ doc = "Timer A clock source select: 3 - INCLK" ]
            Tassel3,
        }
        impl TasselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TasselW::Tassel0 => 0,
                    TasselW::Tassel1 => 1,
                    TasselW::Tassel2 => 2,
                    TasselW::Tassel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TasselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TasselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TasselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A clock source select: 0 - TACLK" ]
            # [ inline ( always ) ]
            pub fn tassel_0(self) -> &'a mut W {
                self.variant(TasselW::Tassel0)
            }
            # [ doc = "Timer A clock source select: 1 - ACLK" ]
            # [ inline ( always ) ]
            pub fn tassel_1(self) -> &'a mut W {
                self.variant(TasselW::Tassel1)
            }
            # [ doc = "Timer A clock source select: 2 - SMCLK" ]
            # [ inline ( always ) ]
            pub fn tassel_2(self) -> &'a mut W {
                self.variant(TasselW::Tassel2)
            }
            # [ doc = "Timer A clock source select: 3 - INCLK" ]
            # [ inline ( always ) ]
            pub fn tassel_3(self) -> &'a mut W {
                self.variant(TasselW::Tassel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Timer A counter interrupt flag" ]
            # [ inline ( always ) ]
            pub fn taifg(&self) -> TaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                TaifgR { bits }
            }
            # [ doc = "Bit 1 - Timer A counter interrupt enable" ]
            # [ inline ( always ) ]
            pub fn taie(&self) -> TaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                TaieR { bits }
            }
            # [ doc = "Bit 2 - Timer A counter clear" ]
            # [ inline ( always ) ]
            pub fn taclr(&self) -> TaclrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                TaclrR { bits }
            }
            # [ doc = "Bits 5:6 - Timer A mode control 1" ]
            # [ inline ( always ) ]
            pub fn mc(&self) -> McR {
                McR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 5;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
            # [ doc = "Bits 7:8 - Timer A clock input divider 1" ]
            # [ inline ( always ) ]
            pub fn id(&self) -> IdR {
                IdR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 7;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
            # [ doc = "Bits 9:10 - Timer A clock source select 1" ]
            # [ inline ( always ) ]
            pub fn tassel(&self) -> TasselR {
                TasselR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 9;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Timer A counter interrupt flag" ]
            # [ inline ( always ) ]
            pub fn taifg(&mut self) -> _TaifgW {
                _TaifgW { w: self }
            }
            # [ doc = "Bit 1 - Timer A counter interrupt enable" ]
            # [ inline ( always ) ]
            pub fn taie(&mut self) -> _TaieW {
                _TaieW { w: self }
            }
            # [ doc = "Bit 2 - Timer A counter clear" ]
            # [ inline ( always ) ]
            pub fn taclr(&mut self) -> _TaclrW {
                _TaclrW { w: self }
            }
            # [ doc = "Bits 5:6 - Timer A mode control 1" ]
            # [ inline ( always ) ]
            pub fn mc(&mut self) -> _McW {
                _McW { w: self }
            }
            # [ doc = "Bits 7:8 - Timer A clock input divider 1" ]
            # [ inline ( always ) ]
            pub fn id(&mut self) -> _IdW {
                _IdW { w: self }
            }
            # [ doc = "Bits 9:10 - Timer A clock source select 1" ]
            # [ inline ( always ) ]
            pub fn tassel(&mut self) -> _TasselW {
                _TasselW { w: self }
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 0" ]
    pub struct Ta0cctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 0" ]
    pub mod ta0cctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0cctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 1" ]
    pub struct Ta0cctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 1" ]
    pub mod ta0cctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0cctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 2" ]
    pub struct Ta0cctl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 2" ]
    pub mod ta0cctl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0cctl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 3" ]
    pub struct Ta0cctl3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 3" ]
    pub mod ta0cctl3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0cctl3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 4" ]
    pub struct Ta0cctl4 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare Control 4" ]
    pub mod ta0cctl4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0cctl4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer0_A5" ]
    pub struct Ta0r {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5" ]
    pub mod ta0r {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0r {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare 0" ]
    pub struct Ta0ccr0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare 0" ]
    pub mod ta0ccr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ccr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare 1" ]
    pub struct Ta0ccr1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare 1" ]
    pub mod ta0ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare 2" ]
    pub struct Ta0ccr2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare 2" ]
    pub mod ta0ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare 3" ]
    pub struct Ta0ccr3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare 3" ]
    pub mod ta0ccr3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ccr3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Capture/Compare 4" ]
    pub struct Ta0ccr4 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Capture/Compare 4" ]
    pub mod ta0ccr4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ccr4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Interrupt Vector Word" ]
    pub struct Ta0iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Interrupt Vector Word" ]
    pub mod ta0iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer0_A5 Expansion Register 0" ]
    pub struct Ta0ex0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer0_A5 Expansion Register 0" ]
    pub mod ta0ex0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta0ex0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TAIDEX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TaidexR {
            # [ doc = "Timer A Input divider expansion : /1" ]
            Taidex0,
            # [ doc = "Timer A Input divider expansion : /2" ]
            Taidex1,
            # [ doc = "Timer A Input divider expansion : /3" ]
            Taidex2,
            # [ doc = "Timer A Input divider expansion : /4" ]
            Taidex3,
            # [ doc = "Timer A Input divider expansion : /5" ]
            Taidex4,
            # [ doc = "Timer A Input divider expansion : /6" ]
            Taidex5,
            # [ doc = "Timer A Input divider expansion : /7" ]
            Taidex6,
            # [ doc = "Timer A Input divider expansion : /8" ]
            Taidex7,
        }
        impl TaidexR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TaidexR::Taidex0 => 0,
                    TaidexR::Taidex1 => 1,
                    TaidexR::Taidex2 => 2,
                    TaidexR::Taidex3 => 3,
                    TaidexR::Taidex4 => 4,
                    TaidexR::Taidex5 => 5,
                    TaidexR::Taidex6 => 6,
                    TaidexR::Taidex7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TaidexR {
                match bits {
                    0 => TaidexR::Taidex0,
                    1 => TaidexR::Taidex1,
                    2 => TaidexR::Taidex2,
                    3 => TaidexR::Taidex3,
                    4 => TaidexR::Taidex4,
                    5 => TaidexR::Taidex5,
                    6 => TaidexR::Taidex6,
                    7 => TaidexR::Taidex7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Taidex0`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_0(&self) -> bool {
                *self == TaidexR::Taidex0
            }
            # [ doc = "Checks if the value of the field is `Taidex1`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_1(&self) -> bool {
                *self == TaidexR::Taidex1
            }
            # [ doc = "Checks if the value of the field is `Taidex2`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_2(&self) -> bool {
                *self == TaidexR::Taidex2
            }
            # [ doc = "Checks if the value of the field is `Taidex3`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_3(&self) -> bool {
                *self == TaidexR::Taidex3
            }
            # [ doc = "Checks if the value of the field is `Taidex4`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_4(&self) -> bool {
                *self == TaidexR::Taidex4
            }
            # [ doc = "Checks if the value of the field is `Taidex5`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_5(&self) -> bool {
                *self == TaidexR::Taidex5
            }
            # [ doc = "Checks if the value of the field is `Taidex6`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_6(&self) -> bool {
                *self == TaidexR::Taidex6
            }
            # [ doc = "Checks if the value of the field is `Taidex7`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_7(&self) -> bool {
                *self == TaidexR::Taidex7
            }
        }
        # [ doc = "Values that can be written to the field `TAIDEX`" ]
        pub enum TaidexW {
            # [ doc = "Timer A Input divider expansion : /1" ]
            Taidex0,
            # [ doc = "Timer A Input divider expansion : /2" ]
            Taidex1,
            # [ doc = "Timer A Input divider expansion : /3" ]
            Taidex2,
            # [ doc = "Timer A Input divider expansion : /4" ]
            Taidex3,
            # [ doc = "Timer A Input divider expansion : /5" ]
            Taidex4,
            # [ doc = "Timer A Input divider expansion : /6" ]
            Taidex5,
            # [ doc = "Timer A Input divider expansion : /7" ]
            Taidex6,
            # [ doc = "Timer A Input divider expansion : /8" ]
            Taidex7,
        }
        impl TaidexW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TaidexW::Taidex0 => 0,
                    TaidexW::Taidex1 => 1,
                    TaidexW::Taidex2 => 2,
                    TaidexW::Taidex3 => 3,
                    TaidexW::Taidex4 => 4,
                    TaidexW::Taidex5 => 5,
                    TaidexW::Taidex6 => 6,
                    TaidexW::Taidex7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaidexW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaidexW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TaidexW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A Input divider expansion : /1" ]
            # [ inline ( always ) ]
            pub fn taidex_0(self) -> &'a mut W {
                self.variant(TaidexW::Taidex0)
            }
            # [ doc = "Timer A Input divider expansion : /2" ]
            # [ inline ( always ) ]
            pub fn taidex_1(self) -> &'a mut W {
                self.variant(TaidexW::Taidex1)
            }
            # [ doc = "Timer A Input divider expansion : /3" ]
            # [ inline ( always ) ]
            pub fn taidex_2(self) -> &'a mut W {
                self.variant(TaidexW::Taidex2)
            }
            # [ doc = "Timer A Input divider expansion : /4" ]
            # [ inline ( always ) ]
            pub fn taidex_3(self) -> &'a mut W {
                self.variant(TaidexW::Taidex3)
            }
            # [ doc = "Timer A Input divider expansion : /5" ]
            # [ inline ( always ) ]
            pub fn taidex_4(self) -> &'a mut W {
                self.variant(TaidexW::Taidex4)
            }
            # [ doc = "Timer A Input divider expansion : /6" ]
            # [ inline ( always ) ]
            pub fn taidex_5(self) -> &'a mut W {
                self.variant(TaidexW::Taidex5)
            }
            # [ doc = "Timer A Input divider expansion : /7" ]
            # [ inline ( always ) ]
            pub fn taidex_6(self) -> &'a mut W {
                self.variant(TaidexW::Taidex6)
            }
            # [ doc = "Timer A Input divider expansion : /8" ]
            # [ inline ( always ) ]
            pub fn taidex_7(self) -> &'a mut W {
                self.variant(TaidexW::Taidex7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - Timer A Input divider expansion Bit: 0" ]
            # [ inline ( always ) ]
            pub fn taidex(&self) -> TaidexR {
                TaidexR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - Timer A Input divider expansion Bit: 0" ]
            # [ inline ( always ) ]
            pub fn taidex(&mut self) -> _TaidexW {
                _TaidexW { w: self }
            }
        }
    }
}
# [ doc = "Timer0_A5" ]
pub struct Timer0A5 {
    register_block: timer0_a5::RegisterBlock,
}
impl Deref for Timer0A5 {
    type Target = timer0_a5::RegisterBlock;
    fn deref(&self) -> &timer0_a5::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Timer1_A3" ]
pub const TIMER1_A3: Peripheral<Timer1A3> = unsafe { Peripheral::new(0) };
# [ doc = "Timer1_A3" ]
pub mod timer1_a3 {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 896usize],
        # [ doc = "0x380 - Timer1_A3 Control" ]
        pub ta1ctl: Ta1ctl,
        # [ doc = "0x382 - Timer1_A3 Capture/Compare Control 0" ]
        pub ta1cctl0: Ta1cctl0,
        # [ doc = "0x384 - Timer1_A3 Capture/Compare Control 1" ]
        pub ta1cctl1: Ta1cctl1,
        # [ doc = "0x386 - Timer1_A3 Capture/Compare Control 2" ]
        pub ta1cctl2: Ta1cctl2,
        _reserved1: [u8; 8usize],
        # [ doc = "0x390 - Timer1_A3" ]
        pub ta1r: Ta1r,
        # [ doc = "0x392 - Timer1_A3 Capture/Compare 0" ]
        pub ta1ccr0: Ta1ccr0,
        # [ doc = "0x394 - Timer1_A3 Capture/Compare 1" ]
        pub ta1ccr1: Ta1ccr1,
        # [ doc = "0x396 - Timer1_A3 Capture/Compare 2" ]
        pub ta1ccr2: Ta1ccr2,
        _reserved2: [u8; 8usize],
        # [ doc = "0x3a0 - Timer1_A3 Expansion Register 0" ]
        pub ta1ex0: Ta1ex0,
        _reserved3: [u8; 12usize],
        # [ doc = "0x3ae - Timer1_A3 Interrupt Vector Word" ]
        pub ta1iv: Ta1iv,
    }
    # [ doc = "Timer1_A3 Control" ]
    pub struct Ta1ctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Control" ]
    pub mod ta1ctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1ctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TaifgR {
            bits: u8,
        }
        impl TaifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TaieR {
            bits: u8,
        }
        impl TaieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct TaclrR {
            bits: u8,
        }
        impl TaclrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `MC`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum McR {
            # [ doc = "Timer A mode control: 0 - Stop" ]
            Mc0,
            # [ doc = "Timer A mode control: 1 - Up to CCR0" ]
            Mc1,
            # [ doc = "Timer A mode control: 2 - Continuous up" ]
            Mc2,
            # [ doc = "Timer A mode control: 3 - Up/Down" ]
            Mc3,
        }
        impl McR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    McR::Mc0 => 0,
                    McR::Mc1 => 1,
                    McR::Mc2 => 2,
                    McR::Mc3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> McR {
                match bits {
                    0 => McR::Mc0,
                    1 => McR::Mc1,
                    2 => McR::Mc2,
                    3 => McR::Mc3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Mc0`" ]
            # [ inline ( always ) ]
            pub fn is_mc_0(&self) -> bool {
                *self == McR::Mc0
            }
            # [ doc = "Checks if the value of the field is `Mc1`" ]
            # [ inline ( always ) ]
            pub fn is_mc_1(&self) -> bool {
                *self == McR::Mc1
            }
            # [ doc = "Checks if the value of the field is `Mc2`" ]
            # [ inline ( always ) ]
            pub fn is_mc_2(&self) -> bool {
                *self == McR::Mc2
            }
            # [ doc = "Checks if the value of the field is `Mc3`" ]
            # [ inline ( always ) ]
            pub fn is_mc_3(&self) -> bool {
                *self == McR::Mc3
            }
        }
        # [ doc = "Possible values of the field `ID`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum IdR {
            # [ doc = "Timer A input divider: 0 - /1" ]
            Id0,
            # [ doc = "Timer A input divider: 1 - /2" ]
            Id1,
            # [ doc = "Timer A input divider: 2 - /4" ]
            Id2,
            # [ doc = "Timer A input divider: 3 - /8" ]
            Id3,
        }
        impl IdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    IdR::Id0 => 0,
                    IdR::Id1 => 1,
                    IdR::Id2 => 2,
                    IdR::Id3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> IdR {
                match bits {
                    0 => IdR::Id0,
                    1 => IdR::Id1,
                    2 => IdR::Id2,
                    3 => IdR::Id3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Id0`" ]
            # [ inline ( always ) ]
            pub fn is_id_0(&self) -> bool {
                *self == IdR::Id0
            }
            # [ doc = "Checks if the value of the field is `Id1`" ]
            # [ inline ( always ) ]
            pub fn is_id_1(&self) -> bool {
                *self == IdR::Id1
            }
            # [ doc = "Checks if the value of the field is `Id2`" ]
            # [ inline ( always ) ]
            pub fn is_id_2(&self) -> bool {
                *self == IdR::Id2
            }
            # [ doc = "Checks if the value of the field is `Id3`" ]
            # [ inline ( always ) ]
            pub fn is_id_3(&self) -> bool {
                *self == IdR::Id3
            }
        }
        # [ doc = "Possible values of the field `TASSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TasselR {
            # [ doc = "Timer A clock source select: 0 - TACLK" ]
            Tassel0,
            # [ doc = "Timer A clock source select: 1 - ACLK" ]
            Tassel1,
            # [ doc = "Timer A clock source select: 2 - SMCLK" ]
            Tassel2,
            # [ doc = "Timer A clock source select: 3 - INCLK" ]
            Tassel3,
        }
        impl TasselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TasselR::Tassel0 => 0,
                    TasselR::Tassel1 => 1,
                    TasselR::Tassel2 => 2,
                    TasselR::Tassel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TasselR {
                match bits {
                    0 => TasselR::Tassel0,
                    1 => TasselR::Tassel1,
                    2 => TasselR::Tassel2,
                    3 => TasselR::Tassel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Tassel0`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_0(&self) -> bool {
                *self == TasselR::Tassel0
            }
            # [ doc = "Checks if the value of the field is `Tassel1`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_1(&self) -> bool {
                *self == TasselR::Tassel1
            }
            # [ doc = "Checks if the value of the field is `Tassel2`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_2(&self) -> bool {
                *self == TasselR::Tassel2
            }
            # [ doc = "Checks if the value of the field is `Tassel3`" ]
            # [ inline ( always ) ]
            pub fn is_tassel_3(&self) -> bool {
                *self == TasselR::Tassel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaclrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaclrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `MC`" ]
        pub enum McW {
            # [ doc = "Timer A mode control: 0 - Stop" ]
            Mc0,
            # [ doc = "Timer A mode control: 1 - Up to CCR0" ]
            Mc1,
            # [ doc = "Timer A mode control: 2 - Continuous up" ]
            Mc2,
            # [ doc = "Timer A mode control: 3 - Up/Down" ]
            Mc3,
        }
        impl McW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    McW::Mc0 => 0,
                    McW::Mc1 => 1,
                    McW::Mc2 => 2,
                    McW::Mc3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _McW<'a> {
            w: &'a mut W,
        }
        impl<'a> _McW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: McW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A mode control: 0 - Stop" ]
            # [ inline ( always ) ]
            pub fn mc_0(self) -> &'a mut W {
                self.variant(McW::Mc0)
            }
            # [ doc = "Timer A mode control: 1 - Up to CCR0" ]
            # [ inline ( always ) ]
            pub fn mc_1(self) -> &'a mut W {
                self.variant(McW::Mc1)
            }
            # [ doc = "Timer A mode control: 2 - Continuous up" ]
            # [ inline ( always ) ]
            pub fn mc_2(self) -> &'a mut W {
                self.variant(McW::Mc2)
            }
            # [ doc = "Timer A mode control: 3 - Up/Down" ]
            # [ inline ( always ) ]
            pub fn mc_3(self) -> &'a mut W {
                self.variant(McW::Mc3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `ID`" ]
        pub enum IdW {
            # [ doc = "Timer A input divider: 0 - /1" ]
            Id0,
            # [ doc = "Timer A input divider: 1 - /2" ]
            Id1,
            # [ doc = "Timer A input divider: 2 - /4" ]
            Id2,
            # [ doc = "Timer A input divider: 3 - /8" ]
            Id3,
        }
        impl IdW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IdW::Id0 => 0,
                    IdW::Id1 => 1,
                    IdW::Id2 => 2,
                    IdW::Id3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _IdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: IdW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A input divider: 0 - /1" ]
            # [ inline ( always ) ]
            pub fn id_0(self) -> &'a mut W {
                self.variant(IdW::Id0)
            }
            # [ doc = "Timer A input divider: 1 - /2" ]
            # [ inline ( always ) ]
            pub fn id_1(self) -> &'a mut W {
                self.variant(IdW::Id1)
            }
            # [ doc = "Timer A input divider: 2 - /4" ]
            # [ inline ( always ) ]
            pub fn id_2(self) -> &'a mut W {
                self.variant(IdW::Id2)
            }
            # [ doc = "Timer A input divider: 3 - /8" ]
            # [ inline ( always ) ]
            pub fn id_3(self) -> &'a mut W {
                self.variant(IdW::Id3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `TASSEL`" ]
        pub enum TasselW {
            # [ doc = "Timer A clock source select: 0 - TACLK" ]
            Tassel0,
            # [ doc = "Timer A clock source select: 1 - ACLK" ]
            Tassel1,
            # [ doc = "Timer A clock source select: 2 - SMCLK" ]
            Tassel2,
            # [ doc = "Timer A clock source select: 3 - INCLK" ]
            Tassel3,
        }
        impl TasselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TasselW::Tassel0 => 0,
                    TasselW::Tassel1 => 1,
                    TasselW::Tassel2 => 2,
                    TasselW::Tassel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TasselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TasselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TasselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A clock source select: 0 - TACLK" ]
            # [ inline ( always ) ]
            pub fn tassel_0(self) -> &'a mut W {
                self.variant(TasselW::Tassel0)
            }
            # [ doc = "Timer A clock source select: 1 - ACLK" ]
            # [ inline ( always ) ]
            pub fn tassel_1(self) -> &'a mut W {
                self.variant(TasselW::Tassel1)
            }
            # [ doc = "Timer A clock source select: 2 - SMCLK" ]
            # [ inline ( always ) ]
            pub fn tassel_2(self) -> &'a mut W {
                self.variant(TasselW::Tassel2)
            }
            # [ doc = "Timer A clock source select: 3 - INCLK" ]
            # [ inline ( always ) ]
            pub fn tassel_3(self) -> &'a mut W {
                self.variant(TasselW::Tassel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Timer A counter interrupt flag" ]
            # [ inline ( always ) ]
            pub fn taifg(&self) -> TaifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                TaifgR { bits }
            }
            # [ doc = "Bit 1 - Timer A counter interrupt enable" ]
            # [ inline ( always ) ]
            pub fn taie(&self) -> TaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                TaieR { bits }
            }
            # [ doc = "Bit 2 - Timer A counter clear" ]
            # [ inline ( always ) ]
            pub fn taclr(&self) -> TaclrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                TaclrR { bits }
            }
            # [ doc = "Bits 5:6 - Timer A mode control 1" ]
            # [ inline ( always ) ]
            pub fn mc(&self) -> McR {
                McR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 5;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
            # [ doc = "Bits 7:8 - Timer A clock input divider 1" ]
            # [ inline ( always ) ]
            pub fn id(&self) -> IdR {
                IdR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 7;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
            # [ doc = "Bits 9:10 - Timer A clock source select 1" ]
            # [ inline ( always ) ]
            pub fn tassel(&self) -> TasselR {
                TasselR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 9;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Timer A counter interrupt flag" ]
            # [ inline ( always ) ]
            pub fn taifg(&mut self) -> _TaifgW {
                _TaifgW { w: self }
            }
            # [ doc = "Bit 1 - Timer A counter interrupt enable" ]
            # [ inline ( always ) ]
            pub fn taie(&mut self) -> _TaieW {
                _TaieW { w: self }
            }
            # [ doc = "Bit 2 - Timer A counter clear" ]
            # [ inline ( always ) ]
            pub fn taclr(&mut self) -> _TaclrW {
                _TaclrW { w: self }
            }
            # [ doc = "Bits 5:6 - Timer A mode control 1" ]
            # [ inline ( always ) ]
            pub fn mc(&mut self) -> _McW {
                _McW { w: self }
            }
            # [ doc = "Bits 7:8 - Timer A clock input divider 1" ]
            # [ inline ( always ) ]
            pub fn id(&mut self) -> _IdW {
                _IdW { w: self }
            }
            # [ doc = "Bits 9:10 - Timer A clock source select 1" ]
            # [ inline ( always ) ]
            pub fn tassel(&mut self) -> _TasselW {
                _TasselW { w: self }
            }
        }
    }
    # [ doc = "Timer1_A3 Capture/Compare Control 0" ]
    pub struct Ta1cctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Capture/Compare Control 0" ]
    pub mod ta1cctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1cctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer1_A3 Capture/Compare Control 1" ]
    pub struct Ta1cctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Capture/Compare Control 1" ]
    pub mod ta1cctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1cctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer1_A3 Capture/Compare Control 2" ]
    pub struct Ta1cctl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Capture/Compare Control 2" ]
    pub mod ta1cctl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1cctl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcifgR {
            bits: u8,
        }
        impl CcifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CovR {
            bits: u8,
        }
        impl CovR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct OutR {
            bits: u8,
        }
        impl OutR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CciR {
            bits: u8,
        }
        impl CciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CcieR {
            bits: u8,
        }
        impl CcieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `OUTMOD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum OutmodR {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    OutmodR::Outmod0 => 0,
                    OutmodR::Outmod1 => 1,
                    OutmodR::Outmod2 => 2,
                    OutmodR::Outmod3 => 3,
                    OutmodR::Outmod4 => 4,
                    OutmodR::Outmod5 => 5,
                    OutmodR::Outmod6 => 6,
                    OutmodR::Outmod7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> OutmodR {
                match bits {
                    0 => OutmodR::Outmod0,
                    1 => OutmodR::Outmod1,
                    2 => OutmodR::Outmod2,
                    3 => OutmodR::Outmod3,
                    4 => OutmodR::Outmod4,
                    5 => OutmodR::Outmod5,
                    6 => OutmodR::Outmod6,
                    7 => OutmodR::Outmod7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Outmod0`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_0(&self) -> bool {
                *self == OutmodR::Outmod0
            }
            # [ doc = "Checks if the value of the field is `Outmod1`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_1(&self) -> bool {
                *self == OutmodR::Outmod1
            }
            # [ doc = "Checks if the value of the field is `Outmod2`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_2(&self) -> bool {
                *self == OutmodR::Outmod2
            }
            # [ doc = "Checks if the value of the field is `Outmod3`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_3(&self) -> bool {
                *self == OutmodR::Outmod3
            }
            # [ doc = "Checks if the value of the field is `Outmod4`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_4(&self) -> bool {
                *self == OutmodR::Outmod4
            }
            # [ doc = "Checks if the value of the field is `Outmod5`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_5(&self) -> bool {
                *self == OutmodR::Outmod5
            }
            # [ doc = "Checks if the value of the field is `Outmod6`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_6(&self) -> bool {
                *self == OutmodR::Outmod6
            }
            # [ doc = "Checks if the value of the field is `Outmod7`" ]
            # [ inline ( always ) ]
            pub fn is_outmod_7(&self) -> bool {
                *self == OutmodR::Outmod7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct CapR {
            bits: u8,
        }
        impl CapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScciR {
            bits: u8,
        }
        impl ScciR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ScsR {
            bits: u8,
        }
        impl ScsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `CCIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CcisR {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CcisR::Ccis0 => 0,
                    CcisR::Ccis1 => 1,
                    CcisR::Ccis2 => 2,
                    CcisR::Ccis3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CcisR {
                match bits {
                    0 => CcisR::Ccis0,
                    1 => CcisR::Ccis1,
                    2 => CcisR::Ccis2,
                    3 => CcisR::Ccis3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ccis0`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_0(&self) -> bool {
                *self == CcisR::Ccis0
            }
            # [ doc = "Checks if the value of the field is `Ccis1`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_1(&self) -> bool {
                *self == CcisR::Ccis1
            }
            # [ doc = "Checks if the value of the field is `Ccis2`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_2(&self) -> bool {
                *self == CcisR::Ccis2
            }
            # [ doc = "Checks if the value of the field is `Ccis3`" ]
            # [ inline ( always ) ]
            pub fn is_ccis_3(&self) -> bool {
                *self == CcisR::Ccis3
            }
        }
        # [ doc = "Possible values of the field `CM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum CmR {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    CmR::Cm0 => 0,
                    CmR::Cm1 => 1,
                    CmR::Cm2 => 2,
                    CmR::Cm3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> CmR {
                match bits {
                    0 => CmR::Cm0,
                    1 => CmR::Cm1,
                    2 => CmR::Cm2,
                    3 => CmR::Cm3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Cm0`" ]
            # [ inline ( always ) ]
            pub fn is_cm_0(&self) -> bool {
                *self == CmR::Cm0
            }
            # [ doc = "Checks if the value of the field is `Cm1`" ]
            # [ inline ( always ) ]
            pub fn is_cm_1(&self) -> bool {
                *self == CmR::Cm1
            }
            # [ doc = "Checks if the value of the field is `Cm2`" ]
            # [ inline ( always ) ]
            pub fn is_cm_2(&self) -> bool {
                *self == CmR::Cm2
            }
            # [ doc = "Checks if the value of the field is `Cm3`" ]
            # [ inline ( always ) ]
            pub fn is_cm_3(&self) -> bool {
                *self == CmR::Cm3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CovW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CovW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `OUTMOD`" ]
        pub enum OutmodW {
            # [ doc = "PWM output mode: 0 - output only" ]
            Outmod0,
            # [ doc = "PWM output mode: 1 - set" ]
            Outmod1,
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            Outmod2,
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            Outmod3,
            # [ doc = "PWM output mode: 4 - toggle" ]
            Outmod4,
            # [ doc = "PWM output mode: 5 - Reset" ]
            Outmod5,
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            Outmod6,
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            Outmod7,
        }
        impl OutmodW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OutmodW::Outmod0 => 0,
                    OutmodW::Outmod1 => 1,
                    OutmodW::Outmod2 => 2,
                    OutmodW::Outmod3 => 3,
                    OutmodW::Outmod4 => 4,
                    OutmodW::Outmod5 => 5,
                    OutmodW::Outmod6 => 6,
                    OutmodW::Outmod7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _OutmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OutmodW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: OutmodW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "PWM output mode: 0 - output only" ]
            # [ inline ( always ) ]
            pub fn outmod_0(self) -> &'a mut W {
                self.variant(OutmodW::Outmod0)
            }
            # [ doc = "PWM output mode: 1 - set" ]
            # [ inline ( always ) ]
            pub fn outmod_1(self) -> &'a mut W {
                self.variant(OutmodW::Outmod1)
            }
            # [ doc = "PWM output mode: 2 - PWM toggle/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_2(self) -> &'a mut W {
                self.variant(OutmodW::Outmod2)
            }
            # [ doc = "PWM output mode: 3 - PWM set/reset" ]
            # [ inline ( always ) ]
            pub fn outmod_3(self) -> &'a mut W {
                self.variant(OutmodW::Outmod3)
            }
            # [ doc = "PWM output mode: 4 - toggle" ]
            # [ inline ( always ) ]
            pub fn outmod_4(self) -> &'a mut W {
                self.variant(OutmodW::Outmod4)
            }
            # [ doc = "PWM output mode: 5 - Reset" ]
            # [ inline ( always ) ]
            pub fn outmod_5(self) -> &'a mut W {
                self.variant(OutmodW::Outmod5)
            }
            # [ doc = "PWM output mode: 6 - PWM toggle/set" ]
            # [ inline ( always ) ]
            pub fn outmod_6(self) -> &'a mut W {
                self.variant(OutmodW::Outmod6)
            }
            # [ doc = "PWM output mode: 7 - PWM reset/set" ]
            # [ inline ( always ) ]
            pub fn outmod_7(self) -> &'a mut W {
                self.variant(OutmodW::Outmod7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CapW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScciW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScciW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ScsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CCIS`" ]
        pub enum CcisW {
            # [ doc = "Capture input select: 0 - CCIxA" ]
            Ccis0,
            # [ doc = "Capture input select: 1 - CCIxB" ]
            Ccis1,
            # [ doc = "Capture input select: 2 - GND" ]
            Ccis2,
            # [ doc = "Capture input select: 3 - Vcc" ]
            Ccis3,
        }
        impl CcisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CcisW::Ccis0 => 0,
                    CcisW::Ccis1 => 1,
                    CcisW::Ccis2 => 2,
                    CcisW::Ccis3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CcisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CcisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture input select: 0 - CCIxA" ]
            # [ inline ( always ) ]
            pub fn ccis_0(self) -> &'a mut W {
                self.variant(CcisW::Ccis0)
            }
            # [ doc = "Capture input select: 1 - CCIxB" ]
            # [ inline ( always ) ]
            pub fn ccis_1(self) -> &'a mut W {
                self.variant(CcisW::Ccis1)
            }
            # [ doc = "Capture input select: 2 - GND" ]
            # [ inline ( always ) ]
            pub fn ccis_2(self) -> &'a mut W {
                self.variant(CcisW::Ccis2)
            }
            # [ doc = "Capture input select: 3 - Vcc" ]
            # [ inline ( always ) ]
            pub fn ccis_3(self) -> &'a mut W {
                self.variant(CcisW::Ccis3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `CM`" ]
        pub enum CmW {
            # [ doc = "Capture mode: 0 - disabled" ]
            Cm0,
            # [ doc = "Capture mode: 1 - pos. edge" ]
            Cm1,
            # [ doc = "Capture mode: 1 - neg. edge" ]
            Cm2,
            # [ doc = "Capture mode: 1 - both edges" ]
            Cm3,
        }
        impl CmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CmW::Cm0 => 0,
                    CmW::Cm1 => 1,
                    CmW::Cm2 => 2,
                    CmW::Cm3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _CmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: CmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Capture mode: 0 - disabled" ]
            # [ inline ( always ) ]
            pub fn cm_0(self) -> &'a mut W {
                self.variant(CmW::Cm0)
            }
            # [ doc = "Capture mode: 1 - pos. edge" ]
            # [ inline ( always ) ]
            pub fn cm_1(self) -> &'a mut W {
                self.variant(CmW::Cm1)
            }
            # [ doc = "Capture mode: 1 - neg. edge" ]
            # [ inline ( always ) ]
            pub fn cm_2(self) -> &'a mut W {
                self.variant(CmW::Cm2)
            }
            # [ doc = "Capture mode: 1 - both edges" ]
            # [ inline ( always ) ]
            pub fn cm_3(self) -> &'a mut W {
                self.variant(CmW::Cm3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&self) -> CcifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcifgR { bits }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&self) -> CovR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CovR { bits }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&self) -> OutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                OutR { bits }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&self) -> CciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CciR { bits }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&self) -> CcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CcieR { bits }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&self) -> CapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                CapR { bits }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&self) -> ScciR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScciR { bits }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&self) -> ScsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ScsR { bits }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&self) -> CcisR {
                CcisR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&self) -> CmR {
                CmR::_from({
                               const MASK: u8 = 3;
                               const OFFSET: u8 = 15;
                               ((self.bits >> OFFSET) & MASK as u16) as u8
                           })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Capture/compare interrupt flag" ]
            # [ inline ( always ) ]
            pub fn ccifg(&mut self) -> _CcifgW {
                _CcifgW { w: self }
            }
            # [ doc = "Bit 1 - Capture/compare overflow flag" ]
            # [ inline ( always ) ]
            pub fn cov(&mut self) -> _CovW {
                _CovW { w: self }
            }
            # [ doc = "Bit 2 - PWM Output signal if output mode 0" ]
            # [ inline ( always ) ]
            pub fn out(&mut self) -> _OutW {
                _OutW { w: self }
            }
            # [ doc = "Bit 3 - Capture input signal (read)" ]
            # [ inline ( always ) ]
            pub fn cci(&mut self) -> _CciW {
                _CciW { w: self }
            }
            # [ doc = "Bit 4 - Capture/compare interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ccie(&mut self) -> _CcieW {
                _CcieW { w: self }
            }
            # [ doc = "Bits 7:9 - Output mode 2" ]
            # [ inline ( always ) ]
            pub fn outmod(&mut self) -> _OutmodW {
                _OutmodW { w: self }
            }
            # [ doc = "Bit 8 - Capture mode: 1 /Compare mode : 0" ]
            # [ inline ( always ) ]
            pub fn cap(&mut self) -> _CapW {
                _CapW { w: self }
            }
            # [ doc = "Bit 10 - Latched capture signal (read)" ]
            # [ inline ( always ) ]
            pub fn scci(&mut self) -> _ScciW {
                _ScciW { w: self }
            }
            # [ doc = "Bit 11 - Capture sychronize" ]
            # [ inline ( always ) ]
            pub fn scs(&mut self) -> _ScsW {
                _ScsW { w: self }
            }
            # [ doc = "Bits 13:14 - Capture input select 1" ]
            # [ inline ( always ) ]
            pub fn ccis(&mut self) -> _CcisW {
                _CcisW { w: self }
            }
            # [ doc = "Bits 15:16 - Capture mode 1" ]
            # [ inline ( always ) ]
            pub fn cm(&mut self) -> _CmW {
                _CmW { w: self }
            }
        }
    }
    # [ doc = "Timer1_A3" ]
    pub struct Ta1r {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3" ]
    pub mod ta1r {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1r {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer1_A3 Capture/Compare 0" ]
    pub struct Ta1ccr0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Capture/Compare 0" ]
    pub mod ta1ccr0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1ccr0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer1_A3 Capture/Compare 1" ]
    pub struct Ta1ccr1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Capture/Compare 1" ]
    pub mod ta1ccr1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1ccr1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer1_A3 Capture/Compare 2" ]
    pub struct Ta1ccr2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Capture/Compare 2" ]
    pub mod ta1ccr2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1ccr2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer1_A3 Interrupt Vector Word" ]
    pub struct Ta1iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Interrupt Vector Word" ]
    pub mod ta1iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "Timer1_A3 Expansion Register 0" ]
    pub struct Ta1ex0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "Timer1_A3 Expansion Register 0" ]
    pub mod ta1ex0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ta1ex0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `TAIDEX`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum TaidexR {
            # [ doc = "Timer A Input divider expansion : /1" ]
            Taidex0,
            # [ doc = "Timer A Input divider expansion : /2" ]
            Taidex1,
            # [ doc = "Timer A Input divider expansion : /3" ]
            Taidex2,
            # [ doc = "Timer A Input divider expansion : /4" ]
            Taidex3,
            # [ doc = "Timer A Input divider expansion : /5" ]
            Taidex4,
            # [ doc = "Timer A Input divider expansion : /6" ]
            Taidex5,
            # [ doc = "Timer A Input divider expansion : /7" ]
            Taidex6,
            # [ doc = "Timer A Input divider expansion : /8" ]
            Taidex7,
        }
        impl TaidexR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    TaidexR::Taidex0 => 0,
                    TaidexR::Taidex1 => 1,
                    TaidexR::Taidex2 => 2,
                    TaidexR::Taidex3 => 3,
                    TaidexR::Taidex4 => 4,
                    TaidexR::Taidex5 => 5,
                    TaidexR::Taidex6 => 6,
                    TaidexR::Taidex7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> TaidexR {
                match bits {
                    0 => TaidexR::Taidex0,
                    1 => TaidexR::Taidex1,
                    2 => TaidexR::Taidex2,
                    3 => TaidexR::Taidex3,
                    4 => TaidexR::Taidex4,
                    5 => TaidexR::Taidex5,
                    6 => TaidexR::Taidex6,
                    7 => TaidexR::Taidex7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Taidex0`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_0(&self) -> bool {
                *self == TaidexR::Taidex0
            }
            # [ doc = "Checks if the value of the field is `Taidex1`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_1(&self) -> bool {
                *self == TaidexR::Taidex1
            }
            # [ doc = "Checks if the value of the field is `Taidex2`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_2(&self) -> bool {
                *self == TaidexR::Taidex2
            }
            # [ doc = "Checks if the value of the field is `Taidex3`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_3(&self) -> bool {
                *self == TaidexR::Taidex3
            }
            # [ doc = "Checks if the value of the field is `Taidex4`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_4(&self) -> bool {
                *self == TaidexR::Taidex4
            }
            # [ doc = "Checks if the value of the field is `Taidex5`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_5(&self) -> bool {
                *self == TaidexR::Taidex5
            }
            # [ doc = "Checks if the value of the field is `Taidex6`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_6(&self) -> bool {
                *self == TaidexR::Taidex6
            }
            # [ doc = "Checks if the value of the field is `Taidex7`" ]
            # [ inline ( always ) ]
            pub fn is_taidex_7(&self) -> bool {
                *self == TaidexR::Taidex7
            }
        }
        # [ doc = "Values that can be written to the field `TAIDEX`" ]
        pub enum TaidexW {
            # [ doc = "Timer A Input divider expansion : /1" ]
            Taidex0,
            # [ doc = "Timer A Input divider expansion : /2" ]
            Taidex1,
            # [ doc = "Timer A Input divider expansion : /3" ]
            Taidex2,
            # [ doc = "Timer A Input divider expansion : /4" ]
            Taidex3,
            # [ doc = "Timer A Input divider expansion : /5" ]
            Taidex4,
            # [ doc = "Timer A Input divider expansion : /6" ]
            Taidex5,
            # [ doc = "Timer A Input divider expansion : /7" ]
            Taidex6,
            # [ doc = "Timer A Input divider expansion : /8" ]
            Taidex7,
        }
        impl TaidexW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TaidexW::Taidex0 => 0,
                    TaidexW::Taidex1 => 1,
                    TaidexW::Taidex2 => 2,
                    TaidexW::Taidex3 => 3,
                    TaidexW::Taidex4 => 4,
                    TaidexW::Taidex5 => 5,
                    TaidexW::Taidex6 => 6,
                    TaidexW::Taidex7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _TaidexW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TaidexW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: TaidexW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Timer A Input divider expansion : /1" ]
            # [ inline ( always ) ]
            pub fn taidex_0(self) -> &'a mut W {
                self.variant(TaidexW::Taidex0)
            }
            # [ doc = "Timer A Input divider expansion : /2" ]
            # [ inline ( always ) ]
            pub fn taidex_1(self) -> &'a mut W {
                self.variant(TaidexW::Taidex1)
            }
            # [ doc = "Timer A Input divider expansion : /3" ]
            # [ inline ( always ) ]
            pub fn taidex_2(self) -> &'a mut W {
                self.variant(TaidexW::Taidex2)
            }
            # [ doc = "Timer A Input divider expansion : /4" ]
            # [ inline ( always ) ]
            pub fn taidex_3(self) -> &'a mut W {
                self.variant(TaidexW::Taidex3)
            }
            # [ doc = "Timer A Input divider expansion : /5" ]
            # [ inline ( always ) ]
            pub fn taidex_4(self) -> &'a mut W {
                self.variant(TaidexW::Taidex4)
            }
            # [ doc = "Timer A Input divider expansion : /6" ]
            # [ inline ( always ) ]
            pub fn taidex_5(self) -> &'a mut W {
                self.variant(TaidexW::Taidex5)
            }
            # [ doc = "Timer A Input divider expansion : /7" ]
            # [ inline ( always ) ]
            pub fn taidex_6(self) -> &'a mut W {
                self.variant(TaidexW::Taidex6)
            }
            # [ doc = "Timer A Input divider expansion : /8" ]
            # [ inline ( always ) ]
            pub fn taidex_7(self) -> &'a mut W {
                self.variant(TaidexW::Taidex7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - Timer A Input divider expansion Bit: 0" ]
            # [ inline ( always ) ]
            pub fn taidex(&self) -> TaidexR {
                TaidexR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - Timer A Input divider expansion Bit: 0" ]
            # [ inline ( always ) ]
            pub fn taidex(&mut self) -> _TaidexW {
                _TaidexW { w: self }
            }
        }
    }
}
# [ doc = "Timer1_A3" ]
pub struct Timer1A3 {
    register_block: timer1_a3::RegisterBlock,
}
impl Deref for Timer1A3 {
    type Target = timer1_a3::RegisterBlock;
    fn deref(&self) -> &timer1_a3::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "UCS Unified System Clock" ]
pub const UCS_UNIFIED_SYSTEM_CLOCK: Peripheral<UcsUnifiedSystemClock> =
    unsafe { Peripheral::new(0) };
# [ doc = "UCS Unified System Clock" ]
pub mod ucs_unified_system_clock {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 352usize],
        # [ doc = "0x160 - UCS Control Register 0" ]
        pub ucsctl0: Ucsctl0,
        # [ doc = "0x162 - UCS Control Register 1" ]
        pub ucsctl1: Ucsctl1,
        # [ doc = "0x164 - UCS Control Register 2" ]
        pub ucsctl2: Ucsctl2,
        # [ doc = "0x166 - UCS Control Register 3" ]
        pub ucsctl3: Ucsctl3,
        # [ doc = "0x168 - UCS Control Register 4" ]
        pub ucsctl4: Ucsctl4,
        # [ doc = "0x16a - UCS Control Register 5" ]
        pub ucsctl5: Ucsctl5,
        # [ doc = "0x16c - UCS Control Register 6" ]
        pub ucsctl6: Ucsctl6,
        # [ doc = "0x16e - UCS Control Register 7" ]
        pub ucsctl7: Ucsctl7,
        # [ doc = "0x170 - UCS Control Register 8" ]
        pub ucsctl8: Ucsctl8,
    }
    # [ doc = "UCS Control Register 0" ]
    pub struct Ucsctl0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 0" ]
    pub mod ucsctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mod0R {
            bits: u8,
        }
        impl Mod0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mod1R {
            bits: u8,
        }
        impl Mod1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mod2R {
            bits: u8,
        }
        impl Mod2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mod3R {
            bits: u8,
        }
        impl Mod3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Mod4R {
            bits: u8,
        }
        impl Mod4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dco0R {
            bits: u8,
        }
        impl Dco0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dco1R {
            bits: u8,
        }
        impl Dco1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dco2R {
            bits: u8,
        }
        impl Dco2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dco3R {
            bits: u8,
        }
        impl Dco3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Dco4R {
            bits: u8,
        }
        impl Dco4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mod0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mod0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mod1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mod1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mod2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mod2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mod3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mod3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Mod4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mod4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dco0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dco0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dco1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dco1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dco2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dco2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dco3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dco3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Dco4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dco4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 3 - Modulation Bit Counter Bit : 0" ]
            # [ inline ( always ) ]
            pub fn mod0(&self) -> Mod0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mod0R { bits }
            }
            # [ doc = "Bit 4 - Modulation Bit Counter Bit : 1" ]
            # [ inline ( always ) ]
            pub fn mod1(&self) -> Mod1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mod1R { bits }
            }
            # [ doc = "Bit 5 - Modulation Bit Counter Bit : 2" ]
            # [ inline ( always ) ]
            pub fn mod2(&self) -> Mod2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mod2R { bits }
            }
            # [ doc = "Bit 6 - Modulation Bit Counter Bit : 3" ]
            # [ inline ( always ) ]
            pub fn mod3(&self) -> Mod3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mod3R { bits }
            }
            # [ doc = "Bit 7 - Modulation Bit Counter Bit : 4" ]
            # [ inline ( always ) ]
            pub fn mod4(&self) -> Mod4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Mod4R { bits }
            }
            # [ doc = "Bit 8 - DCO TAP Bit : 0" ]
            # [ inline ( always ) ]
            pub fn dco0(&self) -> Dco0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Dco0R { bits }
            }
            # [ doc = "Bit 9 - DCO TAP Bit : 1" ]
            # [ inline ( always ) ]
            pub fn dco1(&self) -> Dco1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Dco1R { bits }
            }
            # [ doc = "Bit 10 - DCO TAP Bit : 2" ]
            # [ inline ( always ) ]
            pub fn dco2(&self) -> Dco2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Dco2R { bits }
            }
            # [ doc = "Bit 11 - DCO TAP Bit : 3" ]
            # [ inline ( always ) ]
            pub fn dco3(&self) -> Dco3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Dco3R { bits }
            }
            # [ doc = "Bit 12 - DCO TAP Bit : 4" ]
            # [ inline ( always ) ]
            pub fn dco4(&self) -> Dco4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Dco4R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 3 - Modulation Bit Counter Bit : 0" ]
            # [ inline ( always ) ]
            pub fn mod0(&mut self) -> _Mod0W {
                _Mod0W { w: self }
            }
            # [ doc = "Bit 4 - Modulation Bit Counter Bit : 1" ]
            # [ inline ( always ) ]
            pub fn mod1(&mut self) -> _Mod1W {
                _Mod1W { w: self }
            }
            # [ doc = "Bit 5 - Modulation Bit Counter Bit : 2" ]
            # [ inline ( always ) ]
            pub fn mod2(&mut self) -> _Mod2W {
                _Mod2W { w: self }
            }
            # [ doc = "Bit 6 - Modulation Bit Counter Bit : 3" ]
            # [ inline ( always ) ]
            pub fn mod3(&mut self) -> _Mod3W {
                _Mod3W { w: self }
            }
            # [ doc = "Bit 7 - Modulation Bit Counter Bit : 4" ]
            # [ inline ( always ) ]
            pub fn mod4(&mut self) -> _Mod4W {
                _Mod4W { w: self }
            }
            # [ doc = "Bit 8 - DCO TAP Bit : 0" ]
            # [ inline ( always ) ]
            pub fn dco0(&mut self) -> _Dco0W {
                _Dco0W { w: self }
            }
            # [ doc = "Bit 9 - DCO TAP Bit : 1" ]
            # [ inline ( always ) ]
            pub fn dco1(&mut self) -> _Dco1W {
                _Dco1W { w: self }
            }
            # [ doc = "Bit 10 - DCO TAP Bit : 2" ]
            # [ inline ( always ) ]
            pub fn dco2(&mut self) -> _Dco2W {
                _Dco2W { w: self }
            }
            # [ doc = "Bit 11 - DCO TAP Bit : 3" ]
            # [ inline ( always ) ]
            pub fn dco3(&mut self) -> _Dco3W {
                _Dco3W { w: self }
            }
            # [ doc = "Bit 12 - DCO TAP Bit : 4" ]
            # [ inline ( always ) ]
            pub fn dco4(&mut self) -> _Dco4W {
                _Dco4W { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 1" ]
    pub struct Ucsctl1 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 1" ]
    pub mod ucsctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DismodR {
            bits: u8,
        }
        impl DismodR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `DCORSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DcorselR {
            # [ doc = "DCO RSEL 0" ]
            Dcorsel0,
            # [ doc = "DCO RSEL 1" ]
            Dcorsel1,
            # [ doc = "DCO RSEL 2" ]
            Dcorsel2,
            # [ doc = "DCO RSEL 3" ]
            Dcorsel3,
            # [ doc = "DCO RSEL 4" ]
            Dcorsel4,
            # [ doc = "DCO RSEL 5" ]
            Dcorsel5,
            # [ doc = "DCO RSEL 6" ]
            Dcorsel6,
            # [ doc = "DCO RSEL 7" ]
            Dcorsel7,
        }
        impl DcorselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DcorselR::Dcorsel0 => 0,
                    DcorselR::Dcorsel1 => 1,
                    DcorselR::Dcorsel2 => 2,
                    DcorselR::Dcorsel3 => 3,
                    DcorselR::Dcorsel4 => 4,
                    DcorselR::Dcorsel5 => 5,
                    DcorselR::Dcorsel6 => 6,
                    DcorselR::Dcorsel7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DcorselR {
                match bits {
                    0 => DcorselR::Dcorsel0,
                    1 => DcorselR::Dcorsel1,
                    2 => DcorselR::Dcorsel2,
                    3 => DcorselR::Dcorsel3,
                    4 => DcorselR::Dcorsel4,
                    5 => DcorselR::Dcorsel5,
                    6 => DcorselR::Dcorsel6,
                    7 => DcorselR::Dcorsel7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Dcorsel0`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_0(&self) -> bool {
                *self == DcorselR::Dcorsel0
            }
            # [ doc = "Checks if the value of the field is `Dcorsel1`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_1(&self) -> bool {
                *self == DcorselR::Dcorsel1
            }
            # [ doc = "Checks if the value of the field is `Dcorsel2`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_2(&self) -> bool {
                *self == DcorselR::Dcorsel2
            }
            # [ doc = "Checks if the value of the field is `Dcorsel3`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_3(&self) -> bool {
                *self == DcorselR::Dcorsel3
            }
            # [ doc = "Checks if the value of the field is `Dcorsel4`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_4(&self) -> bool {
                *self == DcorselR::Dcorsel4
            }
            # [ doc = "Checks if the value of the field is `Dcorsel5`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_5(&self) -> bool {
                *self == DcorselR::Dcorsel5
            }
            # [ doc = "Checks if the value of the field is `Dcorsel6`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_6(&self) -> bool {
                *self == DcorselR::Dcorsel6
            }
            # [ doc = "Checks if the value of the field is `Dcorsel7`" ]
            # [ inline ( always ) ]
            pub fn is_dcorsel_7(&self) -> bool {
                *self == DcorselR::Dcorsel7
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DismodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DismodW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DCORSEL`" ]
        pub enum DcorselW {
            # [ doc = "DCO RSEL 0" ]
            Dcorsel0,
            # [ doc = "DCO RSEL 1" ]
            Dcorsel1,
            # [ doc = "DCO RSEL 2" ]
            Dcorsel2,
            # [ doc = "DCO RSEL 3" ]
            Dcorsel3,
            # [ doc = "DCO RSEL 4" ]
            Dcorsel4,
            # [ doc = "DCO RSEL 5" ]
            Dcorsel5,
            # [ doc = "DCO RSEL 6" ]
            Dcorsel6,
            # [ doc = "DCO RSEL 7" ]
            Dcorsel7,
        }
        impl DcorselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DcorselW::Dcorsel0 => 0,
                    DcorselW::Dcorsel1 => 1,
                    DcorselW::Dcorsel2 => 2,
                    DcorselW::Dcorsel3 => 3,
                    DcorselW::Dcorsel4 => 4,
                    DcorselW::Dcorsel5 => 5,
                    DcorselW::Dcorsel6 => 6,
                    DcorselW::Dcorsel7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DcorselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DcorselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DcorselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "DCO RSEL 0" ]
            # [ inline ( always ) ]
            pub fn dcorsel_0(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel0)
            }
            # [ doc = "DCO RSEL 1" ]
            # [ inline ( always ) ]
            pub fn dcorsel_1(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel1)
            }
            # [ doc = "DCO RSEL 2" ]
            # [ inline ( always ) ]
            pub fn dcorsel_2(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel2)
            }
            # [ doc = "DCO RSEL 3" ]
            # [ inline ( always ) ]
            pub fn dcorsel_3(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel3)
            }
            # [ doc = "DCO RSEL 4" ]
            # [ inline ( always ) ]
            pub fn dcorsel_4(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel4)
            }
            # [ doc = "DCO RSEL 5" ]
            # [ inline ( always ) ]
            pub fn dcorsel_5(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel5)
            }
            # [ doc = "DCO RSEL 6" ]
            # [ inline ( always ) ]
            pub fn dcorsel_6(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel6)
            }
            # [ doc = "DCO RSEL 7" ]
            # [ inline ( always ) ]
            pub fn dcorsel_7(self) -> &'a mut W {
                self.variant(DcorselW::Dcorsel7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - Disable Modulation" ]
            # [ inline ( always ) ]
            pub fn dismod(&self) -> DismodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DismodR { bits }
            }
            # [ doc = "Bits 6:8 - DCO Freq. Range Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn dcorsel(&self) -> DcorselR {
                DcorselR::_from({
                                    const MASK: u8 = 7;
                                    const OFFSET: u8 = 6;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Disable Modulation" ]
            # [ inline ( always ) ]
            pub fn dismod(&mut self) -> _DismodW {
                _DismodW { w: self }
            }
            # [ doc = "Bits 6:8 - DCO Freq. Range Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn dcorsel(&mut self) -> _DcorselW {
                _DcorselW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 2" ]
    pub struct Ucsctl2 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 2" ]
    pub mod ucsctl2 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl2 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln0R {
            bits: u8,
        }
        impl Flln0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln1R {
            bits: u8,
        }
        impl Flln1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln2R {
            bits: u8,
        }
        impl Flln2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln3R {
            bits: u8,
        }
        impl Flln3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln4R {
            bits: u8,
        }
        impl Flln4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln5R {
            bits: u8,
        }
        impl Flln5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln6R {
            bits: u8,
        }
        impl Flln6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln7R {
            bits: u8,
        }
        impl Flln7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln8R {
            bits: u8,
        }
        impl Flln8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Flln9R {
            bits: u8,
        }
        impl Flln9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `FLLD`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum FlldR {
            # [ doc = "Multiply Selected Loop Freq. 1" ]
            Flld0,
            # [ doc = "Multiply Selected Loop Freq. 2" ]
            Flld1,
            # [ doc = "Multiply Selected Loop Freq. 4" ]
            Flld2,
            # [ doc = "Multiply Selected Loop Freq. 8" ]
            Flld3,
            # [ doc = "Multiply Selected Loop Freq. 16" ]
            Flld4,
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            Flld5,
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            Flld6,
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            Flld7,
        }
        impl FlldR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    FlldR::Flld0 => 0,
                    FlldR::Flld1 => 1,
                    FlldR::Flld2 => 2,
                    FlldR::Flld3 => 3,
                    FlldR::Flld4 => 4,
                    FlldR::Flld5 => 5,
                    FlldR::Flld6 => 6,
                    FlldR::Flld7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> FlldR {
                match bits {
                    0 => FlldR::Flld0,
                    1 => FlldR::Flld1,
                    2 => FlldR::Flld2,
                    3 => FlldR::Flld3,
                    4 => FlldR::Flld4,
                    5 => FlldR::Flld5,
                    6 => FlldR::Flld6,
                    7 => FlldR::Flld7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Flld0`" ]
            # [ inline ( always ) ]
            pub fn is_flld_0(&self) -> bool {
                *self == FlldR::Flld0
            }
            # [ doc = "Checks if the value of the field is `Flld1`" ]
            # [ inline ( always ) ]
            pub fn is_flld_1(&self) -> bool {
                *self == FlldR::Flld1
            }
            # [ doc = "Checks if the value of the field is `Flld2`" ]
            # [ inline ( always ) ]
            pub fn is_flld_2(&self) -> bool {
                *self == FlldR::Flld2
            }
            # [ doc = "Checks if the value of the field is `Flld3`" ]
            # [ inline ( always ) ]
            pub fn is_flld_3(&self) -> bool {
                *self == FlldR::Flld3
            }
            # [ doc = "Checks if the value of the field is `Flld4`" ]
            # [ inline ( always ) ]
            pub fn is_flld_4(&self) -> bool {
                *self == FlldR::Flld4
            }
            # [ doc = "Checks if the value of the field is `Flld5`" ]
            # [ inline ( always ) ]
            pub fn is_flld_5(&self) -> bool {
                *self == FlldR::Flld5
            }
            # [ doc = "Checks if the value of the field is `Flld6`" ]
            # [ inline ( always ) ]
            pub fn is_flld_6(&self) -> bool {
                *self == FlldR::Flld6
            }
            # [ doc = "Checks if the value of the field is `Flld7`" ]
            # [ inline ( always ) ]
            pub fn is_flld_7(&self) -> bool {
                *self == FlldR::Flld7
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Flln9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Flln9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `FLLD`" ]
        pub enum FlldW {
            # [ doc = "Multiply Selected Loop Freq. 1" ]
            Flld0,
            # [ doc = "Multiply Selected Loop Freq. 2" ]
            Flld1,
            # [ doc = "Multiply Selected Loop Freq. 4" ]
            Flld2,
            # [ doc = "Multiply Selected Loop Freq. 8" ]
            Flld3,
            # [ doc = "Multiply Selected Loop Freq. 16" ]
            Flld4,
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            Flld5,
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            Flld6,
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            Flld7,
        }
        impl FlldW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FlldW::Flld0 => 0,
                    FlldW::Flld1 => 1,
                    FlldW::Flld2 => 2,
                    FlldW::Flld3 => 3,
                    FlldW::Flld4 => 4,
                    FlldW::Flld5 => 5,
                    FlldW::Flld6 => 6,
                    FlldW::Flld7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FlldW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FlldW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: FlldW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Multiply Selected Loop Freq. 1" ]
            # [ inline ( always ) ]
            pub fn flld_0(self) -> &'a mut W {
                self.variant(FlldW::Flld0)
            }
            # [ doc = "Multiply Selected Loop Freq. 2" ]
            # [ inline ( always ) ]
            pub fn flld_1(self) -> &'a mut W {
                self.variant(FlldW::Flld1)
            }
            # [ doc = "Multiply Selected Loop Freq. 4" ]
            # [ inline ( always ) ]
            pub fn flld_2(self) -> &'a mut W {
                self.variant(FlldW::Flld2)
            }
            # [ doc = "Multiply Selected Loop Freq. 8" ]
            # [ inline ( always ) ]
            pub fn flld_3(self) -> &'a mut W {
                self.variant(FlldW::Flld3)
            }
            # [ doc = "Multiply Selected Loop Freq. 16" ]
            # [ inline ( always ) ]
            pub fn flld_4(self) -> &'a mut W {
                self.variant(FlldW::Flld4)
            }
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            # [ inline ( always ) ]
            pub fn flld_5(self) -> &'a mut W {
                self.variant(FlldW::Flld5)
            }
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            # [ inline ( always ) ]
            pub fn flld_6(self) -> &'a mut W {
                self.variant(FlldW::Flld6)
            }
            # [ doc = "Multiply Selected Loop Freq. 32" ]
            # [ inline ( always ) ]
            pub fn flld_7(self) -> &'a mut W {
                self.variant(FlldW::Flld7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - FLL Multipier Bit : 0" ]
            # [ inline ( always ) ]
            pub fn flln0(&self) -> Flln0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln0R { bits }
            }
            # [ doc = "Bit 1 - FLL Multipier Bit : 1" ]
            # [ inline ( always ) ]
            pub fn flln1(&self) -> Flln1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln1R { bits }
            }
            # [ doc = "Bit 2 - FLL Multipier Bit : 2" ]
            # [ inline ( always ) ]
            pub fn flln2(&self) -> Flln2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln2R { bits }
            }
            # [ doc = "Bit 3 - FLL Multipier Bit : 3" ]
            # [ inline ( always ) ]
            pub fn flln3(&self) -> Flln3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln3R { bits }
            }
            # [ doc = "Bit 4 - FLL Multipier Bit : 4" ]
            # [ inline ( always ) ]
            pub fn flln4(&self) -> Flln4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln4R { bits }
            }
            # [ doc = "Bit 5 - FLL Multipier Bit : 5" ]
            # [ inline ( always ) ]
            pub fn flln5(&self) -> Flln5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln5R { bits }
            }
            # [ doc = "Bit 6 - FLL Multipier Bit : 6" ]
            # [ inline ( always ) ]
            pub fn flln6(&self) -> Flln6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln6R { bits }
            }
            # [ doc = "Bit 7 - FLL Multipier Bit : 7" ]
            # [ inline ( always ) ]
            pub fn flln7(&self) -> Flln7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln7R { bits }
            }
            # [ doc = "Bit 8 - FLL Multipier Bit : 8" ]
            # [ inline ( always ) ]
            pub fn flln8(&self) -> Flln8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln8R { bits }
            }
            # [ doc = "Bit 9 - FLL Multipier Bit : 9" ]
            # [ inline ( always ) ]
            pub fn flln9(&self) -> Flln9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Flln9R { bits }
            }
            # [ doc = "Bits 14:16 - Loop Divider Bit : 0" ]
            # [ inline ( always ) ]
            pub fn flld(&self) -> FlldR {
                FlldR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - FLL Multipier Bit : 0" ]
            # [ inline ( always ) ]
            pub fn flln0(&mut self) -> _Flln0W {
                _Flln0W { w: self }
            }
            # [ doc = "Bit 1 - FLL Multipier Bit : 1" ]
            # [ inline ( always ) ]
            pub fn flln1(&mut self) -> _Flln1W {
                _Flln1W { w: self }
            }
            # [ doc = "Bit 2 - FLL Multipier Bit : 2" ]
            # [ inline ( always ) ]
            pub fn flln2(&mut self) -> _Flln2W {
                _Flln2W { w: self }
            }
            # [ doc = "Bit 3 - FLL Multipier Bit : 3" ]
            # [ inline ( always ) ]
            pub fn flln3(&mut self) -> _Flln3W {
                _Flln3W { w: self }
            }
            # [ doc = "Bit 4 - FLL Multipier Bit : 4" ]
            # [ inline ( always ) ]
            pub fn flln4(&mut self) -> _Flln4W {
                _Flln4W { w: self }
            }
            # [ doc = "Bit 5 - FLL Multipier Bit : 5" ]
            # [ inline ( always ) ]
            pub fn flln5(&mut self) -> _Flln5W {
                _Flln5W { w: self }
            }
            # [ doc = "Bit 6 - FLL Multipier Bit : 6" ]
            # [ inline ( always ) ]
            pub fn flln6(&mut self) -> _Flln6W {
                _Flln6W { w: self }
            }
            # [ doc = "Bit 7 - FLL Multipier Bit : 7" ]
            # [ inline ( always ) ]
            pub fn flln7(&mut self) -> _Flln7W {
                _Flln7W { w: self }
            }
            # [ doc = "Bit 8 - FLL Multipier Bit : 8" ]
            # [ inline ( always ) ]
            pub fn flln8(&mut self) -> _Flln8W {
                _Flln8W { w: self }
            }
            # [ doc = "Bit 9 - FLL Multipier Bit : 9" ]
            # [ inline ( always ) ]
            pub fn flln9(&mut self) -> _Flln9W {
                _Flln9W { w: self }
            }
            # [ doc = "Bits 14:16 - Loop Divider Bit : 0" ]
            # [ inline ( always ) ]
            pub fn flld(&mut self) -> _FlldW {
                _FlldW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 3" ]
    pub struct Ucsctl3 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 3" ]
    pub mod ucsctl3 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl3 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `FLLREFDIV`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum FllrefdivR {
            # [ doc = "Reference Divider: f(LFCLK)/1" ]
            Fllrefdiv0,
            # [ doc = "Reference Divider: f(LFCLK)/2" ]
            Fllrefdiv1,
            # [ doc = "Reference Divider: f(LFCLK)/4" ]
            Fllrefdiv2,
            # [ doc = "Reference Divider: f(LFCLK)/8" ]
            Fllrefdiv3,
            # [ doc = "Reference Divider: f(LFCLK)/12" ]
            Fllrefdiv4,
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            Fllrefdiv5,
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            Fllrefdiv6,
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            Fllrefdiv7,
        }
        impl FllrefdivR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    FllrefdivR::Fllrefdiv0 => 0,
                    FllrefdivR::Fllrefdiv1 => 1,
                    FllrefdivR::Fllrefdiv2 => 2,
                    FllrefdivR::Fllrefdiv3 => 3,
                    FllrefdivR::Fllrefdiv4 => 4,
                    FllrefdivR::Fllrefdiv5 => 5,
                    FllrefdivR::Fllrefdiv6 => 6,
                    FllrefdivR::Fllrefdiv7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> FllrefdivR {
                match bits {
                    0 => FllrefdivR::Fllrefdiv0,
                    1 => FllrefdivR::Fllrefdiv1,
                    2 => FllrefdivR::Fllrefdiv2,
                    3 => FllrefdivR::Fllrefdiv3,
                    4 => FllrefdivR::Fllrefdiv4,
                    5 => FllrefdivR::Fllrefdiv5,
                    6 => FllrefdivR::Fllrefdiv6,
                    7 => FllrefdivR::Fllrefdiv7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv0`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_0(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv0
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv1`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_1(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv1
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv2`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_2(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv2
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv3`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_3(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv3
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv4`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_4(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv4
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv5`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_5(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv5
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv6`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_6(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv6
            }
            # [ doc = "Checks if the value of the field is `Fllrefdiv7`" ]
            # [ inline ( always ) ]
            pub fn is_fllrefdiv_7(&self) -> bool {
                *self == FllrefdivR::Fllrefdiv7
            }
        }
        # [ doc = "Possible values of the field `SELREF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SelrefR {
            # [ doc = "FLL Reference Clock Select 0" ]
            Selref0,
            # [ doc = "FLL Reference Clock Select 1" ]
            Selref1,
            # [ doc = "FLL Reference Clock Select 2" ]
            Selref2,
            # [ doc = "FLL Reference Clock Select 3" ]
            Selref3,
            # [ doc = "FLL Reference Clock Select 4" ]
            Selref4,
            # [ doc = "FLL Reference Clock Select 5" ]
            Selref5,
            # [ doc = "FLL Reference Clock Select 6" ]
            Selref6,
            # [ doc = "FLL Reference Clock Select 7" ]
            Selref7,
        }
        impl SelrefR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SelrefR::Selref0 => 0,
                    SelrefR::Selref1 => 1,
                    SelrefR::Selref2 => 2,
                    SelrefR::Selref3 => 3,
                    SelrefR::Selref4 => 4,
                    SelrefR::Selref5 => 5,
                    SelrefR::Selref6 => 6,
                    SelrefR::Selref7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SelrefR {
                match bits {
                    0 => SelrefR::Selref0,
                    1 => SelrefR::Selref1,
                    2 => SelrefR::Selref2,
                    3 => SelrefR::Selref3,
                    4 => SelrefR::Selref4,
                    5 => SelrefR::Selref5,
                    6 => SelrefR::Selref6,
                    7 => SelrefR::Selref7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Selref0`" ]
            # [ inline ( always ) ]
            pub fn is_selref_0(&self) -> bool {
                *self == SelrefR::Selref0
            }
            # [ doc = "Checks if the value of the field is `Selref1`" ]
            # [ inline ( always ) ]
            pub fn is_selref_1(&self) -> bool {
                *self == SelrefR::Selref1
            }
            # [ doc = "Checks if the value of the field is `Selref2`" ]
            # [ inline ( always ) ]
            pub fn is_selref_2(&self) -> bool {
                *self == SelrefR::Selref2
            }
            # [ doc = "Checks if the value of the field is `Selref3`" ]
            # [ inline ( always ) ]
            pub fn is_selref_3(&self) -> bool {
                *self == SelrefR::Selref3
            }
            # [ doc = "Checks if the value of the field is `Selref4`" ]
            # [ inline ( always ) ]
            pub fn is_selref_4(&self) -> bool {
                *self == SelrefR::Selref4
            }
            # [ doc = "Checks if the value of the field is `Selref5`" ]
            # [ inline ( always ) ]
            pub fn is_selref_5(&self) -> bool {
                *self == SelrefR::Selref5
            }
            # [ doc = "Checks if the value of the field is `Selref6`" ]
            # [ inline ( always ) ]
            pub fn is_selref_6(&self) -> bool {
                *self == SelrefR::Selref6
            }
            # [ doc = "Checks if the value of the field is `Selref7`" ]
            # [ inline ( always ) ]
            pub fn is_selref_7(&self) -> bool {
                *self == SelrefR::Selref7
            }
        }
        # [ doc = "Values that can be written to the field `FLLREFDIV`" ]
        pub enum FllrefdivW {
            # [ doc = "Reference Divider: f(LFCLK)/1" ]
            Fllrefdiv0,
            # [ doc = "Reference Divider: f(LFCLK)/2" ]
            Fllrefdiv1,
            # [ doc = "Reference Divider: f(LFCLK)/4" ]
            Fllrefdiv2,
            # [ doc = "Reference Divider: f(LFCLK)/8" ]
            Fllrefdiv3,
            # [ doc = "Reference Divider: f(LFCLK)/12" ]
            Fllrefdiv4,
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            Fllrefdiv5,
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            Fllrefdiv6,
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            Fllrefdiv7,
        }
        impl FllrefdivW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FllrefdivW::Fllrefdiv0 => 0,
                    FllrefdivW::Fllrefdiv1 => 1,
                    FllrefdivW::Fllrefdiv2 => 2,
                    FllrefdivW::Fllrefdiv3 => 3,
                    FllrefdivW::Fllrefdiv4 => 4,
                    FllrefdivW::Fllrefdiv5 => 5,
                    FllrefdivW::Fllrefdiv6 => 6,
                    FllrefdivW::Fllrefdiv7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _FllrefdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FllrefdivW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: FllrefdivW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Reference Divider: f(LFCLK)/1" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_0(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv0)
            }
            # [ doc = "Reference Divider: f(LFCLK)/2" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_1(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv1)
            }
            # [ doc = "Reference Divider: f(LFCLK)/4" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_2(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv2)
            }
            # [ doc = "Reference Divider: f(LFCLK)/8" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_3(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv3)
            }
            # [ doc = "Reference Divider: f(LFCLK)/12" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_4(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv4)
            }
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_5(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv5)
            }
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_6(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv6)
            }
            # [ doc = "Reference Divider: f(LFCLK)/16" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv_7(self) -> &'a mut W {
                self.variant(FllrefdivW::Fllrefdiv7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SELREF`" ]
        pub enum SelrefW {
            # [ doc = "FLL Reference Clock Select 0" ]
            Selref0,
            # [ doc = "FLL Reference Clock Select 1" ]
            Selref1,
            # [ doc = "FLL Reference Clock Select 2" ]
            Selref2,
            # [ doc = "FLL Reference Clock Select 3" ]
            Selref3,
            # [ doc = "FLL Reference Clock Select 4" ]
            Selref4,
            # [ doc = "FLL Reference Clock Select 5" ]
            Selref5,
            # [ doc = "FLL Reference Clock Select 6" ]
            Selref6,
            # [ doc = "FLL Reference Clock Select 7" ]
            Selref7,
        }
        impl SelrefW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SelrefW::Selref0 => 0,
                    SelrefW::Selref1 => 1,
                    SelrefW::Selref2 => 2,
                    SelrefW::Selref3 => 3,
                    SelrefW::Selref4 => 4,
                    SelrefW::Selref5 => 5,
                    SelrefW::Selref6 => 6,
                    SelrefW::Selref7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SelrefW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SelrefW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SelrefW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "FLL Reference Clock Select 0" ]
            # [ inline ( always ) ]
            pub fn selref_0(self) -> &'a mut W {
                self.variant(SelrefW::Selref0)
            }
            # [ doc = "FLL Reference Clock Select 1" ]
            # [ inline ( always ) ]
            pub fn selref_1(self) -> &'a mut W {
                self.variant(SelrefW::Selref1)
            }
            # [ doc = "FLL Reference Clock Select 2" ]
            # [ inline ( always ) ]
            pub fn selref_2(self) -> &'a mut W {
                self.variant(SelrefW::Selref2)
            }
            # [ doc = "FLL Reference Clock Select 3" ]
            # [ inline ( always ) ]
            pub fn selref_3(self) -> &'a mut W {
                self.variant(SelrefW::Selref3)
            }
            # [ doc = "FLL Reference Clock Select 4" ]
            # [ inline ( always ) ]
            pub fn selref_4(self) -> &'a mut W {
                self.variant(SelrefW::Selref4)
            }
            # [ doc = "FLL Reference Clock Select 5" ]
            # [ inline ( always ) ]
            pub fn selref_5(self) -> &'a mut W {
                self.variant(SelrefW::Selref5)
            }
            # [ doc = "FLL Reference Clock Select 6" ]
            # [ inline ( always ) ]
            pub fn selref_6(self) -> &'a mut W {
                self.variant(SelrefW::Selref6)
            }
            # [ doc = "FLL Reference Clock Select 7" ]
            # [ inline ( always ) ]
            pub fn selref_7(self) -> &'a mut W {
                self.variant(SelrefW::Selref7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - Reference Divider Bit : 0" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv(&self) -> FllrefdivR {
                FllrefdivR::_from({
                                      const MASK: u8 = 7;
                                      const OFFSET: u8 = 2;
                                      ((self.bits >> OFFSET) & MASK as u16) as u8
                                  })
            }
            # [ doc = "Bits 6:8 - FLL Reference Clock Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn selref(&self) -> SelrefR {
                SelrefR::_from({
                                   const MASK: u8 = 7;
                                   const OFFSET: u8 = 6;
                                   ((self.bits >> OFFSET) & MASK as u16) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - Reference Divider Bit : 0" ]
            # [ inline ( always ) ]
            pub fn fllrefdiv(&mut self) -> _FllrefdivW {
                _FllrefdivW { w: self }
            }
            # [ doc = "Bits 6:8 - FLL Reference Clock Select Bit : 0" ]
            # [ inline ( always ) ]
            pub fn selref(&mut self) -> _SelrefW {
                _SelrefW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 4" ]
    pub struct Ucsctl4 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 4" ]
    pub mod ucsctl4 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl4 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `SELM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SelmR {
            # [ doc = "MCLK Source Select 0" ]
            Selm0,
            # [ doc = "MCLK Source Select 1" ]
            Selm1,
            # [ doc = "MCLK Source Select 2" ]
            Selm2,
            # [ doc = "MCLK Source Select 3" ]
            Selm3,
            # [ doc = "MCLK Source Select 4" ]
            Selm4,
            # [ doc = "MCLK Source Select 5" ]
            Selm5,
            # [ doc = "MCLK Source Select 6" ]
            Selm6,
            # [ doc = "MCLK Source Select 7" ]
            Selm7,
        }
        impl SelmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SelmR::Selm0 => 0,
                    SelmR::Selm1 => 1,
                    SelmR::Selm2 => 2,
                    SelmR::Selm3 => 3,
                    SelmR::Selm4 => 4,
                    SelmR::Selm5 => 5,
                    SelmR::Selm6 => 6,
                    SelmR::Selm7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SelmR {
                match bits {
                    0 => SelmR::Selm0,
                    1 => SelmR::Selm1,
                    2 => SelmR::Selm2,
                    3 => SelmR::Selm3,
                    4 => SelmR::Selm4,
                    5 => SelmR::Selm5,
                    6 => SelmR::Selm6,
                    7 => SelmR::Selm7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Selm0`" ]
            # [ inline ( always ) ]
            pub fn is_selm_0(&self) -> bool {
                *self == SelmR::Selm0
            }
            # [ doc = "Checks if the value of the field is `Selm1`" ]
            # [ inline ( always ) ]
            pub fn is_selm_1(&self) -> bool {
                *self == SelmR::Selm1
            }
            # [ doc = "Checks if the value of the field is `Selm2`" ]
            # [ inline ( always ) ]
            pub fn is_selm_2(&self) -> bool {
                *self == SelmR::Selm2
            }
            # [ doc = "Checks if the value of the field is `Selm3`" ]
            # [ inline ( always ) ]
            pub fn is_selm_3(&self) -> bool {
                *self == SelmR::Selm3
            }
            # [ doc = "Checks if the value of the field is `Selm4`" ]
            # [ inline ( always ) ]
            pub fn is_selm_4(&self) -> bool {
                *self == SelmR::Selm4
            }
            # [ doc = "Checks if the value of the field is `Selm5`" ]
            # [ inline ( always ) ]
            pub fn is_selm_5(&self) -> bool {
                *self == SelmR::Selm5
            }
            # [ doc = "Checks if the value of the field is `Selm6`" ]
            # [ inline ( always ) ]
            pub fn is_selm_6(&self) -> bool {
                *self == SelmR::Selm6
            }
            # [ doc = "Checks if the value of the field is `Selm7`" ]
            # [ inline ( always ) ]
            pub fn is_selm_7(&self) -> bool {
                *self == SelmR::Selm7
            }
        }
        # [ doc = "Possible values of the field `SELS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SelsR {
            # [ doc = "SMCLK Source Select 0" ]
            Sels0,
            # [ doc = "SMCLK Source Select 1" ]
            Sels1,
            # [ doc = "SMCLK Source Select 2" ]
            Sels2,
            # [ doc = "SMCLK Source Select 3" ]
            Sels3,
            # [ doc = "SMCLK Source Select 4" ]
            Sels4,
            # [ doc = "SMCLK Source Select 5" ]
            Sels5,
            # [ doc = "SMCLK Source Select 6" ]
            Sels6,
            # [ doc = "SMCLK Source Select 7" ]
            Sels7,
        }
        impl SelsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SelsR::Sels0 => 0,
                    SelsR::Sels1 => 1,
                    SelsR::Sels2 => 2,
                    SelsR::Sels3 => 3,
                    SelsR::Sels4 => 4,
                    SelsR::Sels5 => 5,
                    SelsR::Sels6 => 6,
                    SelsR::Sels7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SelsR {
                match bits {
                    0 => SelsR::Sels0,
                    1 => SelsR::Sels1,
                    2 => SelsR::Sels2,
                    3 => SelsR::Sels3,
                    4 => SelsR::Sels4,
                    5 => SelsR::Sels5,
                    6 => SelsR::Sels6,
                    7 => SelsR::Sels7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Sels0`" ]
            # [ inline ( always ) ]
            pub fn is_sels_0(&self) -> bool {
                *self == SelsR::Sels0
            }
            # [ doc = "Checks if the value of the field is `Sels1`" ]
            # [ inline ( always ) ]
            pub fn is_sels_1(&self) -> bool {
                *self == SelsR::Sels1
            }
            # [ doc = "Checks if the value of the field is `Sels2`" ]
            # [ inline ( always ) ]
            pub fn is_sels_2(&self) -> bool {
                *self == SelsR::Sels2
            }
            # [ doc = "Checks if the value of the field is `Sels3`" ]
            # [ inline ( always ) ]
            pub fn is_sels_3(&self) -> bool {
                *self == SelsR::Sels3
            }
            # [ doc = "Checks if the value of the field is `Sels4`" ]
            # [ inline ( always ) ]
            pub fn is_sels_4(&self) -> bool {
                *self == SelsR::Sels4
            }
            # [ doc = "Checks if the value of the field is `Sels5`" ]
            # [ inline ( always ) ]
            pub fn is_sels_5(&self) -> bool {
                *self == SelsR::Sels5
            }
            # [ doc = "Checks if the value of the field is `Sels6`" ]
            # [ inline ( always ) ]
            pub fn is_sels_6(&self) -> bool {
                *self == SelsR::Sels6
            }
            # [ doc = "Checks if the value of the field is `Sels7`" ]
            # [ inline ( always ) ]
            pub fn is_sels_7(&self) -> bool {
                *self == SelsR::Sels7
            }
        }
        # [ doc = "Possible values of the field `SELA`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum SelaR {
            # [ doc = "ACLK Source Select 0" ]
            Sela0,
            # [ doc = "ACLK Source Select 1" ]
            Sela1,
            # [ doc = "ACLK Source Select 2" ]
            Sela2,
            # [ doc = "ACLK Source Select 3" ]
            Sela3,
            # [ doc = "ACLK Source Select 4" ]
            Sela4,
            # [ doc = "ACLK Source Select 5" ]
            Sela5,
            # [ doc = "ACLK Source Select 6" ]
            Sela6,
            # [ doc = "ACLK Source Select 7" ]
            Sela7,
        }
        impl SelaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    SelaR::Sela0 => 0,
                    SelaR::Sela1 => 1,
                    SelaR::Sela2 => 2,
                    SelaR::Sela3 => 3,
                    SelaR::Sela4 => 4,
                    SelaR::Sela5 => 5,
                    SelaR::Sela6 => 6,
                    SelaR::Sela7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> SelaR {
                match bits {
                    0 => SelaR::Sela0,
                    1 => SelaR::Sela1,
                    2 => SelaR::Sela2,
                    3 => SelaR::Sela3,
                    4 => SelaR::Sela4,
                    5 => SelaR::Sela5,
                    6 => SelaR::Sela6,
                    7 => SelaR::Sela7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Sela0`" ]
            # [ inline ( always ) ]
            pub fn is_sela_0(&self) -> bool {
                *self == SelaR::Sela0
            }
            # [ doc = "Checks if the value of the field is `Sela1`" ]
            # [ inline ( always ) ]
            pub fn is_sela_1(&self) -> bool {
                *self == SelaR::Sela1
            }
            # [ doc = "Checks if the value of the field is `Sela2`" ]
            # [ inline ( always ) ]
            pub fn is_sela_2(&self) -> bool {
                *self == SelaR::Sela2
            }
            # [ doc = "Checks if the value of the field is `Sela3`" ]
            # [ inline ( always ) ]
            pub fn is_sela_3(&self) -> bool {
                *self == SelaR::Sela3
            }
            # [ doc = "Checks if the value of the field is `Sela4`" ]
            # [ inline ( always ) ]
            pub fn is_sela_4(&self) -> bool {
                *self == SelaR::Sela4
            }
            # [ doc = "Checks if the value of the field is `Sela5`" ]
            # [ inline ( always ) ]
            pub fn is_sela_5(&self) -> bool {
                *self == SelaR::Sela5
            }
            # [ doc = "Checks if the value of the field is `Sela6`" ]
            # [ inline ( always ) ]
            pub fn is_sela_6(&self) -> bool {
                *self == SelaR::Sela6
            }
            # [ doc = "Checks if the value of the field is `Sela7`" ]
            # [ inline ( always ) ]
            pub fn is_sela_7(&self) -> bool {
                *self == SelaR::Sela7
            }
        }
        # [ doc = "Values that can be written to the field `SELM`" ]
        pub enum SelmW {
            # [ doc = "MCLK Source Select 0" ]
            Selm0,
            # [ doc = "MCLK Source Select 1" ]
            Selm1,
            # [ doc = "MCLK Source Select 2" ]
            Selm2,
            # [ doc = "MCLK Source Select 3" ]
            Selm3,
            # [ doc = "MCLK Source Select 4" ]
            Selm4,
            # [ doc = "MCLK Source Select 5" ]
            Selm5,
            # [ doc = "MCLK Source Select 6" ]
            Selm6,
            # [ doc = "MCLK Source Select 7" ]
            Selm7,
        }
        impl SelmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SelmW::Selm0 => 0,
                    SelmW::Selm1 => 1,
                    SelmW::Selm2 => 2,
                    SelmW::Selm3 => 3,
                    SelmW::Selm4 => 4,
                    SelmW::Selm5 => 5,
                    SelmW::Selm6 => 6,
                    SelmW::Selm7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SelmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SelmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SelmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "MCLK Source Select 0" ]
            # [ inline ( always ) ]
            pub fn selm_0(self) -> &'a mut W {
                self.variant(SelmW::Selm0)
            }
            # [ doc = "MCLK Source Select 1" ]
            # [ inline ( always ) ]
            pub fn selm_1(self) -> &'a mut W {
                self.variant(SelmW::Selm1)
            }
            # [ doc = "MCLK Source Select 2" ]
            # [ inline ( always ) ]
            pub fn selm_2(self) -> &'a mut W {
                self.variant(SelmW::Selm2)
            }
            # [ doc = "MCLK Source Select 3" ]
            # [ inline ( always ) ]
            pub fn selm_3(self) -> &'a mut W {
                self.variant(SelmW::Selm3)
            }
            # [ doc = "MCLK Source Select 4" ]
            # [ inline ( always ) ]
            pub fn selm_4(self) -> &'a mut W {
                self.variant(SelmW::Selm4)
            }
            # [ doc = "MCLK Source Select 5" ]
            # [ inline ( always ) ]
            pub fn selm_5(self) -> &'a mut W {
                self.variant(SelmW::Selm5)
            }
            # [ doc = "MCLK Source Select 6" ]
            # [ inline ( always ) ]
            pub fn selm_6(self) -> &'a mut W {
                self.variant(SelmW::Selm6)
            }
            # [ doc = "MCLK Source Select 7" ]
            # [ inline ( always ) ]
            pub fn selm_7(self) -> &'a mut W {
                self.variant(SelmW::Selm7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SELS`" ]
        pub enum SelsW {
            # [ doc = "SMCLK Source Select 0" ]
            Sels0,
            # [ doc = "SMCLK Source Select 1" ]
            Sels1,
            # [ doc = "SMCLK Source Select 2" ]
            Sels2,
            # [ doc = "SMCLK Source Select 3" ]
            Sels3,
            # [ doc = "SMCLK Source Select 4" ]
            Sels4,
            # [ doc = "SMCLK Source Select 5" ]
            Sels5,
            # [ doc = "SMCLK Source Select 6" ]
            Sels6,
            # [ doc = "SMCLK Source Select 7" ]
            Sels7,
        }
        impl SelsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SelsW::Sels0 => 0,
                    SelsW::Sels1 => 1,
                    SelsW::Sels2 => 2,
                    SelsW::Sels3 => 3,
                    SelsW::Sels4 => 4,
                    SelsW::Sels5 => 5,
                    SelsW::Sels6 => 6,
                    SelsW::Sels7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SelsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SelsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SelsW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "SMCLK Source Select 0" ]
            # [ inline ( always ) ]
            pub fn sels_0(self) -> &'a mut W {
                self.variant(SelsW::Sels0)
            }
            # [ doc = "SMCLK Source Select 1" ]
            # [ inline ( always ) ]
            pub fn sels_1(self) -> &'a mut W {
                self.variant(SelsW::Sels1)
            }
            # [ doc = "SMCLK Source Select 2" ]
            # [ inline ( always ) ]
            pub fn sels_2(self) -> &'a mut W {
                self.variant(SelsW::Sels2)
            }
            # [ doc = "SMCLK Source Select 3" ]
            # [ inline ( always ) ]
            pub fn sels_3(self) -> &'a mut W {
                self.variant(SelsW::Sels3)
            }
            # [ doc = "SMCLK Source Select 4" ]
            # [ inline ( always ) ]
            pub fn sels_4(self) -> &'a mut W {
                self.variant(SelsW::Sels4)
            }
            # [ doc = "SMCLK Source Select 5" ]
            # [ inline ( always ) ]
            pub fn sels_5(self) -> &'a mut W {
                self.variant(SelsW::Sels5)
            }
            # [ doc = "SMCLK Source Select 6" ]
            # [ inline ( always ) ]
            pub fn sels_6(self) -> &'a mut W {
                self.variant(SelsW::Sels6)
            }
            # [ doc = "SMCLK Source Select 7" ]
            # [ inline ( always ) ]
            pub fn sels_7(self) -> &'a mut W {
                self.variant(SelsW::Sels7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `SELA`" ]
        pub enum SelaW {
            # [ doc = "ACLK Source Select 0" ]
            Sela0,
            # [ doc = "ACLK Source Select 1" ]
            Sela1,
            # [ doc = "ACLK Source Select 2" ]
            Sela2,
            # [ doc = "ACLK Source Select 3" ]
            Sela3,
            # [ doc = "ACLK Source Select 4" ]
            Sela4,
            # [ doc = "ACLK Source Select 5" ]
            Sela5,
            # [ doc = "ACLK Source Select 6" ]
            Sela6,
            # [ doc = "ACLK Source Select 7" ]
            Sela7,
        }
        impl SelaW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SelaW::Sela0 => 0,
                    SelaW::Sela1 => 1,
                    SelaW::Sela2 => 2,
                    SelaW::Sela3 => 3,
                    SelaW::Sela4 => 4,
                    SelaW::Sela5 => 5,
                    SelaW::Sela6 => 6,
                    SelaW::Sela7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SelaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SelaW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: SelaW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ACLK Source Select 0" ]
            # [ inline ( always ) ]
            pub fn sela_0(self) -> &'a mut W {
                self.variant(SelaW::Sela0)
            }
            # [ doc = "ACLK Source Select 1" ]
            # [ inline ( always ) ]
            pub fn sela_1(self) -> &'a mut W {
                self.variant(SelaW::Sela1)
            }
            # [ doc = "ACLK Source Select 2" ]
            # [ inline ( always ) ]
            pub fn sela_2(self) -> &'a mut W {
                self.variant(SelaW::Sela2)
            }
            # [ doc = "ACLK Source Select 3" ]
            # [ inline ( always ) ]
            pub fn sela_3(self) -> &'a mut W {
                self.variant(SelaW::Sela3)
            }
            # [ doc = "ACLK Source Select 4" ]
            # [ inline ( always ) ]
            pub fn sela_4(self) -> &'a mut W {
                self.variant(SelaW::Sela4)
            }
            # [ doc = "ACLK Source Select 5" ]
            # [ inline ( always ) ]
            pub fn sela_5(self) -> &'a mut W {
                self.variant(SelaW::Sela5)
            }
            # [ doc = "ACLK Source Select 6" ]
            # [ inline ( always ) ]
            pub fn sela_6(self) -> &'a mut W {
                self.variant(SelaW::Sela6)
            }
            # [ doc = "ACLK Source Select 7" ]
            # [ inline ( always ) ]
            pub fn sela_7(self) -> &'a mut W {
                self.variant(SelaW::Sela7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - MCLK Source Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn selm(&self) -> SelmR {
                SelmR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 2;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 6:8 - SMCLK Source Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn sels(&self) -> SelsR {
                SelsR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 6;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 10:12 - ACLK Source Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn sela(&self) -> SelaR {
                SelaR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - MCLK Source Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn selm(&mut self) -> _SelmW {
                _SelmW { w: self }
            }
            # [ doc = "Bits 6:8 - SMCLK Source Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn sels(&mut self) -> _SelsW {
                _SelsW { w: self }
            }
            # [ doc = "Bits 10:12 - ACLK Source Select Bit: 0" ]
            # [ inline ( always ) ]
            pub fn sela(&mut self) -> _SelaW {
                _SelaW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 5" ]
    pub struct Ucsctl5 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 5" ]
    pub mod ucsctl5 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl5 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `DIVM`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DivmR {
            # [ doc = "MCLK Source Divider 0" ]
            Divm0,
            # [ doc = "MCLK Source Divider 1" ]
            Divm1,
            # [ doc = "MCLK Source Divider 2" ]
            Divm2,
            # [ doc = "MCLK Source Divider 3" ]
            Divm3,
            # [ doc = "MCLK Source Divider 4" ]
            Divm4,
            # [ doc = "MCLK Source Divider 5" ]
            Divm5,
            # [ doc = "MCLK Source Divider 6" ]
            Divm6,
            # [ doc = "MCLK Source Divider 7" ]
            Divm7,
        }
        impl DivmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DivmR::Divm0 => 0,
                    DivmR::Divm1 => 1,
                    DivmR::Divm2 => 2,
                    DivmR::Divm3 => 3,
                    DivmR::Divm4 => 4,
                    DivmR::Divm5 => 5,
                    DivmR::Divm6 => 6,
                    DivmR::Divm7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DivmR {
                match bits {
                    0 => DivmR::Divm0,
                    1 => DivmR::Divm1,
                    2 => DivmR::Divm2,
                    3 => DivmR::Divm3,
                    4 => DivmR::Divm4,
                    5 => DivmR::Divm5,
                    6 => DivmR::Divm6,
                    7 => DivmR::Divm7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Divm0`" ]
            # [ inline ( always ) ]
            pub fn is_divm_0(&self) -> bool {
                *self == DivmR::Divm0
            }
            # [ doc = "Checks if the value of the field is `Divm1`" ]
            # [ inline ( always ) ]
            pub fn is_divm_1(&self) -> bool {
                *self == DivmR::Divm1
            }
            # [ doc = "Checks if the value of the field is `Divm2`" ]
            # [ inline ( always ) ]
            pub fn is_divm_2(&self) -> bool {
                *self == DivmR::Divm2
            }
            # [ doc = "Checks if the value of the field is `Divm3`" ]
            # [ inline ( always ) ]
            pub fn is_divm_3(&self) -> bool {
                *self == DivmR::Divm3
            }
            # [ doc = "Checks if the value of the field is `Divm4`" ]
            # [ inline ( always ) ]
            pub fn is_divm_4(&self) -> bool {
                *self == DivmR::Divm4
            }
            # [ doc = "Checks if the value of the field is `Divm5`" ]
            # [ inline ( always ) ]
            pub fn is_divm_5(&self) -> bool {
                *self == DivmR::Divm5
            }
            # [ doc = "Checks if the value of the field is `Divm6`" ]
            # [ inline ( always ) ]
            pub fn is_divm_6(&self) -> bool {
                *self == DivmR::Divm6
            }
            # [ doc = "Checks if the value of the field is `Divm7`" ]
            # [ inline ( always ) ]
            pub fn is_divm_7(&self) -> bool {
                *self == DivmR::Divm7
            }
        }
        # [ doc = "Possible values of the field `DIVS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DivsR {
            # [ doc = "SMCLK Source Divider 0" ]
            Divs0,
            # [ doc = "SMCLK Source Divider 1" ]
            Divs1,
            # [ doc = "SMCLK Source Divider 2" ]
            Divs2,
            # [ doc = "SMCLK Source Divider 3" ]
            Divs3,
            # [ doc = "SMCLK Source Divider 4" ]
            Divs4,
            # [ doc = "SMCLK Source Divider 5" ]
            Divs5,
            # [ doc = "SMCLK Source Divider 6" ]
            Divs6,
            # [ doc = "SMCLK Source Divider 7" ]
            Divs7,
        }
        impl DivsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DivsR::Divs0 => 0,
                    DivsR::Divs1 => 1,
                    DivsR::Divs2 => 2,
                    DivsR::Divs3 => 3,
                    DivsR::Divs4 => 4,
                    DivsR::Divs5 => 5,
                    DivsR::Divs6 => 6,
                    DivsR::Divs7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DivsR {
                match bits {
                    0 => DivsR::Divs0,
                    1 => DivsR::Divs1,
                    2 => DivsR::Divs2,
                    3 => DivsR::Divs3,
                    4 => DivsR::Divs4,
                    5 => DivsR::Divs5,
                    6 => DivsR::Divs6,
                    7 => DivsR::Divs7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Divs0`" ]
            # [ inline ( always ) ]
            pub fn is_divs_0(&self) -> bool {
                *self == DivsR::Divs0
            }
            # [ doc = "Checks if the value of the field is `Divs1`" ]
            # [ inline ( always ) ]
            pub fn is_divs_1(&self) -> bool {
                *self == DivsR::Divs1
            }
            # [ doc = "Checks if the value of the field is `Divs2`" ]
            # [ inline ( always ) ]
            pub fn is_divs_2(&self) -> bool {
                *self == DivsR::Divs2
            }
            # [ doc = "Checks if the value of the field is `Divs3`" ]
            # [ inline ( always ) ]
            pub fn is_divs_3(&self) -> bool {
                *self == DivsR::Divs3
            }
            # [ doc = "Checks if the value of the field is `Divs4`" ]
            # [ inline ( always ) ]
            pub fn is_divs_4(&self) -> bool {
                *self == DivsR::Divs4
            }
            # [ doc = "Checks if the value of the field is `Divs5`" ]
            # [ inline ( always ) ]
            pub fn is_divs_5(&self) -> bool {
                *self == DivsR::Divs5
            }
            # [ doc = "Checks if the value of the field is `Divs6`" ]
            # [ inline ( always ) ]
            pub fn is_divs_6(&self) -> bool {
                *self == DivsR::Divs6
            }
            # [ doc = "Checks if the value of the field is `Divs7`" ]
            # [ inline ( always ) ]
            pub fn is_divs_7(&self) -> bool {
                *self == DivsR::Divs7
            }
        }
        # [ doc = "Possible values of the field `DIVA`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DivaR {
            # [ doc = "ACLK Source Divider 0" ]
            Diva0,
            # [ doc = "ACLK Source Divider 1" ]
            Diva1,
            # [ doc = "ACLK Source Divider 2" ]
            Diva2,
            # [ doc = "ACLK Source Divider 3" ]
            Diva3,
            # [ doc = "ACLK Source Divider 4" ]
            Diva4,
            # [ doc = "ACLK Source Divider 5" ]
            Diva5,
            # [ doc = "ACLK Source Divider 6" ]
            Diva6,
            # [ doc = "ACLK Source Divider 7" ]
            Diva7,
        }
        impl DivaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DivaR::Diva0 => 0,
                    DivaR::Diva1 => 1,
                    DivaR::Diva2 => 2,
                    DivaR::Diva3 => 3,
                    DivaR::Diva4 => 4,
                    DivaR::Diva5 => 5,
                    DivaR::Diva6 => 6,
                    DivaR::Diva7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DivaR {
                match bits {
                    0 => DivaR::Diva0,
                    1 => DivaR::Diva1,
                    2 => DivaR::Diva2,
                    3 => DivaR::Diva3,
                    4 => DivaR::Diva4,
                    5 => DivaR::Diva5,
                    6 => DivaR::Diva6,
                    7 => DivaR::Diva7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Diva0`" ]
            # [ inline ( always ) ]
            pub fn is_diva_0(&self) -> bool {
                *self == DivaR::Diva0
            }
            # [ doc = "Checks if the value of the field is `Diva1`" ]
            # [ inline ( always ) ]
            pub fn is_diva_1(&self) -> bool {
                *self == DivaR::Diva1
            }
            # [ doc = "Checks if the value of the field is `Diva2`" ]
            # [ inline ( always ) ]
            pub fn is_diva_2(&self) -> bool {
                *self == DivaR::Diva2
            }
            # [ doc = "Checks if the value of the field is `Diva3`" ]
            # [ inline ( always ) ]
            pub fn is_diva_3(&self) -> bool {
                *self == DivaR::Diva3
            }
            # [ doc = "Checks if the value of the field is `Diva4`" ]
            # [ inline ( always ) ]
            pub fn is_diva_4(&self) -> bool {
                *self == DivaR::Diva4
            }
            # [ doc = "Checks if the value of the field is `Diva5`" ]
            # [ inline ( always ) ]
            pub fn is_diva_5(&self) -> bool {
                *self == DivaR::Diva5
            }
            # [ doc = "Checks if the value of the field is `Diva6`" ]
            # [ inline ( always ) ]
            pub fn is_diva_6(&self) -> bool {
                *self == DivaR::Diva6
            }
            # [ doc = "Checks if the value of the field is `Diva7`" ]
            # [ inline ( always ) ]
            pub fn is_diva_7(&self) -> bool {
                *self == DivaR::Diva7
            }
        }
        # [ doc = "Possible values of the field `DIVPA`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum DivpaR {
            # [ doc = "ACLK from Pin Source Divider 0" ]
            Divpa0,
            # [ doc = "ACLK from Pin Source Divider 1" ]
            Divpa1,
            # [ doc = "ACLK from Pin Source Divider 2" ]
            Divpa2,
            # [ doc = "ACLK from Pin Source Divider 3" ]
            Divpa3,
            # [ doc = "ACLK from Pin Source Divider 4" ]
            Divpa4,
            # [ doc = "ACLK from Pin Source Divider 5" ]
            Divpa5,
            # [ doc = "ACLK from Pin Source Divider 6" ]
            Divpa6,
            # [ doc = "ACLK from Pin Source Divider 7" ]
            Divpa7,
        }
        impl DivpaR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    DivpaR::Divpa0 => 0,
                    DivpaR::Divpa1 => 1,
                    DivpaR::Divpa2 => 2,
                    DivpaR::Divpa3 => 3,
                    DivpaR::Divpa4 => 4,
                    DivpaR::Divpa5 => 5,
                    DivpaR::Divpa6 => 6,
                    DivpaR::Divpa7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> DivpaR {
                match bits {
                    0 => DivpaR::Divpa0,
                    1 => DivpaR::Divpa1,
                    2 => DivpaR::Divpa2,
                    3 => DivpaR::Divpa3,
                    4 => DivpaR::Divpa4,
                    5 => DivpaR::Divpa5,
                    6 => DivpaR::Divpa6,
                    7 => DivpaR::Divpa7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Divpa0`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_0(&self) -> bool {
                *self == DivpaR::Divpa0
            }
            # [ doc = "Checks if the value of the field is `Divpa1`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_1(&self) -> bool {
                *self == DivpaR::Divpa1
            }
            # [ doc = "Checks if the value of the field is `Divpa2`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_2(&self) -> bool {
                *self == DivpaR::Divpa2
            }
            # [ doc = "Checks if the value of the field is `Divpa3`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_3(&self) -> bool {
                *self == DivpaR::Divpa3
            }
            # [ doc = "Checks if the value of the field is `Divpa4`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_4(&self) -> bool {
                *self == DivpaR::Divpa4
            }
            # [ doc = "Checks if the value of the field is `Divpa5`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_5(&self) -> bool {
                *self == DivpaR::Divpa5
            }
            # [ doc = "Checks if the value of the field is `Divpa6`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_6(&self) -> bool {
                *self == DivpaR::Divpa6
            }
            # [ doc = "Checks if the value of the field is `Divpa7`" ]
            # [ inline ( always ) ]
            pub fn is_divpa_7(&self) -> bool {
                *self == DivpaR::Divpa7
            }
        }
        # [ doc = "Values that can be written to the field `DIVM`" ]
        pub enum DivmW {
            # [ doc = "MCLK Source Divider 0" ]
            Divm0,
            # [ doc = "MCLK Source Divider 1" ]
            Divm1,
            # [ doc = "MCLK Source Divider 2" ]
            Divm2,
            # [ doc = "MCLK Source Divider 3" ]
            Divm3,
            # [ doc = "MCLK Source Divider 4" ]
            Divm4,
            # [ doc = "MCLK Source Divider 5" ]
            Divm5,
            # [ doc = "MCLK Source Divider 6" ]
            Divm6,
            # [ doc = "MCLK Source Divider 7" ]
            Divm7,
        }
        impl DivmW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DivmW::Divm0 => 0,
                    DivmW::Divm1 => 1,
                    DivmW::Divm2 => 2,
                    DivmW::Divm3 => 3,
                    DivmW::Divm4 => 4,
                    DivmW::Divm5 => 5,
                    DivmW::Divm6 => 6,
                    DivmW::Divm7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivmW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DivmW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "MCLK Source Divider 0" ]
            # [ inline ( always ) ]
            pub fn divm_0(self) -> &'a mut W {
                self.variant(DivmW::Divm0)
            }
            # [ doc = "MCLK Source Divider 1" ]
            # [ inline ( always ) ]
            pub fn divm_1(self) -> &'a mut W {
                self.variant(DivmW::Divm1)
            }
            # [ doc = "MCLK Source Divider 2" ]
            # [ inline ( always ) ]
            pub fn divm_2(self) -> &'a mut W {
                self.variant(DivmW::Divm2)
            }
            # [ doc = "MCLK Source Divider 3" ]
            # [ inline ( always ) ]
            pub fn divm_3(self) -> &'a mut W {
                self.variant(DivmW::Divm3)
            }
            # [ doc = "MCLK Source Divider 4" ]
            # [ inline ( always ) ]
            pub fn divm_4(self) -> &'a mut W {
                self.variant(DivmW::Divm4)
            }
            # [ doc = "MCLK Source Divider 5" ]
            # [ inline ( always ) ]
            pub fn divm_5(self) -> &'a mut W {
                self.variant(DivmW::Divm5)
            }
            # [ doc = "MCLK Source Divider 6" ]
            # [ inline ( always ) ]
            pub fn divm_6(self) -> &'a mut W {
                self.variant(DivmW::Divm6)
            }
            # [ doc = "MCLK Source Divider 7" ]
            # [ inline ( always ) ]
            pub fn divm_7(self) -> &'a mut W {
                self.variant(DivmW::Divm7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DIVS`" ]
        pub enum DivsW {
            # [ doc = "SMCLK Source Divider 0" ]
            Divs0,
            # [ doc = "SMCLK Source Divider 1" ]
            Divs1,
            # [ doc = "SMCLK Source Divider 2" ]
            Divs2,
            # [ doc = "SMCLK Source Divider 3" ]
            Divs3,
            # [ doc = "SMCLK Source Divider 4" ]
            Divs4,
            # [ doc = "SMCLK Source Divider 5" ]
            Divs5,
            # [ doc = "SMCLK Source Divider 6" ]
            Divs6,
            # [ doc = "SMCLK Source Divider 7" ]
            Divs7,
        }
        impl DivsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DivsW::Divs0 => 0,
                    DivsW::Divs1 => 1,
                    DivsW::Divs2 => 2,
                    DivsW::Divs3 => 3,
                    DivsW::Divs4 => 4,
                    DivsW::Divs5 => 5,
                    DivsW::Divs6 => 6,
                    DivsW::Divs7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DivsW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "SMCLK Source Divider 0" ]
            # [ inline ( always ) ]
            pub fn divs_0(self) -> &'a mut W {
                self.variant(DivsW::Divs0)
            }
            # [ doc = "SMCLK Source Divider 1" ]
            # [ inline ( always ) ]
            pub fn divs_1(self) -> &'a mut W {
                self.variant(DivsW::Divs1)
            }
            # [ doc = "SMCLK Source Divider 2" ]
            # [ inline ( always ) ]
            pub fn divs_2(self) -> &'a mut W {
                self.variant(DivsW::Divs2)
            }
            # [ doc = "SMCLK Source Divider 3" ]
            # [ inline ( always ) ]
            pub fn divs_3(self) -> &'a mut W {
                self.variant(DivsW::Divs3)
            }
            # [ doc = "SMCLK Source Divider 4" ]
            # [ inline ( always ) ]
            pub fn divs_4(self) -> &'a mut W {
                self.variant(DivsW::Divs4)
            }
            # [ doc = "SMCLK Source Divider 5" ]
            # [ inline ( always ) ]
            pub fn divs_5(self) -> &'a mut W {
                self.variant(DivsW::Divs5)
            }
            # [ doc = "SMCLK Source Divider 6" ]
            # [ inline ( always ) ]
            pub fn divs_6(self) -> &'a mut W {
                self.variant(DivsW::Divs6)
            }
            # [ doc = "SMCLK Source Divider 7" ]
            # [ inline ( always ) ]
            pub fn divs_7(self) -> &'a mut W {
                self.variant(DivsW::Divs7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DIVA`" ]
        pub enum DivaW {
            # [ doc = "ACLK Source Divider 0" ]
            Diva0,
            # [ doc = "ACLK Source Divider 1" ]
            Diva1,
            # [ doc = "ACLK Source Divider 2" ]
            Diva2,
            # [ doc = "ACLK Source Divider 3" ]
            Diva3,
            # [ doc = "ACLK Source Divider 4" ]
            Diva4,
            # [ doc = "ACLK Source Divider 5" ]
            Diva5,
            # [ doc = "ACLK Source Divider 6" ]
            Diva6,
            # [ doc = "ACLK Source Divider 7" ]
            Diva7,
        }
        impl DivaW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DivaW::Diva0 => 0,
                    DivaW::Diva1 => 1,
                    DivaW::Diva2 => 2,
                    DivaW::Diva3 => 3,
                    DivaW::Diva4 => 4,
                    DivaW::Diva5 => 5,
                    DivaW::Diva6 => 6,
                    DivaW::Diva7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivaW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DivaW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ACLK Source Divider 0" ]
            # [ inline ( always ) ]
            pub fn diva_0(self) -> &'a mut W {
                self.variant(DivaW::Diva0)
            }
            # [ doc = "ACLK Source Divider 1" ]
            # [ inline ( always ) ]
            pub fn diva_1(self) -> &'a mut W {
                self.variant(DivaW::Diva1)
            }
            # [ doc = "ACLK Source Divider 2" ]
            # [ inline ( always ) ]
            pub fn diva_2(self) -> &'a mut W {
                self.variant(DivaW::Diva2)
            }
            # [ doc = "ACLK Source Divider 3" ]
            # [ inline ( always ) ]
            pub fn diva_3(self) -> &'a mut W {
                self.variant(DivaW::Diva3)
            }
            # [ doc = "ACLK Source Divider 4" ]
            # [ inline ( always ) ]
            pub fn diva_4(self) -> &'a mut W {
                self.variant(DivaW::Diva4)
            }
            # [ doc = "ACLK Source Divider 5" ]
            # [ inline ( always ) ]
            pub fn diva_5(self) -> &'a mut W {
                self.variant(DivaW::Diva5)
            }
            # [ doc = "ACLK Source Divider 6" ]
            # [ inline ( always ) ]
            pub fn diva_6(self) -> &'a mut W {
                self.variant(DivaW::Diva6)
            }
            # [ doc = "ACLK Source Divider 7" ]
            # [ inline ( always ) ]
            pub fn diva_7(self) -> &'a mut W {
                self.variant(DivaW::Diva7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `DIVPA`" ]
        pub enum DivpaW {
            # [ doc = "ACLK from Pin Source Divider 0" ]
            Divpa0,
            # [ doc = "ACLK from Pin Source Divider 1" ]
            Divpa1,
            # [ doc = "ACLK from Pin Source Divider 2" ]
            Divpa2,
            # [ doc = "ACLK from Pin Source Divider 3" ]
            Divpa3,
            # [ doc = "ACLK from Pin Source Divider 4" ]
            Divpa4,
            # [ doc = "ACLK from Pin Source Divider 5" ]
            Divpa5,
            # [ doc = "ACLK from Pin Source Divider 6" ]
            Divpa6,
            # [ doc = "ACLK from Pin Source Divider 7" ]
            Divpa7,
        }
        impl DivpaW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DivpaW::Divpa0 => 0,
                    DivpaW::Divpa1 => 1,
                    DivpaW::Divpa2 => 2,
                    DivpaW::Divpa3 => 3,
                    DivpaW::Divpa4 => 4,
                    DivpaW::Divpa5 => 5,
                    DivpaW::Divpa6 => 6,
                    DivpaW::Divpa7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DivpaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivpaW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: DivpaW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "ACLK from Pin Source Divider 0" ]
            # [ inline ( always ) ]
            pub fn divpa_0(self) -> &'a mut W {
                self.variant(DivpaW::Divpa0)
            }
            # [ doc = "ACLK from Pin Source Divider 1" ]
            # [ inline ( always ) ]
            pub fn divpa_1(self) -> &'a mut W {
                self.variant(DivpaW::Divpa1)
            }
            # [ doc = "ACLK from Pin Source Divider 2" ]
            # [ inline ( always ) ]
            pub fn divpa_2(self) -> &'a mut W {
                self.variant(DivpaW::Divpa2)
            }
            # [ doc = "ACLK from Pin Source Divider 3" ]
            # [ inline ( always ) ]
            pub fn divpa_3(self) -> &'a mut W {
                self.variant(DivpaW::Divpa3)
            }
            # [ doc = "ACLK from Pin Source Divider 4" ]
            # [ inline ( always ) ]
            pub fn divpa_4(self) -> &'a mut W {
                self.variant(DivpaW::Divpa4)
            }
            # [ doc = "ACLK from Pin Source Divider 5" ]
            # [ inline ( always ) ]
            pub fn divpa_5(self) -> &'a mut W {
                self.variant(DivpaW::Divpa5)
            }
            # [ doc = "ACLK from Pin Source Divider 6" ]
            # [ inline ( always ) ]
            pub fn divpa_6(self) -> &'a mut W {
                self.variant(DivpaW::Divpa6)
            }
            # [ doc = "ACLK from Pin Source Divider 7" ]
            # [ inline ( always ) ]
            pub fn divpa_7(self) -> &'a mut W {
                self.variant(DivpaW::Divpa7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - MCLK Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn divm(&self) -> DivmR {
                DivmR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 2;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 6:8 - SMCLK Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn divs(&self) -> DivsR {
                DivsR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 6;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 10:12 - ACLK Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn diva(&self) -> DivaR {
                DivaR::_from({
                                 const MASK: u8 = 7;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bits 14:16 - ACLK from Pin Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn divpa(&self) -> DivpaR {
                DivpaR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 14;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - MCLK Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn divm(&mut self) -> _DivmW {
                _DivmW { w: self }
            }
            # [ doc = "Bits 6:8 - SMCLK Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn divs(&mut self) -> _DivsW {
                _DivsW { w: self }
            }
            # [ doc = "Bits 10:12 - ACLK Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn diva(&mut self) -> _DivaW {
                _DivaW { w: self }
            }
            # [ doc = "Bits 14:16 - ACLK from Pin Divider Bit: 0" ]
            # [ inline ( always ) ]
            pub fn divpa(&mut self) -> _DivpaW {
                _DivpaW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 6" ]
    pub struct Ucsctl6 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 6" ]
    pub mod ucsctl6 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl6 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Xt1offR {
            bits: u8,
        }
        impl Xt1offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmclkoffR {
            bits: u8,
        }
        impl SmclkoffR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `XCAP`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum XcapR {
            # [ doc = "XIN/XOUT Cap 0" ]
            Xcap0,
            # [ doc = "XIN/XOUT Cap 1" ]
            Xcap1,
            # [ doc = "XIN/XOUT Cap 2" ]
            Xcap2,
            # [ doc = "XIN/XOUT Cap 3" ]
            Xcap3,
        }
        impl XcapR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    XcapR::Xcap0 => 0,
                    XcapR::Xcap1 => 1,
                    XcapR::Xcap2 => 2,
                    XcapR::Xcap3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> XcapR {
                match bits {
                    0 => XcapR::Xcap0,
                    1 => XcapR::Xcap1,
                    2 => XcapR::Xcap2,
                    3 => XcapR::Xcap3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Xcap0`" ]
            # [ inline ( always ) ]
            pub fn is_xcap_0(&self) -> bool {
                *self == XcapR::Xcap0
            }
            # [ doc = "Checks if the value of the field is `Xcap1`" ]
            # [ inline ( always ) ]
            pub fn is_xcap_1(&self) -> bool {
                *self == XcapR::Xcap1
            }
            # [ doc = "Checks if the value of the field is `Xcap2`" ]
            # [ inline ( always ) ]
            pub fn is_xcap_2(&self) -> bool {
                *self == XcapR::Xcap2
            }
            # [ doc = "Checks if the value of the field is `Xcap3`" ]
            # [ inline ( always ) ]
            pub fn is_xcap_3(&self) -> bool {
                *self == XcapR::Xcap3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Xt1bypassR {
            bits: u8,
        }
        impl Xt1bypassR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct XtsR {
            bits: u8,
        }
        impl XtsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `XT1DRIVE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum Xt1driveR {
            # [ doc = "XT1 Drive Level mode: 0" ]
            Xt1drive0,
            # [ doc = "XT1 Drive Level mode: 1" ]
            Xt1drive1,
            # [ doc = "XT1 Drive Level mode: 2" ]
            Xt1drive2,
            # [ doc = "XT1 Drive Level mode: 3" ]
            Xt1drive3,
        }
        impl Xt1driveR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    Xt1driveR::Xt1drive0 => 0,
                    Xt1driveR::Xt1drive1 => 1,
                    Xt1driveR::Xt1drive2 => 2,
                    Xt1driveR::Xt1drive3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> Xt1driveR {
                match bits {
                    0 => Xt1driveR::Xt1drive0,
                    1 => Xt1driveR::Xt1drive1,
                    2 => Xt1driveR::Xt1drive2,
                    3 => Xt1driveR::Xt1drive3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Xt1drive0`" ]
            # [ inline ( always ) ]
            pub fn is_xt1drive_0(&self) -> bool {
                *self == Xt1driveR::Xt1drive0
            }
            # [ doc = "Checks if the value of the field is `Xt1drive1`" ]
            # [ inline ( always ) ]
            pub fn is_xt1drive_1(&self) -> bool {
                *self == Xt1driveR::Xt1drive1
            }
            # [ doc = "Checks if the value of the field is `Xt1drive2`" ]
            # [ inline ( always ) ]
            pub fn is_xt1drive_2(&self) -> bool {
                *self == Xt1driveR::Xt1drive2
            }
            # [ doc = "Checks if the value of the field is `Xt1drive3`" ]
            # [ inline ( always ) ]
            pub fn is_xt1drive_3(&self) -> bool {
                *self == Xt1driveR::Xt1drive3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Xt2offR {
            bits: u8,
        }
        impl Xt2offR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt1offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt1offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmclkoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmclkoffW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `XCAP`" ]
        pub enum XcapW {
            # [ doc = "XIN/XOUT Cap 0" ]
            Xcap0,
            # [ doc = "XIN/XOUT Cap 1" ]
            Xcap1,
            # [ doc = "XIN/XOUT Cap 2" ]
            Xcap2,
            # [ doc = "XIN/XOUT Cap 3" ]
            Xcap3,
        }
        impl XcapW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XcapW::Xcap0 => 0,
                    XcapW::Xcap1 => 1,
                    XcapW::Xcap2 => 2,
                    XcapW::Xcap3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _XcapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XcapW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: XcapW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "XIN/XOUT Cap 0" ]
            # [ inline ( always ) ]
            pub fn xcap_0(self) -> &'a mut W {
                self.variant(XcapW::Xcap0)
            }
            # [ doc = "XIN/XOUT Cap 1" ]
            # [ inline ( always ) ]
            pub fn xcap_1(self) -> &'a mut W {
                self.variant(XcapW::Xcap1)
            }
            # [ doc = "XIN/XOUT Cap 2" ]
            # [ inline ( always ) ]
            pub fn xcap_2(self) -> &'a mut W {
                self.variant(XcapW::Xcap2)
            }
            # [ doc = "XIN/XOUT Cap 3" ]
            # [ inline ( always ) ]
            pub fn xcap_3(self) -> &'a mut W {
                self.variant(XcapW::Xcap3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt1bypassW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt1bypassW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _XtsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XtsW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `XT1DRIVE`" ]
        pub enum Xt1driveW {
            # [ doc = "XT1 Drive Level mode: 0" ]
            Xt1drive0,
            # [ doc = "XT1 Drive Level mode: 1" ]
            Xt1drive1,
            # [ doc = "XT1 Drive Level mode: 2" ]
            Xt1drive2,
            # [ doc = "XT1 Drive Level mode: 3" ]
            Xt1drive3,
        }
        impl Xt1driveW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Xt1driveW::Xt1drive0 => 0,
                    Xt1driveW::Xt1drive1 => 1,
                    Xt1driveW::Xt1drive2 => 2,
                    Xt1driveW::Xt1drive3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt1driveW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt1driveW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: Xt1driveW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "XT1 Drive Level mode: 0" ]
            # [ inline ( always ) ]
            pub fn xt1drive_0(self) -> &'a mut W {
                self.variant(Xt1driveW::Xt1drive0)
            }
            # [ doc = "XT1 Drive Level mode: 1" ]
            # [ inline ( always ) ]
            pub fn xt1drive_1(self) -> &'a mut W {
                self.variant(Xt1driveW::Xt1drive1)
            }
            # [ doc = "XT1 Drive Level mode: 2" ]
            # [ inline ( always ) ]
            pub fn xt1drive_2(self) -> &'a mut W {
                self.variant(Xt1driveW::Xt1drive2)
            }
            # [ doc = "XT1 Drive Level mode: 3" ]
            # [ inline ( always ) ]
            pub fn xt1drive_3(self) -> &'a mut W {
                self.variant(Xt1driveW::Xt1drive3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt2offW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt2offW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - High Frequency Oscillator 1 (XT1) disable" ]
            # [ inline ( always ) ]
            pub fn xt1off(&self) -> Xt1offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Xt1offR { bits }
            }
            # [ doc = "Bit 1 - SMCLK Off" ]
            # [ inline ( always ) ]
            pub fn smclkoff(&self) -> SmclkoffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SmclkoffR { bits }
            }
            # [ doc = "Bits 3:4 - XIN/XOUT Cap Bit: 0" ]
            # [ inline ( always ) ]
            pub fn xcap(&self) -> XcapR {
                XcapR::_from({
                                 const MASK: u8 = 3;
                                 const OFFSET: u8 = 3;
                                 ((self.bits >> OFFSET) & MASK as u16) as u8
                             })
            }
            # [ doc = "Bit 4 - XT1 bypass mode : 0: internal 1:sourced from external pin" ]
            # [ inline ( always ) ]
            pub fn xt1bypass(&self) -> Xt1bypassR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Xt1bypassR { bits }
            }
            # [ doc = "Bit 5 - 1: Selects high-freq. oscillator" ]
            # [ inline ( always ) ]
            pub fn xts(&self) -> XtsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                XtsR { bits }
            }
            # [ doc = "Bits 7:8 - XT1 Drive Level mode Bit 0" ]
            # [ inline ( always ) ]
            pub fn xt1drive(&self) -> Xt1driveR {
                Xt1driveR::_from({
                                     const MASK: u8 = 3;
                                     const OFFSET: u8 = 7;
                                     ((self.bits >> OFFSET) & MASK as u16) as u8
                                 })
            }
            # [ doc = "Bit 8 - High Frequency Oscillator 2 (XT2) disable" ]
            # [ inline ( always ) ]
            pub fn xt2off(&self) -> Xt2offR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Xt2offR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - High Frequency Oscillator 1 (XT1) disable" ]
            # [ inline ( always ) ]
            pub fn xt1off(&mut self) -> _Xt1offW {
                _Xt1offW { w: self }
            }
            # [ doc = "Bit 1 - SMCLK Off" ]
            # [ inline ( always ) ]
            pub fn smclkoff(&mut self) -> _SmclkoffW {
                _SmclkoffW { w: self }
            }
            # [ doc = "Bits 3:4 - XIN/XOUT Cap Bit: 0" ]
            # [ inline ( always ) ]
            pub fn xcap(&mut self) -> _XcapW {
                _XcapW { w: self }
            }
            # [ doc = "Bit 4 - XT1 bypass mode : 0: internal 1:sourced from external pin" ]
            # [ inline ( always ) ]
            pub fn xt1bypass(&mut self) -> _Xt1bypassW {
                _Xt1bypassW { w: self }
            }
            # [ doc = "Bit 5 - 1: Selects high-freq. oscillator" ]
            # [ inline ( always ) ]
            pub fn xts(&mut self) -> _XtsW {
                _XtsW { w: self }
            }
            # [ doc = "Bits 7:8 - XT1 Drive Level mode Bit 0" ]
            # [ inline ( always ) ]
            pub fn xt1drive(&mut self) -> _Xt1driveW {
                _Xt1driveW { w: self }
            }
            # [ doc = "Bit 8 - High Frequency Oscillator 2 (XT2) disable" ]
            # [ inline ( always ) ]
            pub fn xt2off(&mut self) -> _Xt2offW {
                _Xt2offW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 7" ]
    pub struct Ucsctl7 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 7" ]
    pub mod ucsctl7 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl7 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct DcoffgR {
            bits: u8,
        }
        impl DcoffgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Xt1lfoffgR {
            bits: u8,
        }
        impl Xt1lfoffgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Xt1hfoffgR {
            bits: u8,
        }
        impl Xt1hfoffgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Xt2offgR {
            bits: u8,
        }
        impl Xt2offgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _DcoffgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DcoffgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt1lfoffgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt1lfoffgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt1hfoffgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt1hfoffgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Xt2offgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Xt2offgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - DCO Fault Flag" ]
            # [ inline ( always ) ]
            pub fn dcoffg(&self) -> DcoffgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                DcoffgR { bits }
            }
            # [ doc = "Bit 1 - XT1 Low Frequency Oscillator Fault Flag" ]
            # [ inline ( always ) ]
            pub fn xt1lfoffg(&self) -> Xt1lfoffgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Xt1lfoffgR { bits }
            }
            # [ doc = "Bit 2 - XT1 High Frequency Oscillator 1 Fault Flag" ]
            # [ inline ( always ) ]
            pub fn xt1hfoffg(&self) -> Xt1hfoffgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Xt1hfoffgR { bits }
            }
            # [ doc = "Bit 3 - High Frequency Oscillator 2 Fault Flag" ]
            # [ inline ( always ) ]
            pub fn xt2offg(&self) -> Xt2offgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Xt2offgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - DCO Fault Flag" ]
            # [ inline ( always ) ]
            pub fn dcoffg(&mut self) -> _DcoffgW {
                _DcoffgW { w: self }
            }
            # [ doc = "Bit 1 - XT1 Low Frequency Oscillator Fault Flag" ]
            # [ inline ( always ) ]
            pub fn xt1lfoffg(&mut self) -> _Xt1lfoffgW {
                _Xt1lfoffgW { w: self }
            }
            # [ doc = "Bit 2 - XT1 High Frequency Oscillator 1 Fault Flag" ]
            # [ inline ( always ) ]
            pub fn xt1hfoffg(&mut self) -> _Xt1hfoffgW {
                _Xt1hfoffgW { w: self }
            }
            # [ doc = "Bit 3 - High Frequency Oscillator 2 Fault Flag" ]
            # [ inline ( always ) ]
            pub fn xt2offg(&mut self) -> _Xt2offgW {
                _Xt2offgW { w: self }
            }
        }
    }
    # [ doc = "UCS Control Register 8" ]
    pub struct Ucsctl8 {
        register: VolatileCell<u16>,
    }
    # [ doc = "UCS Control Register 8" ]
    pub mod ucsctl8 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucsctl8 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct AclkreqenR {
            bits: u8,
        }
        impl AclkreqenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct MclkreqenR {
            bits: u8,
        }
        impl MclkreqenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct SmclkreqenR {
            bits: u8,
        }
        impl SmclkreqenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct ModoscreqenR {
            bits: u8,
        }
        impl ModoscreqenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _AclkreqenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AclkreqenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _MclkreqenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MclkreqenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _SmclkreqenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmclkreqenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _ModoscreqenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ModoscreqenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - ACLK Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn aclkreqen(&self) -> AclkreqenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                AclkreqenR { bits }
            }
            # [ doc = "Bit 1 - MCLK Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn mclkreqen(&self) -> MclkreqenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                MclkreqenR { bits }
            }
            # [ doc = "Bit 2 - SMCLK Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn smclkreqen(&self) -> SmclkreqenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                SmclkreqenR { bits }
            }
            # [ doc = "Bit 3 - MODOSC Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn modoscreqen(&self) -> ModoscreqenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                ModoscreqenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - ACLK Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn aclkreqen(&mut self) -> _AclkreqenW {
                _AclkreqenW { w: self }
            }
            # [ doc = "Bit 1 - MCLK Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn mclkreqen(&mut self) -> _MclkreqenW {
                _MclkreqenW { w: self }
            }
            # [ doc = "Bit 2 - SMCLK Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn smclkreqen(&mut self) -> _SmclkreqenW {
                _SmclkreqenW { w: self }
            }
            # [ doc = "Bit 3 - MODOSC Clock Request Enable" ]
            # [ inline ( always ) ]
            pub fn modoscreqen(&mut self) -> _ModoscreqenW {
                _ModoscreqenW { w: self }
            }
        }
    }
}
# [ doc = "UCS Unified System Clock" ]
pub struct UcsUnifiedSystemClock {
    register_block: ucs_unified_system_clock::RegisterBlock,
}
impl Deref for UcsUnifiedSystemClock {
    type Target = ucs_unified_system_clock::RegisterBlock;
    fn deref(&self) -> &ucs_unified_system_clock::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "USCI_A0 UART Mode" ]
pub const USCI_A0_UART_MODE: Peripheral<UsciA0UartMode> = unsafe { Peripheral::new(0) };
# [ doc = "USCI_A0 UART Mode" ]
pub mod usci_a0_uart_mode {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1472usize],
        # [ doc = "0x5c0 - USCI A0 Control Word Register 0" ]
        pub uca0ctlw0: Uca0ctlw0,
        _reserved1: [u8; 4usize],
        # [ doc = "0x5c6 - USCI A0 Baud Word Rate 0" ]
        pub uca0brw: Uca0brw,
        # [ doc = "0x5c8 - USCI A0 Modulation Control" ]
        pub uca0mctl: Uca0mctl,
        _reserved2: [u8; 1usize],
        # [ doc = "0x5ca - USCI A0 Status Register" ]
        pub uca0stat: Uca0stat,
        _reserved3: [u8; 1usize],
        # [ doc = "0x5cc - USCI A0 Receive Buffer" ]
        pub uca0rxbuf: Uca0rxbuf,
        _reserved4: [u8; 1usize],
        # [ doc = "0x5ce - USCI A0 Transmit Buffer" ]
        pub uca0txbuf: Uca0txbuf,
        _reserved5: [u8; 1usize],
        # [ doc = "0x5d0 - USCI A0 LIN Control" ]
        pub uca0abctl: Uca0abctl,
        _reserved6: [u8; 1usize],
        # [ doc = "0x5d2 - USCI A0 IrDA Transmit Control" ]
        pub uca0irctl: Uca0irctl,
        _reserved7: [u8; 8usize],
        # [ doc = "0x5dc - USCI A0 Interrupt Enable Register" ]
        pub uca0ictl: Uca0ictl,
        # [ doc = "0x5de - USCI A0 Interrupt Vector Register" ]
        pub uca0iv: Uca0iv,
    }
    # [ doc = "USCI A0 Control Word Register 0" ]
    pub struct Uca0ctlw0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Control Word Register 0" ]
    pub mod uca0ctlw0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0ctlw0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Control Register 0" ]
    pub struct Uca0ctl0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Control Register 0" ]
    pub mod uca0ctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsyncR {
            bits: u8,
        }
        impl UcsyncR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCMODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcmodeR {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcmodeR::Ucmode0 => 0,
                    UcmodeR::Ucmode1 => 1,
                    UcmodeR::Ucmode2 => 2,
                    UcmodeR::Ucmode3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcmodeR {
                match bits {
                    0 => UcmodeR::Ucmode0,
                    1 => UcmodeR::Ucmode1,
                    2 => UcmodeR::Ucmode2,
                    3 => UcmodeR::Ucmode3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucmode0`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UcmodeR::Ucmode0
            }
            # [ doc = "Checks if the value of the field is `Ucmode1`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UcmodeR::Ucmode1
            }
            # [ doc = "Checks if the value of the field is `Ucmode2`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UcmodeR::Ucmode2
            }
            # [ doc = "Checks if the value of the field is `Ucmode3`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UcmodeR::Ucmode3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcspbR {
            bits: u8,
        }
        impl UcspbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Uc7bitR {
            bits: u8,
        }
        impl Uc7bitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmsbR {
            bits: u8,
        }
        impl UcmsbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcparR {
            bits: u8,
        }
        impl UcparR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcpenR {
            bits: u8,
        }
        impl UcpenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsyncW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsyncW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCMODE`" ]
        pub enum UcmodeW {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcmodeW::Ucmode0 => 0,
                    UcmodeW::Ucmode1 => 1,
                    UcmodeW::Ucmode2 => 2,
                    UcmodeW::Ucmode3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmodeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcmodeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            # [ inline ( always ) ]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode0)
            }
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            # [ inline ( always ) ]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode1)
            }
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            # [ inline ( always ) ]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode2)
            }
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            # [ inline ( always ) ]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcspbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcspbW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Uc7bitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uc7bitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmsbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmsbW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcparW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcparW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcpenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcpenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&self) -> UcsyncR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsyncR { bits }
            }
            # [ doc = "Bits 2:3 - Async. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&self) -> UcmodeR {
                UcmodeR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
            # [ doc = "Bit 3 - Async. Mode: Stop Bits 0:one / 1: two" ]
            # [ inline ( always ) ]
            pub fn ucspb(&self) -> UcspbR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcspbR { bits }
            }
            # [ doc = "Bit 4 - Async. Mode: Data Bits 0:8-bits / 1:7-bits" ]
            # [ inline ( always ) ]
            pub fn uc7bit(&self) -> Uc7bitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Uc7bitR { bits }
            }
            # [ doc = "Bit 5 - Async. Mode: MSB first 0:LSB / 1:MSB" ]
            # [ inline ( always ) ]
            pub fn ucmsb(&self) -> UcmsbR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmsbR { bits }
            }
            # [ doc = "Bit 6 - Async. Mode: Parity 0:odd / 1:even" ]
            # [ inline ( always ) ]
            pub fn ucpar(&self) -> UcparR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcparR { bits }
            }
            # [ doc = "Bit 7 - Async. Mode: Parity enable" ]
            # [ inline ( always ) ]
            pub fn ucpen(&self) -> UcpenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcpenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&mut self) -> _UcsyncW {
                _UcsyncW { w: self }
            }
            # [ doc = "Bits 2:3 - Async. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&mut self) -> _UcmodeW {
                _UcmodeW { w: self }
            }
            # [ doc = "Bit 3 - Async. Mode: Stop Bits 0:one / 1: two" ]
            # [ inline ( always ) ]
            pub fn ucspb(&mut self) -> _UcspbW {
                _UcspbW { w: self }
            }
            # [ doc = "Bit 4 - Async. Mode: Data Bits 0:8-bits / 1:7-bits" ]
            # [ inline ( always ) ]
            pub fn uc7bit(&mut self) -> _Uc7bitW {
                _Uc7bitW { w: self }
            }
            # [ doc = "Bit 5 - Async. Mode: MSB first 0:LSB / 1:MSB" ]
            # [ inline ( always ) ]
            pub fn ucmsb(&mut self) -> _UcmsbW {
                _UcmsbW { w: self }
            }
            # [ doc = "Bit 6 - Async. Mode: Parity 0:odd / 1:even" ]
            # [ inline ( always ) ]
            pub fn ucpar(&mut self) -> _UcparW {
                _UcparW { w: self }
            }
            # [ doc = "Bit 7 - Async. Mode: Parity enable" ]
            # [ inline ( always ) ]
            pub fn ucpen(&mut self) -> _UcpenW {
                _UcpenW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Control Register 1" ]
    pub struct Uca0ctl1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Control Register 1" ]
    pub mod uca0ctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcswrstR {
            bits: u8,
        }
        impl UcswrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxbrkR {
            bits: u8,
        }
        impl UctxbrkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxaddrR {
            bits: u8,
        }
        impl UctxaddrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcdormR {
            bits: u8,
        }
        impl UcdormR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbrkieR {
            bits: u8,
        }
        impl UcbrkieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxeieR {
            bits: u8,
        }
        impl UcrxeieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCSSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcsselR {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcsselR::Ucssel0 => 0,
                    UcsselR::Ucssel1 => 1,
                    UcsselR::Ucssel2 => 2,
                    UcsselR::Ucssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcsselR {
                match bits {
                    0 => UcsselR::Ucssel0,
                    1 => UcsselR::Ucssel1,
                    2 => UcsselR::Ucssel2,
                    3 => UcsselR::Ucssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucssel0`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UcsselR::Ucssel0
            }
            # [ doc = "Checks if the value of the field is `Ucssel1`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UcsselR::Ucssel1
            }
            # [ doc = "Checks if the value of the field is `Ucssel2`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UcsselR::Ucssel2
            }
            # [ doc = "Checks if the value of the field is `Ucssel3`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UcsselR::Ucssel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcswrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcswrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxbrkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxbrkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxaddrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxaddrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcdormW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcdormW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbrkieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbrkieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxeieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCSSEL`" ]
        pub enum UcsselW {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcsselW::Ucssel0 => 0,
                    UcsselW::Ucssel1 => 1,
                    UcsselW::Ucssel2 => 2,
                    UcsselW::Ucssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcsselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "USCI 0 Clock Source: 0" ]
            # [ inline ( always ) ]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel0)
            }
            # [ doc = "USCI 0 Clock Source: 1" ]
            # [ inline ( always ) ]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel1)
            }
            # [ doc = "USCI 0 Clock Source: 2" ]
            # [ inline ( always ) ]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel2)
            }
            # [ doc = "USCI 0 Clock Source: 3" ]
            # [ inline ( always ) ]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&self) -> UcswrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcswrstR { bits }
            }
            # [ doc = "Bit 1 - Send next Data as Break" ]
            # [ inline ( always ) ]
            pub fn uctxbrk(&self) -> UctxbrkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxbrkR { bits }
            }
            # [ doc = "Bit 2 - Send next Data as Address" ]
            # [ inline ( always ) ]
            pub fn uctxaddr(&self) -> UctxaddrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxaddrR { bits }
            }
            # [ doc = "Bit 3 - Dormant (Sleep) Mode" ]
            # [ inline ( always ) ]
            pub fn ucdorm(&self) -> UcdormR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcdormR { bits }
            }
            # [ doc = "Bit 4 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucbrkie(&self) -> UcbrkieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbrkieR { bits }
            }
            # [ doc = "Bit 5 - RX Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucrxeie(&self) -> UcrxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxeieR { bits }
            }
            # [ doc = "Bits 7:8 - USCI 0 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&self) -> UcsselR {
                UcsselR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&mut self) -> _UcswrstW {
                _UcswrstW { w: self }
            }
            # [ doc = "Bit 1 - Send next Data as Break" ]
            # [ inline ( always ) ]
            pub fn uctxbrk(&mut self) -> _UctxbrkW {
                _UctxbrkW { w: self }
            }
            # [ doc = "Bit 2 - Send next Data as Address" ]
            # [ inline ( always ) ]
            pub fn uctxaddr(&mut self) -> _UctxaddrW {
                _UctxaddrW { w: self }
            }
            # [ doc = "Bit 3 - Dormant (Sleep) Mode" ]
            # [ inline ( always ) ]
            pub fn ucdorm(&mut self) -> _UcdormW {
                _UcdormW { w: self }
            }
            # [ doc = "Bit 4 - Break interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucbrkie(&mut self) -> _UcbrkieW {
                _UcbrkieW { w: self }
            }
            # [ doc = "Bit 5 - RX Error interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucrxeie(&mut self) -> _UcrxeieW {
                _UcrxeieW { w: self }
            }
            # [ doc = "Bits 7:8 - USCI 0 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&mut self) -> _UcsselW {
                _UcsselW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Baud Word Rate 0" ]
    pub struct Uca0brw {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Baud Word Rate 0" ]
    pub mod uca0brw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0brw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Baud Rate 0" ]
    pub struct Uca0br0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Baud Rate 0" ]
    pub mod uca0br0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0br0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Baud Rate 1" ]
    pub struct Uca0br1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Baud Rate 1" ]
    pub mod uca0br1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0br1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Modulation Control" ]
    pub struct Uca0mctl {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Modulation Control" ]
    pub mod uca0mctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0mctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucos16R {
            bits: u8,
        }
        impl Ucos16R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCBRS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcbrsR {
            # [ doc = "USCI Second Stage Modulation: 0" ]
            Ucbrs0,
            # [ doc = "USCI Second Stage Modulation: 1" ]
            Ucbrs1,
            # [ doc = "USCI Second Stage Modulation: 2" ]
            Ucbrs2,
            # [ doc = "USCI Second Stage Modulation: 3" ]
            Ucbrs3,
            # [ doc = "USCI Second Stage Modulation: 4" ]
            Ucbrs4,
            # [ doc = "USCI Second Stage Modulation: 5" ]
            Ucbrs5,
            # [ doc = "USCI Second Stage Modulation: 6" ]
            Ucbrs6,
            # [ doc = "USCI Second Stage Modulation: 7" ]
            Ucbrs7,
        }
        impl UcbrsR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcbrsR::Ucbrs0 => 0,
                    UcbrsR::Ucbrs1 => 1,
                    UcbrsR::Ucbrs2 => 2,
                    UcbrsR::Ucbrs3 => 3,
                    UcbrsR::Ucbrs4 => 4,
                    UcbrsR::Ucbrs5 => 5,
                    UcbrsR::Ucbrs6 => 6,
                    UcbrsR::Ucbrs7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcbrsR {
                match bits {
                    0 => UcbrsR::Ucbrs0,
                    1 => UcbrsR::Ucbrs1,
                    2 => UcbrsR::Ucbrs2,
                    3 => UcbrsR::Ucbrs3,
                    4 => UcbrsR::Ucbrs4,
                    5 => UcbrsR::Ucbrs5,
                    6 => UcbrsR::Ucbrs6,
                    7 => UcbrsR::Ucbrs7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucbrs0`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_0(&self) -> bool {
                *self == UcbrsR::Ucbrs0
            }
            # [ doc = "Checks if the value of the field is `Ucbrs1`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_1(&self) -> bool {
                *self == UcbrsR::Ucbrs1
            }
            # [ doc = "Checks if the value of the field is `Ucbrs2`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_2(&self) -> bool {
                *self == UcbrsR::Ucbrs2
            }
            # [ doc = "Checks if the value of the field is `Ucbrs3`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_3(&self) -> bool {
                *self == UcbrsR::Ucbrs3
            }
            # [ doc = "Checks if the value of the field is `Ucbrs4`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_4(&self) -> bool {
                *self == UcbrsR::Ucbrs4
            }
            # [ doc = "Checks if the value of the field is `Ucbrs5`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_5(&self) -> bool {
                *self == UcbrsR::Ucbrs5
            }
            # [ doc = "Checks if the value of the field is `Ucbrs6`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_6(&self) -> bool {
                *self == UcbrsR::Ucbrs6
            }
            # [ doc = "Checks if the value of the field is `Ucbrs7`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrs_7(&self) -> bool {
                *self == UcbrsR::Ucbrs7
            }
        }
        # [ doc = "Possible values of the field `UCBRF`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcbrfR {
            # [ doc = "USCI First Stage Modulation: 0" ]
            Ucbrf0,
            # [ doc = "USCI First Stage Modulation: 1" ]
            Ucbrf1,
            # [ doc = "USCI First Stage Modulation: 2" ]
            Ucbrf2,
            # [ doc = "USCI First Stage Modulation: 3" ]
            Ucbrf3,
            # [ doc = "USCI First Stage Modulation: 4" ]
            Ucbrf4,
            # [ doc = "USCI First Stage Modulation: 5" ]
            Ucbrf5,
            # [ doc = "USCI First Stage Modulation: 6" ]
            Ucbrf6,
            # [ doc = "USCI First Stage Modulation: 7" ]
            Ucbrf7,
            # [ doc = "USCI First Stage Modulation: 8" ]
            Ucbrf8,
            # [ doc = "USCI First Stage Modulation: 9" ]
            Ucbrf9,
            # [ doc = "USCI First Stage Modulation: A" ]
            Ucbrf10,
            # [ doc = "USCI First Stage Modulation: B" ]
            Ucbrf11,
            # [ doc = "USCI First Stage Modulation: C" ]
            Ucbrf12,
            # [ doc = "USCI First Stage Modulation: D" ]
            Ucbrf13,
            # [ doc = "USCI First Stage Modulation: E" ]
            Ucbrf14,
            # [ doc = "USCI First Stage Modulation: F" ]
            Ucbrf15,
        }
        impl UcbrfR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcbrfR::Ucbrf0 => 0,
                    UcbrfR::Ucbrf1 => 1,
                    UcbrfR::Ucbrf2 => 2,
                    UcbrfR::Ucbrf3 => 3,
                    UcbrfR::Ucbrf4 => 4,
                    UcbrfR::Ucbrf5 => 5,
                    UcbrfR::Ucbrf6 => 6,
                    UcbrfR::Ucbrf7 => 7,
                    UcbrfR::Ucbrf8 => 8,
                    UcbrfR::Ucbrf9 => 9,
                    UcbrfR::Ucbrf10 => 10,
                    UcbrfR::Ucbrf11 => 11,
                    UcbrfR::Ucbrf12 => 12,
                    UcbrfR::Ucbrf13 => 13,
                    UcbrfR::Ucbrf14 => 14,
                    UcbrfR::Ucbrf15 => 15,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcbrfR {
                match bits {
                    0 => UcbrfR::Ucbrf0,
                    1 => UcbrfR::Ucbrf1,
                    2 => UcbrfR::Ucbrf2,
                    3 => UcbrfR::Ucbrf3,
                    4 => UcbrfR::Ucbrf4,
                    5 => UcbrfR::Ucbrf5,
                    6 => UcbrfR::Ucbrf6,
                    7 => UcbrfR::Ucbrf7,
                    8 => UcbrfR::Ucbrf8,
                    9 => UcbrfR::Ucbrf9,
                    10 => UcbrfR::Ucbrf10,
                    11 => UcbrfR::Ucbrf11,
                    12 => UcbrfR::Ucbrf12,
                    13 => UcbrfR::Ucbrf13,
                    14 => UcbrfR::Ucbrf14,
                    15 => UcbrfR::Ucbrf15,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucbrf0`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_0(&self) -> bool {
                *self == UcbrfR::Ucbrf0
            }
            # [ doc = "Checks if the value of the field is `Ucbrf1`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_1(&self) -> bool {
                *self == UcbrfR::Ucbrf1
            }
            # [ doc = "Checks if the value of the field is `Ucbrf2`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_2(&self) -> bool {
                *self == UcbrfR::Ucbrf2
            }
            # [ doc = "Checks if the value of the field is `Ucbrf3`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_3(&self) -> bool {
                *self == UcbrfR::Ucbrf3
            }
            # [ doc = "Checks if the value of the field is `Ucbrf4`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_4(&self) -> bool {
                *self == UcbrfR::Ucbrf4
            }
            # [ doc = "Checks if the value of the field is `Ucbrf5`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_5(&self) -> bool {
                *self == UcbrfR::Ucbrf5
            }
            # [ doc = "Checks if the value of the field is `Ucbrf6`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_6(&self) -> bool {
                *self == UcbrfR::Ucbrf6
            }
            # [ doc = "Checks if the value of the field is `Ucbrf7`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_7(&self) -> bool {
                *self == UcbrfR::Ucbrf7
            }
            # [ doc = "Checks if the value of the field is `Ucbrf8`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_8(&self) -> bool {
                *self == UcbrfR::Ucbrf8
            }
            # [ doc = "Checks if the value of the field is `Ucbrf9`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_9(&self) -> bool {
                *self == UcbrfR::Ucbrf9
            }
            # [ doc = "Checks if the value of the field is `Ucbrf10`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_10(&self) -> bool {
                *self == UcbrfR::Ucbrf10
            }
            # [ doc = "Checks if the value of the field is `Ucbrf11`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_11(&self) -> bool {
                *self == UcbrfR::Ucbrf11
            }
            # [ doc = "Checks if the value of the field is `Ucbrf12`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_12(&self) -> bool {
                *self == UcbrfR::Ucbrf12
            }
            # [ doc = "Checks if the value of the field is `Ucbrf13`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_13(&self) -> bool {
                *self == UcbrfR::Ucbrf13
            }
            # [ doc = "Checks if the value of the field is `Ucbrf14`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_14(&self) -> bool {
                *self == UcbrfR::Ucbrf14
            }
            # [ doc = "Checks if the value of the field is `Ucbrf15`" ]
            # [ inline ( always ) ]
            pub fn is_ucbrf_15(&self) -> bool {
                *self == UcbrfR::Ucbrf15
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucos16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucos16W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCBRS`" ]
        pub enum UcbrsW {
            # [ doc = "USCI Second Stage Modulation: 0" ]
            Ucbrs0,
            # [ doc = "USCI Second Stage Modulation: 1" ]
            Ucbrs1,
            # [ doc = "USCI Second Stage Modulation: 2" ]
            Ucbrs2,
            # [ doc = "USCI Second Stage Modulation: 3" ]
            Ucbrs3,
            # [ doc = "USCI Second Stage Modulation: 4" ]
            Ucbrs4,
            # [ doc = "USCI Second Stage Modulation: 5" ]
            Ucbrs5,
            # [ doc = "USCI Second Stage Modulation: 6" ]
            Ucbrs6,
            # [ doc = "USCI Second Stage Modulation: 7" ]
            Ucbrs7,
        }
        impl UcbrsW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcbrsW::Ucbrs0 => 0,
                    UcbrsW::Ucbrs1 => 1,
                    UcbrsW::Ucbrs2 => 2,
                    UcbrsW::Ucbrs3 => 3,
                    UcbrsW::Ucbrs4 => 4,
                    UcbrsW::Ucbrs5 => 5,
                    UcbrsW::Ucbrs6 => 6,
                    UcbrsW::Ucbrs7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbrsW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcbrsW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "USCI Second Stage Modulation: 0" ]
            # [ inline ( always ) ]
            pub fn ucbrs_0(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs0)
            }
            # [ doc = "USCI Second Stage Modulation: 1" ]
            # [ inline ( always ) ]
            pub fn ucbrs_1(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs1)
            }
            # [ doc = "USCI Second Stage Modulation: 2" ]
            # [ inline ( always ) ]
            pub fn ucbrs_2(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs2)
            }
            # [ doc = "USCI Second Stage Modulation: 3" ]
            # [ inline ( always ) ]
            pub fn ucbrs_3(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs3)
            }
            # [ doc = "USCI Second Stage Modulation: 4" ]
            # [ inline ( always ) ]
            pub fn ucbrs_4(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs4)
            }
            # [ doc = "USCI Second Stage Modulation: 5" ]
            # [ inline ( always ) ]
            pub fn ucbrs_5(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs5)
            }
            # [ doc = "USCI Second Stage Modulation: 6" ]
            # [ inline ( always ) ]
            pub fn ucbrs_6(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs6)
            }
            # [ doc = "USCI Second Stage Modulation: 7" ]
            # [ inline ( always ) ]
            pub fn ucbrs_7(self) -> &'a mut W {
                self.variant(UcbrsW::Ucbrs7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCBRF`" ]
        pub enum UcbrfW {
            # [ doc = "USCI First Stage Modulation: 0" ]
            Ucbrf0,
            # [ doc = "USCI First Stage Modulation: 1" ]
            Ucbrf1,
            # [ doc = "USCI First Stage Modulation: 2" ]
            Ucbrf2,
            # [ doc = "USCI First Stage Modulation: 3" ]
            Ucbrf3,
            # [ doc = "USCI First Stage Modulation: 4" ]
            Ucbrf4,
            # [ doc = "USCI First Stage Modulation: 5" ]
            Ucbrf5,
            # [ doc = "USCI First Stage Modulation: 6" ]
            Ucbrf6,
            # [ doc = "USCI First Stage Modulation: 7" ]
            Ucbrf7,
            # [ doc = "USCI First Stage Modulation: 8" ]
            Ucbrf8,
            # [ doc = "USCI First Stage Modulation: 9" ]
            Ucbrf9,
            # [ doc = "USCI First Stage Modulation: A" ]
            Ucbrf10,
            # [ doc = "USCI First Stage Modulation: B" ]
            Ucbrf11,
            # [ doc = "USCI First Stage Modulation: C" ]
            Ucbrf12,
            # [ doc = "USCI First Stage Modulation: D" ]
            Ucbrf13,
            # [ doc = "USCI First Stage Modulation: E" ]
            Ucbrf14,
            # [ doc = "USCI First Stage Modulation: F" ]
            Ucbrf15,
        }
        impl UcbrfW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcbrfW::Ucbrf0 => 0,
                    UcbrfW::Ucbrf1 => 1,
                    UcbrfW::Ucbrf2 => 2,
                    UcbrfW::Ucbrf3 => 3,
                    UcbrfW::Ucbrf4 => 4,
                    UcbrfW::Ucbrf5 => 5,
                    UcbrfW::Ucbrf6 => 6,
                    UcbrfW::Ucbrf7 => 7,
                    UcbrfW::Ucbrf8 => 8,
                    UcbrfW::Ucbrf9 => 9,
                    UcbrfW::Ucbrf10 => 10,
                    UcbrfW::Ucbrf11 => 11,
                    UcbrfW::Ucbrf12 => 12,
                    UcbrfW::Ucbrf13 => 13,
                    UcbrfW::Ucbrf14 => 14,
                    UcbrfW::Ucbrf15 => 15,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbrfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbrfW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcbrfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "USCI First Stage Modulation: 0" ]
            # [ inline ( always ) ]
            pub fn ucbrf_0(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf0)
            }
            # [ doc = "USCI First Stage Modulation: 1" ]
            # [ inline ( always ) ]
            pub fn ucbrf_1(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf1)
            }
            # [ doc = "USCI First Stage Modulation: 2" ]
            # [ inline ( always ) ]
            pub fn ucbrf_2(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf2)
            }
            # [ doc = "USCI First Stage Modulation: 3" ]
            # [ inline ( always ) ]
            pub fn ucbrf_3(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf3)
            }
            # [ doc = "USCI First Stage Modulation: 4" ]
            # [ inline ( always ) ]
            pub fn ucbrf_4(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf4)
            }
            # [ doc = "USCI First Stage Modulation: 5" ]
            # [ inline ( always ) ]
            pub fn ucbrf_5(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf5)
            }
            # [ doc = "USCI First Stage Modulation: 6" ]
            # [ inline ( always ) ]
            pub fn ucbrf_6(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf6)
            }
            # [ doc = "USCI First Stage Modulation: 7" ]
            # [ inline ( always ) ]
            pub fn ucbrf_7(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf7)
            }
            # [ doc = "USCI First Stage Modulation: 8" ]
            # [ inline ( always ) ]
            pub fn ucbrf_8(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf8)
            }
            # [ doc = "USCI First Stage Modulation: 9" ]
            # [ inline ( always ) ]
            pub fn ucbrf_9(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf9)
            }
            # [ doc = "USCI First Stage Modulation: A" ]
            # [ inline ( always ) ]
            pub fn ucbrf_10(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf10)
            }
            # [ doc = "USCI First Stage Modulation: B" ]
            # [ inline ( always ) ]
            pub fn ucbrf_11(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf11)
            }
            # [ doc = "USCI First Stage Modulation: C" ]
            # [ inline ( always ) ]
            pub fn ucbrf_12(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf12)
            }
            # [ doc = "USCI First Stage Modulation: D" ]
            # [ inline ( always ) ]
            pub fn ucbrf_13(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf13)
            }
            # [ doc = "USCI First Stage Modulation: E" ]
            # [ inline ( always ) ]
            pub fn ucbrf_14(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf14)
            }
            # [ doc = "USCI First Stage Modulation: F" ]
            # [ inline ( always ) ]
            pub fn ucbrf_15(self) -> &'a mut W {
                self.variant(UcbrfW::Ucbrf15)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI 16-times Oversampling enable" ]
            # [ inline ( always ) ]
            pub fn ucos16(&self) -> Ucos16R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucos16R { bits }
            }
            # [ doc = "Bits 3:5 - USCI Second Stage Modulation Select 2" ]
            # [ inline ( always ) ]
            pub fn ucbrs(&self) -> UcbrsR {
                UcbrsR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 3;
                                  ((self.bits >> OFFSET) & MASK as u8) as u8
                              })
            }
            # [ doc = "Bits 7:10 - USCI First Stage Modulation Select 3" ]
            # [ inline ( always ) ]
            pub fn ucbrf(&self) -> UcbrfR {
                UcbrfR::_from({
                                  const MASK: u8 = 15;
                                  const OFFSET: u8 = 7;
                                  ((self.bits >> OFFSET) & MASK as u8) as u8
                              })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI 16-times Oversampling enable" ]
            # [ inline ( always ) ]
            pub fn ucos16(&mut self) -> _Ucos16W {
                _Ucos16W { w: self }
            }
            # [ doc = "Bits 3:5 - USCI Second Stage Modulation Select 2" ]
            # [ inline ( always ) ]
            pub fn ucbrs(&mut self) -> _UcbrsW {
                _UcbrsW { w: self }
            }
            # [ doc = "Bits 7:10 - USCI First Stage Modulation Select 3" ]
            # [ inline ( always ) ]
            pub fn ucbrf(&mut self) -> _UcbrfW {
                _UcbrfW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Status Register" ]
    pub struct Uca0stat {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Status Register" ]
    pub mod uca0stat {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0stat {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbusyR {
            bits: u8,
        }
        impl UcbusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcaddrR {
            bits: u8,
        }
        impl UcaddrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxerrR {
            bits: u8,
        }
        impl UcrxerrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbrkR {
            bits: u8,
        }
        impl UcbrkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcpeR {
            bits: u8,
        }
        impl UcpeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcoeR {
            bits: u8,
        }
        impl UcoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcfeR {
            bits: u8,
        }
        impl UcfeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UclistenR {
            bits: u8,
        }
        impl UclistenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcaddrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcaddrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxerrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbrkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbrkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcpeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcfeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcfeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UclistenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UclistenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbusy(&self) -> UcbusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbusyR { bits }
            }
            # [ doc = "Bit 1 - USCI Address received Flag" ]
            # [ inline ( always ) ]
            pub fn ucaddr(&self) -> UcaddrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcaddrR { bits }
            }
            # [ doc = "Bit 2 - USCI RX Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxerr(&self) -> UcrxerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxerrR { bits }
            }
            # [ doc = "Bit 3 - USCI Break received" ]
            # [ inline ( always ) ]
            pub fn ucbrk(&self) -> UcbrkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbrkR { bits }
            }
            # [ doc = "Bit 4 - USCI Parity Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucpe(&self) -> UcpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcpeR { bits }
            }
            # [ doc = "Bit 5 - USCI Overrun Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucoe(&self) -> UcoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcoeR { bits }
            }
            # [ doc = "Bit 6 - USCI Frame Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucfe(&self) -> UcfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcfeR { bits }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&self) -> UclistenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UclistenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbusy(&mut self) -> _UcbusyW {
                _UcbusyW { w: self }
            }
            # [ doc = "Bit 1 - USCI Address received Flag" ]
            # [ inline ( always ) ]
            pub fn ucaddr(&mut self) -> _UcaddrW {
                _UcaddrW { w: self }
            }
            # [ doc = "Bit 2 - USCI RX Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxerr(&mut self) -> _UcrxerrW {
                _UcrxerrW { w: self }
            }
            # [ doc = "Bit 3 - USCI Break received" ]
            # [ inline ( always ) ]
            pub fn ucbrk(&mut self) -> _UcbrkW {
                _UcbrkW { w: self }
            }
            # [ doc = "Bit 4 - USCI Parity Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucpe(&mut self) -> _UcpeW {
                _UcpeW { w: self }
            }
            # [ doc = "Bit 5 - USCI Overrun Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucoe(&mut self) -> _UcoeW {
                _UcoeW { w: self }
            }
            # [ doc = "Bit 6 - USCI Frame Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucfe(&mut self) -> _UcfeW {
                _UcfeW { w: self }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&mut self) -> _UclistenW {
                _UclistenW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Receive Buffer" ]
    pub struct Uca0rxbuf {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Receive Buffer" ]
    pub mod uca0rxbuf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0rxbuf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Transmit Buffer" ]
    pub struct Uca0txbuf {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Transmit Buffer" ]
    pub mod uca0txbuf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0txbuf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 LIN Control" ]
    pub struct Uca0abctl {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 LIN Control" ]
    pub mod uca0abctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0abctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcabdenR {
            bits: u8,
        }
        impl UcabdenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbtoeR {
            bits: u8,
        }
        impl UcbtoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcstoeR {
            bits: u8,
        }
        impl UcstoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucdelim0R {
            bits: u8,
        }
        impl Ucdelim0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucdelim1R {
            bits: u8,
        }
        impl Ucdelim1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcabdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcabdenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbtoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbtoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcstoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcstoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucdelim0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucdelim0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucdelim1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucdelim1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Auto Baud Rate detect enable" ]
            # [ inline ( always ) ]
            pub fn ucabden(&self) -> UcabdenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcabdenR { bits }
            }
            # [ doc = "Bit 2 - Break Timeout error" ]
            # [ inline ( always ) ]
            pub fn ucbtoe(&self) -> UcbtoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbtoeR { bits }
            }
            # [ doc = "Bit 3 - Sync-Field Timeout error" ]
            # [ inline ( always ) ]
            pub fn ucstoe(&self) -> UcstoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcstoeR { bits }
            }
            # [ doc = "Bit 4 - Break Sync Delimiter 0" ]
            # [ inline ( always ) ]
            pub fn ucdelim0(&self) -> Ucdelim0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucdelim0R { bits }
            }
            # [ doc = "Bit 5 - Break Sync Delimiter 1" ]
            # [ inline ( always ) ]
            pub fn ucdelim1(&self) -> Ucdelim1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucdelim1R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Auto Baud Rate detect enable" ]
            # [ inline ( always ) ]
            pub fn ucabden(&mut self) -> _UcabdenW {
                _UcabdenW { w: self }
            }
            # [ doc = "Bit 2 - Break Timeout error" ]
            # [ inline ( always ) ]
            pub fn ucbtoe(&mut self) -> _UcbtoeW {
                _UcbtoeW { w: self }
            }
            # [ doc = "Bit 3 - Sync-Field Timeout error" ]
            # [ inline ( always ) ]
            pub fn ucstoe(&mut self) -> _UcstoeW {
                _UcstoeW { w: self }
            }
            # [ doc = "Bit 4 - Break Sync Delimiter 0" ]
            # [ inline ( always ) ]
            pub fn ucdelim0(&mut self) -> _Ucdelim0W {
                _Ucdelim0W { w: self }
            }
            # [ doc = "Bit 5 - Break Sync Delimiter 1" ]
            # [ inline ( always ) ]
            pub fn ucdelim1(&mut self) -> _Ucdelim1W {
                _Ucdelim1W { w: self }
            }
        }
    }
    # [ doc = "USCI A0 IrDA Transmit Control" ]
    pub struct Uca0irctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 IrDA Transmit Control" ]
    pub mod uca0irctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0irctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 IrDA Transmit Control" ]
    pub struct Uca0irtctl {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 IrDA Transmit Control" ]
    pub mod uca0irtctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0irtctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcirenR {
            bits: u8,
        }
        impl UcirenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcirtxclkR {
            bits: u8,
        }
        impl UcirtxclkR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirtxpl0R {
            bits: u8,
        }
        impl Ucirtxpl0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirtxpl1R {
            bits: u8,
        }
        impl Ucirtxpl1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirtxpl2R {
            bits: u8,
        }
        impl Ucirtxpl2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirtxpl3R {
            bits: u8,
        }
        impl Ucirtxpl3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirtxpl4R {
            bits: u8,
        }
        impl Ucirtxpl4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirtxpl5R {
            bits: u8,
        }
        impl Ucirtxpl5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcirenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcirenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcirtxclkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcirtxclkW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirtxpl0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirtxpl0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirtxpl1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirtxpl1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirtxpl2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirtxpl2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirtxpl3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirtxpl3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirtxpl4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirtxpl4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirtxpl5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirtxpl5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - IRDA Encoder/Decoder enable" ]
            # [ inline ( always ) ]
            pub fn uciren(&self) -> UcirenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcirenR { bits }
            }
            # [ doc = "Bit 1 - IRDA Transmit Pulse Clock Select" ]
            # [ inline ( always ) ]
            pub fn ucirtxclk(&self) -> UcirtxclkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcirtxclkR { bits }
            }
            # [ doc = "Bit 2 - IRDA Transmit Pulse Length 0" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl0(&self) -> Ucirtxpl0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirtxpl0R { bits }
            }
            # [ doc = "Bit 3 - IRDA Transmit Pulse Length 1" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl1(&self) -> Ucirtxpl1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirtxpl1R { bits }
            }
            # [ doc = "Bit 4 - IRDA Transmit Pulse Length 2" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl2(&self) -> Ucirtxpl2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirtxpl2R { bits }
            }
            # [ doc = "Bit 5 - IRDA Transmit Pulse Length 3" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl3(&self) -> Ucirtxpl3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirtxpl3R { bits }
            }
            # [ doc = "Bit 6 - IRDA Transmit Pulse Length 4" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl4(&self) -> Ucirtxpl4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirtxpl4R { bits }
            }
            # [ doc = "Bit 7 - IRDA Transmit Pulse Length 5" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl5(&self) -> Ucirtxpl5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirtxpl5R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - IRDA Encoder/Decoder enable" ]
            # [ inline ( always ) ]
            pub fn uciren(&mut self) -> _UcirenW {
                _UcirenW { w: self }
            }
            # [ doc = "Bit 1 - IRDA Transmit Pulse Clock Select" ]
            # [ inline ( always ) ]
            pub fn ucirtxclk(&mut self) -> _UcirtxclkW {
                _UcirtxclkW { w: self }
            }
            # [ doc = "Bit 2 - IRDA Transmit Pulse Length 0" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl0(&mut self) -> _Ucirtxpl0W {
                _Ucirtxpl0W { w: self }
            }
            # [ doc = "Bit 3 - IRDA Transmit Pulse Length 1" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl1(&mut self) -> _Ucirtxpl1W {
                _Ucirtxpl1W { w: self }
            }
            # [ doc = "Bit 4 - IRDA Transmit Pulse Length 2" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl2(&mut self) -> _Ucirtxpl2W {
                _Ucirtxpl2W { w: self }
            }
            # [ doc = "Bit 5 - IRDA Transmit Pulse Length 3" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl3(&mut self) -> _Ucirtxpl3W {
                _Ucirtxpl3W { w: self }
            }
            # [ doc = "Bit 6 - IRDA Transmit Pulse Length 4" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl4(&mut self) -> _Ucirtxpl4W {
                _Ucirtxpl4W { w: self }
            }
            # [ doc = "Bit 7 - IRDA Transmit Pulse Length 5" ]
            # [ inline ( always ) ]
            pub fn ucirtxpl5(&mut self) -> _Ucirtxpl5W {
                _Ucirtxpl5W { w: self }
            }
        }
    }
    # [ doc = "USCI A0 IrDA Receive Control" ]
    pub struct Uca0irrctl {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 IrDA Receive Control" ]
    pub mod uca0irrctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0irrctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcirrxfeR {
            bits: u8,
        }
        impl UcirrxfeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcirrxplR {
            bits: u8,
        }
        impl UcirrxplR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirrxfl0R {
            bits: u8,
        }
        impl Ucirrxfl0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirrxfl1R {
            bits: u8,
        }
        impl Ucirrxfl1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirrxfl2R {
            bits: u8,
        }
        impl Ucirrxfl2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirrxfl3R {
            bits: u8,
        }
        impl Ucirrxfl3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirrxfl4R {
            bits: u8,
        }
        impl Ucirrxfl4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucirrxfl5R {
            bits: u8,
        }
        impl Ucirrxfl5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcirrxfeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcirrxfeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcirrxplW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcirrxplW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirrxfl0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirrxfl0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirrxfl1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirrxfl1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirrxfl2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirrxfl2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirrxfl3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirrxfl3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirrxfl4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirrxfl4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucirrxfl5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucirrxfl5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - IRDA Receive Filter enable" ]
            # [ inline ( always ) ]
            pub fn ucirrxfe(&self) -> UcirrxfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcirrxfeR { bits }
            }
            # [ doc = "Bit 1 - IRDA Receive Input Polarity" ]
            # [ inline ( always ) ]
            pub fn ucirrxpl(&self) -> UcirrxplR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcirrxplR { bits }
            }
            # [ doc = "Bit 2 - IRDA Receive Filter Length 0" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl0(&self) -> Ucirrxfl0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirrxfl0R { bits }
            }
            # [ doc = "Bit 3 - IRDA Receive Filter Length 1" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl1(&self) -> Ucirrxfl1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirrxfl1R { bits }
            }
            # [ doc = "Bit 4 - IRDA Receive Filter Length 2" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl2(&self) -> Ucirrxfl2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirrxfl2R { bits }
            }
            # [ doc = "Bit 5 - IRDA Receive Filter Length 3" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl3(&self) -> Ucirrxfl3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirrxfl3R { bits }
            }
            # [ doc = "Bit 6 - IRDA Receive Filter Length 4" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl4(&self) -> Ucirrxfl4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirrxfl4R { bits }
            }
            # [ doc = "Bit 7 - IRDA Receive Filter Length 5" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl5(&self) -> Ucirrxfl5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucirrxfl5R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - IRDA Receive Filter enable" ]
            # [ inline ( always ) ]
            pub fn ucirrxfe(&mut self) -> _UcirrxfeW {
                _UcirrxfeW { w: self }
            }
            # [ doc = "Bit 1 - IRDA Receive Input Polarity" ]
            # [ inline ( always ) ]
            pub fn ucirrxpl(&mut self) -> _UcirrxplW {
                _UcirrxplW { w: self }
            }
            # [ doc = "Bit 2 - IRDA Receive Filter Length 0" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl0(&mut self) -> _Ucirrxfl0W {
                _Ucirrxfl0W { w: self }
            }
            # [ doc = "Bit 3 - IRDA Receive Filter Length 1" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl1(&mut self) -> _Ucirrxfl1W {
                _Ucirrxfl1W { w: self }
            }
            # [ doc = "Bit 4 - IRDA Receive Filter Length 2" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl2(&mut self) -> _Ucirrxfl2W {
                _Ucirrxfl2W { w: self }
            }
            # [ doc = "Bit 5 - IRDA Receive Filter Length 3" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl3(&mut self) -> _Ucirrxfl3W {
                _Ucirrxfl3W { w: self }
            }
            # [ doc = "Bit 6 - IRDA Receive Filter Length 4" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl4(&mut self) -> _Ucirrxfl4W {
                _Ucirrxfl4W { w: self }
            }
            # [ doc = "Bit 7 - IRDA Receive Filter Length 5" ]
            # [ inline ( always ) ]
            pub fn ucirrxfl5(&mut self) -> _Ucirrxfl5W {
                _Ucirrxfl5W { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub struct Uca0ictl {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub mod uca0ictl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0ictl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub struct Uca0ie {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub mod uca0ie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxieR {
            bits: u8,
        }
        impl UcrxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxieR {
            bits: u8,
        }
        impl UctxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&self) -> UcrxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxieR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&self) -> UctxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&mut self) -> _UcrxieW {
                _UcrxieW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&mut self) -> _UctxieW {
                _UctxieW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Flags Register" ]
    pub struct Uca0ifg {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Interrupt Flags Register" ]
    pub mod uca0ifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxifgR {
            bits: u8,
        }
        impl UcrxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxifgR {
            bits: u8,
        }
        impl UctxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&self) -> UcrxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxifgR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&self) -> UctxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&mut self) -> _UcrxifgW {
                _UcrxifgW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&mut self) -> _UctxifgW {
                _UctxifgW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Vector Register" ]
    pub struct Uca0iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Interrupt Vector Register" ]
    pub mod uca0iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "USCI_A0 UART Mode" ]
pub struct UsciA0UartMode {
    register_block: usci_a0_uart_mode::RegisterBlock,
}
impl Deref for UsciA0UartMode {
    type Target = usci_a0_uart_mode::RegisterBlock;
    fn deref(&self) -> &usci_a0_uart_mode::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "USCI_A0 SPI Mode" ]
pub const USCI_A0_SPI_MODE: Peripheral<UsciA0SpiMode> = unsafe { Peripheral::new(0) };
# [ doc = "USCI_A0 SPI Mode" ]
pub mod usci_a0_spi_mode {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1472usize],
        # [ doc = "0x5c0 - USCI A0 Control Word Register 0" ]
        pub uca0ctlw0_spi: Uca0ctlw0Spi,
        _reserved1: [u8; 4usize],
        # [ doc = "0x5c6 - USCI A0 Baud Word Rate 0" ]
        pub uca0brw_spi: Uca0brwSpi,
        # [ doc = "0x5c8 - USCI A0 Modulation Control" ]
        pub uca0mctl_spi: Uca0mctlSpi,
        _reserved2: [u8; 1usize],
        # [ doc = "0x5ca - USCI A0 Status Register" ]
        pub uca0stat_spi: Uca0statSpi,
        _reserved3: [u8; 1usize],
        # [ doc = "0x5cc - USCI A0 Receive Buffer" ]
        pub uca0rxbuf_spi: Uca0rxbufSpi,
        _reserved4: [u8; 1usize],
        # [ doc = "0x5ce - USCI A0 Transmit Buffer" ]
        pub uca0txbuf_spi: Uca0txbufSpi,
        _reserved5: [u8; 13usize],
        # [ doc = "0x5dc - USCI A0 Interrupt Enable Register" ]
        pub uca0ictl_spi: Uca0ictlSpi,
        # [ doc = "0x5de - USCI A0 Interrupt Vector Register" ]
        pub uca0iv_spi: Uca0ivSpi,
    }
    # [ doc = "USCI A0 Control Word Register 0" ]
    pub struct Uca0ctlw0Spi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Control Word Register 0" ]
    pub mod uca0ctlw0_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0ctlw0Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Control Register 0" ]
    pub struct Uca0ctl0Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Control Register 0" ]
    pub mod uca0ctl0_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ctl0Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsyncR {
            bits: u8,
        }
        impl UcsyncR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCMODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcmodeR {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcmodeR::Ucmode0 => 0,
                    UcmodeR::Ucmode1 => 1,
                    UcmodeR::Ucmode2 => 2,
                    UcmodeR::Ucmode3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcmodeR {
                match bits {
                    0 => UcmodeR::Ucmode0,
                    1 => UcmodeR::Ucmode1,
                    2 => UcmodeR::Ucmode2,
                    3 => UcmodeR::Ucmode3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucmode0`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UcmodeR::Ucmode0
            }
            # [ doc = "Checks if the value of the field is `Ucmode1`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UcmodeR::Ucmode1
            }
            # [ doc = "Checks if the value of the field is `Ucmode2`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UcmodeR::Ucmode2
            }
            # [ doc = "Checks if the value of the field is `Ucmode3`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UcmodeR::Ucmode3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmstR {
            bits: u8,
        }
        impl UcmstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Uc7bitR {
            bits: u8,
        }
        impl Uc7bitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmsbR {
            bits: u8,
        }
        impl UcmsbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcckplR {
            bits: u8,
        }
        impl UcckplR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcckphR {
            bits: u8,
        }
        impl UcckphR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsyncW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsyncW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCMODE`" ]
        pub enum UcmodeW {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcmodeW::Ucmode0 => 0,
                    UcmodeW::Ucmode1 => 1,
                    UcmodeW::Ucmode2 => 2,
                    UcmodeW::Ucmode3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmodeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcmodeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            # [ inline ( always ) ]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode0)
            }
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            # [ inline ( always ) ]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode1)
            }
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            # [ inline ( always ) ]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode2)
            }
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            # [ inline ( always ) ]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Uc7bitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uc7bitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmsbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmsbW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcckplW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcckplW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcckphW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcckphW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&self) -> UcsyncR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsyncR { bits }
            }
            # [ doc = "Bits 2:3 - Sync. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&self) -> UcmodeR {
                UcmodeR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
            # [ doc = "Bit 3 - Sync. Mode: Master Select" ]
            # [ inline ( always ) ]
            pub fn ucmst(&self) -> UcmstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmstR { bits }
            }
            # [ doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits" ]
            # [ inline ( always ) ]
            pub fn uc7bit(&self) -> Uc7bitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Uc7bitR { bits }
            }
            # [ doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB" ]
            # [ inline ( always ) ]
            pub fn ucmsb(&self) -> UcmsbR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmsbR { bits }
            }
            # [ doc = "Bit 6 - Sync. Mode: Clock Polarity" ]
            # [ inline ( always ) ]
            pub fn ucckpl(&self) -> UcckplR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcckplR { bits }
            }
            # [ doc = "Bit 7 - Sync. Mode: Clock Phase" ]
            # [ inline ( always ) ]
            pub fn ucckph(&self) -> UcckphR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcckphR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&mut self) -> _UcsyncW {
                _UcsyncW { w: self }
            }
            # [ doc = "Bits 2:3 - Sync. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&mut self) -> _UcmodeW {
                _UcmodeW { w: self }
            }
            # [ doc = "Bit 3 - Sync. Mode: Master Select" ]
            # [ inline ( always ) ]
            pub fn ucmst(&mut self) -> _UcmstW {
                _UcmstW { w: self }
            }
            # [ doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits" ]
            # [ inline ( always ) ]
            pub fn uc7bit(&mut self) -> _Uc7bitW {
                _Uc7bitW { w: self }
            }
            # [ doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB" ]
            # [ inline ( always ) ]
            pub fn ucmsb(&mut self) -> _UcmsbW {
                _UcmsbW { w: self }
            }
            # [ doc = "Bit 6 - Sync. Mode: Clock Polarity" ]
            # [ inline ( always ) ]
            pub fn ucckpl(&mut self) -> _UcckplW {
                _UcckplW { w: self }
            }
            # [ doc = "Bit 7 - Sync. Mode: Clock Phase" ]
            # [ inline ( always ) ]
            pub fn ucckph(&mut self) -> _UcckphW {
                _UcckphW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Control Register 1" ]
    pub struct Uca0ctl1Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Control Register 1" ]
    pub mod uca0ctl1_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ctl1Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcswrstR {
            bits: u8,
        }
        impl UcswrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCSSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcsselR {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcsselR::Ucssel0 => 0,
                    UcsselR::Ucssel1 => 1,
                    UcsselR::Ucssel2 => 2,
                    UcsselR::Ucssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcsselR {
                match bits {
                    0 => UcsselR::Ucssel0,
                    1 => UcsselR::Ucssel1,
                    2 => UcsselR::Ucssel2,
                    3 => UcsselR::Ucssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucssel0`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UcsselR::Ucssel0
            }
            # [ doc = "Checks if the value of the field is `Ucssel1`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UcsselR::Ucssel1
            }
            # [ doc = "Checks if the value of the field is `Ucssel2`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UcsselR::Ucssel2
            }
            # [ doc = "Checks if the value of the field is `Ucssel3`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UcsselR::Ucssel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcswrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcswrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCSSEL`" ]
        pub enum UcsselW {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcsselW::Ucssel0 => 0,
                    UcsselW::Ucssel1 => 1,
                    UcsselW::Ucssel2 => 2,
                    UcsselW::Ucssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcsselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "USCI 0 Clock Source: 0" ]
            # [ inline ( always ) ]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel0)
            }
            # [ doc = "USCI 0 Clock Source: 1" ]
            # [ inline ( always ) ]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel1)
            }
            # [ doc = "USCI 0 Clock Source: 2" ]
            # [ inline ( always ) ]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel2)
            }
            # [ doc = "USCI 0 Clock Source: 3" ]
            # [ inline ( always ) ]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&self) -> UcswrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcswrstR { bits }
            }
            # [ doc = "Bits 7:8 - USCI 1 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&self) -> UcsselR {
                UcsselR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&mut self) -> _UcswrstW {
                _UcswrstW { w: self }
            }
            # [ doc = "Bits 7:8 - USCI 1 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&mut self) -> _UcsselW {
                _UcsselW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Baud Word Rate 0" ]
    pub struct Uca0brwSpi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Baud Word Rate 0" ]
    pub mod uca0brw_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0brwSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Baud Rate 0" ]
    pub struct Uca0br0Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Baud Rate 0" ]
    pub mod uca0br0_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0br0Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Baud Rate 1" ]
    pub struct Uca0br1Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Baud Rate 1" ]
    pub mod uca0br1_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0br1Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Modulation Control" ]
    pub struct Uca0mctlSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Modulation Control" ]
    pub mod uca0mctl_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0mctlSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Status Register" ]
    pub struct Uca0statSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Status Register" ]
    pub mod uca0stat_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0statSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbusyR {
            bits: u8,
        }
        impl UcbusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcoeR {
            bits: u8,
        }
        impl UcoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcfeR {
            bits: u8,
        }
        impl UcfeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UclistenR {
            bits: u8,
        }
        impl UclistenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcfeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcfeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UclistenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UclistenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbusy(&self) -> UcbusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbusyR { bits }
            }
            # [ doc = "Bit 5 - USCI Overrun Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucoe(&self) -> UcoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcoeR { bits }
            }
            # [ doc = "Bit 6 - USCI Frame Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucfe(&self) -> UcfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcfeR { bits }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&self) -> UclistenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UclistenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbusy(&mut self) -> _UcbusyW {
                _UcbusyW { w: self }
            }
            # [ doc = "Bit 5 - USCI Overrun Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucoe(&mut self) -> _UcoeW {
                _UcoeW { w: self }
            }
            # [ doc = "Bit 6 - USCI Frame Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucfe(&mut self) -> _UcfeW {
                _UcfeW { w: self }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&mut self) -> _UclistenW {
                _UclistenW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Receive Buffer" ]
    pub struct Uca0rxbufSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Receive Buffer" ]
    pub mod uca0rxbuf_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0rxbufSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Transmit Buffer" ]
    pub struct Uca0txbufSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Transmit Buffer" ]
    pub mod uca0txbuf_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0txbufSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub struct Uca0ictlSpi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub mod uca0ictl_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0ictlSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub struct Uca0ieSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Interrupt Enable Register" ]
    pub mod uca0ie_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ieSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxieR {
            bits: u8,
        }
        impl UcrxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxieR {
            bits: u8,
        }
        impl UctxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsttieR {
            bits: u8,
        }
        impl UcsttieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcstpieR {
            bits: u8,
        }
        impl UcstpieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcalieR {
            bits: u8,
        }
        impl UcalieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcnackieR {
            bits: u8,
        }
        impl UcnackieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsttieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsttieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcstpieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcstpieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcalieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcalieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcnackieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcnackieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&self) -> UcrxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxieR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&self) -> UctxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxieR { bits }
            }
            # [ doc = "Bit 2 - START Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucsttie(&self) -> UcsttieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsttieR { bits }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucstpie(&self) -> UcstpieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcstpieR { bits }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucalie(&self) -> UcalieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcalieR { bits }
            }
            # [ doc = "Bit 5 - NACK Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucnackie(&self) -> UcnackieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcnackieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&mut self) -> _UcrxieW {
                _UcrxieW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&mut self) -> _UctxieW {
                _UctxieW { w: self }
            }
            # [ doc = "Bit 2 - START Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucsttie(&mut self) -> _UcsttieW {
                _UcsttieW { w: self }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucstpie(&mut self) -> _UcstpieW {
                _UcstpieW { w: self }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucalie(&mut self) -> _UcalieW {
                _UcalieW { w: self }
            }
            # [ doc = "Bit 5 - NACK Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucnackie(&mut self) -> _UcnackieW {
                _UcnackieW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Flags Register" ]
    pub struct Uca0ifgSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI A0 Interrupt Flags Register" ]
    pub mod uca0ifg_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Uca0ifgSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxifgR {
            bits: u8,
        }
        impl UcrxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxifgR {
            bits: u8,
        }
        impl UctxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&self) -> UcrxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxifgR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&self) -> UctxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&mut self) -> _UcrxifgW {
                _UcrxifgW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&mut self) -> _UctxifgW {
                _UctxifgW { w: self }
            }
        }
    }
    # [ doc = "USCI A0 Interrupt Vector Register" ]
    pub struct Uca0ivSpi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI A0 Interrupt Vector Register" ]
    pub mod uca0iv_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Uca0ivSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "USCI_A0 SPI Mode" ]
pub struct UsciA0SpiMode {
    register_block: usci_a0_spi_mode::RegisterBlock,
}
impl Deref for UsciA0SpiMode {
    type Target = usci_a0_spi_mode::RegisterBlock;
    fn deref(&self) -> &usci_a0_spi_mode::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "USCI_B0 SPI Mode" ]
pub const USCI_B0_SPI_MODE: Peripheral<UsciB0SpiMode> = unsafe { Peripheral::new(0) };
# [ doc = "USCI_B0 SPI Mode" ]
pub mod usci_b0_spi_mode {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1504usize],
        # [ doc = "0x5e0 - USCI B0 Control Word Register 0" ]
        pub ucb0ctlw0_spi: Ucb0ctlw0Spi,
        _reserved1: [u8; 4usize],
        # [ doc = "0x5e6 - USCI B0 Baud Word Rate 0" ]
        pub ucb0brw_spi: Ucb0brwSpi,
        _reserved2: [u8; 2usize],
        # [ doc = "0x5ea - USCI B0 Status Register" ]
        pub ucb0stat_spi: Ucb0statSpi,
        _reserved3: [u8; 1usize],
        # [ doc = "0x5ec - USCI B0 Receive Buffer" ]
        pub ucb0rxbuf_spi: Ucb0rxbufSpi,
        _reserved4: [u8; 1usize],
        # [ doc = "0x5ee - USCI B0 Transmit Buffer" ]
        pub ucb0txbuf_spi: Ucb0txbufSpi,
        _reserved5: [u8; 13usize],
        # [ doc = "0x5fc - USCI B0 Interrupt Enable Register" ]
        pub ucb0ictl_spi: Ucb0ictlSpi,
        # [ doc = "0x5fe - USCI B0 Interrupt Vector Register" ]
        pub ucb0iv_spi: Ucb0ivSpi,
    }
    # [ doc = "USCI B0 Control Word Register 0" ]
    pub struct Ucb0ctlw0Spi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Control Word Register 0" ]
    pub mod ucb0ctlw0_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0ctlw0Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Control Register 0" ]
    pub struct Ucb0ctl0Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Control Register 0" ]
    pub mod ucb0ctl0_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ctl0Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsyncR {
            bits: u8,
        }
        impl UcsyncR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCMODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcmodeR {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcmodeR::Ucmode0 => 0,
                    UcmodeR::Ucmode1 => 1,
                    UcmodeR::Ucmode2 => 2,
                    UcmodeR::Ucmode3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcmodeR {
                match bits {
                    0 => UcmodeR::Ucmode0,
                    1 => UcmodeR::Ucmode1,
                    2 => UcmodeR::Ucmode2,
                    3 => UcmodeR::Ucmode3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucmode0`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UcmodeR::Ucmode0
            }
            # [ doc = "Checks if the value of the field is `Ucmode1`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UcmodeR::Ucmode1
            }
            # [ doc = "Checks if the value of the field is `Ucmode2`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UcmodeR::Ucmode2
            }
            # [ doc = "Checks if the value of the field is `Ucmode3`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UcmodeR::Ucmode3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmstR {
            bits: u8,
        }
        impl UcmstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Uc7bitR {
            bits: u8,
        }
        impl Uc7bitR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmsbR {
            bits: u8,
        }
        impl UcmsbR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcckplR {
            bits: u8,
        }
        impl UcckplR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcckphR {
            bits: u8,
        }
        impl UcckphR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsyncW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsyncW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCMODE`" ]
        pub enum UcmodeW {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcmodeW::Ucmode0 => 0,
                    UcmodeW::Ucmode1 => 1,
                    UcmodeW::Ucmode2 => 2,
                    UcmodeW::Ucmode3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmodeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcmodeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            # [ inline ( always ) ]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode0)
            }
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            # [ inline ( always ) ]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode1)
            }
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            # [ inline ( always ) ]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode2)
            }
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            # [ inline ( always ) ]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Uc7bitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uc7bitW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmsbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmsbW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcckplW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcckplW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcckphW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcckphW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&self) -> UcsyncR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsyncR { bits }
            }
            # [ doc = "Bits 2:3 - Sync. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&self) -> UcmodeR {
                UcmodeR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
            # [ doc = "Bit 3 - Sync. Mode: Master Select" ]
            # [ inline ( always ) ]
            pub fn ucmst(&self) -> UcmstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmstR { bits }
            }
            # [ doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits" ]
            # [ inline ( always ) ]
            pub fn uc7bit(&self) -> Uc7bitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Uc7bitR { bits }
            }
            # [ doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB" ]
            # [ inline ( always ) ]
            pub fn ucmsb(&self) -> UcmsbR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmsbR { bits }
            }
            # [ doc = "Bit 6 - Sync. Mode: Clock Polarity" ]
            # [ inline ( always ) ]
            pub fn ucckpl(&self) -> UcckplR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcckplR { bits }
            }
            # [ doc = "Bit 7 - Sync. Mode: Clock Phase" ]
            # [ inline ( always ) ]
            pub fn ucckph(&self) -> UcckphR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcckphR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&mut self) -> _UcsyncW {
                _UcsyncW { w: self }
            }
            # [ doc = "Bits 2:3 - Sync. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&mut self) -> _UcmodeW {
                _UcmodeW { w: self }
            }
            # [ doc = "Bit 3 - Sync. Mode: Master Select" ]
            # [ inline ( always ) ]
            pub fn ucmst(&mut self) -> _UcmstW {
                _UcmstW { w: self }
            }
            # [ doc = "Bit 4 - Sync. Mode: Data Bits 0:8-bits / 1:7-bits" ]
            # [ inline ( always ) ]
            pub fn uc7bit(&mut self) -> _Uc7bitW {
                _Uc7bitW { w: self }
            }
            # [ doc = "Bit 5 - Sync. Mode: MSB first 0:LSB / 1:MSB" ]
            # [ inline ( always ) ]
            pub fn ucmsb(&mut self) -> _UcmsbW {
                _UcmsbW { w: self }
            }
            # [ doc = "Bit 6 - Sync. Mode: Clock Polarity" ]
            # [ inline ( always ) ]
            pub fn ucckpl(&mut self) -> _UcckplW {
                _UcckplW { w: self }
            }
            # [ doc = "Bit 7 - Sync. Mode: Clock Phase" ]
            # [ inline ( always ) ]
            pub fn ucckph(&mut self) -> _UcckphW {
                _UcckphW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Control Register 1" ]
    pub struct Ucb0ctl1Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Control Register 1" ]
    pub mod ucb0ctl1_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ctl1Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcswrstR {
            bits: u8,
        }
        impl UcswrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCSSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcsselR {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcsselR::Ucssel0 => 0,
                    UcsselR::Ucssel1 => 1,
                    UcsselR::Ucssel2 => 2,
                    UcsselR::Ucssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcsselR {
                match bits {
                    0 => UcsselR::Ucssel0,
                    1 => UcsselR::Ucssel1,
                    2 => UcsselR::Ucssel2,
                    3 => UcsselR::Ucssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucssel0`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UcsselR::Ucssel0
            }
            # [ doc = "Checks if the value of the field is `Ucssel1`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UcsselR::Ucssel1
            }
            # [ doc = "Checks if the value of the field is `Ucssel2`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UcsselR::Ucssel2
            }
            # [ doc = "Checks if the value of the field is `Ucssel3`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UcsselR::Ucssel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcswrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcswrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCSSEL`" ]
        pub enum UcsselW {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcsselW::Ucssel0 => 0,
                    UcsselW::Ucssel1 => 1,
                    UcsselW::Ucssel2 => 2,
                    UcsselW::Ucssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcsselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "USCI 0 Clock Source: 0" ]
            # [ inline ( always ) ]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel0)
            }
            # [ doc = "USCI 0 Clock Source: 1" ]
            # [ inline ( always ) ]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel1)
            }
            # [ doc = "USCI 0 Clock Source: 2" ]
            # [ inline ( always ) ]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel2)
            }
            # [ doc = "USCI 0 Clock Source: 3" ]
            # [ inline ( always ) ]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&self) -> UcswrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcswrstR { bits }
            }
            # [ doc = "Bits 7:8 - USCI 1 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&self) -> UcsselR {
                UcsselR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&mut self) -> _UcswrstW {
                _UcswrstW { w: self }
            }
            # [ doc = "Bits 7:8 - USCI 1 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&mut self) -> _UcsselW {
                _UcsselW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Baud Word Rate 0" ]
    pub struct Ucb0brwSpi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Baud Word Rate 0" ]
    pub mod ucb0brw_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0brwSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Baud Rate 0" ]
    pub struct Ucb0br0Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Baud Rate 0" ]
    pub mod ucb0br0_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0br0Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Baud Rate 1" ]
    pub struct Ucb0br1Spi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Baud Rate 1" ]
    pub mod ucb0br1_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0br1Spi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Status Register" ]
    pub struct Ucb0statSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Status Register" ]
    pub mod ucb0stat_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0statSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbusyR {
            bits: u8,
        }
        impl UcbusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcoeR {
            bits: u8,
        }
        impl UcoeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcfeR {
            bits: u8,
        }
        impl UcfeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UclistenR {
            bits: u8,
        }
        impl UclistenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcoeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcfeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcfeW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UclistenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UclistenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbusy(&self) -> UcbusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbusyR { bits }
            }
            # [ doc = "Bit 5 - USCI Overrun Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucoe(&self) -> UcoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcoeR { bits }
            }
            # [ doc = "Bit 6 - USCI Frame Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucfe(&self) -> UcfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcfeR { bits }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&self) -> UclistenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UclistenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbusy(&mut self) -> _UcbusyW {
                _UcbusyW { w: self }
            }
            # [ doc = "Bit 5 - USCI Overrun Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucoe(&mut self) -> _UcoeW {
                _UcoeW { w: self }
            }
            # [ doc = "Bit 6 - USCI Frame Error Flag" ]
            # [ inline ( always ) ]
            pub fn ucfe(&mut self) -> _UcfeW {
                _UcfeW { w: self }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&mut self) -> _UclistenW {
                _UclistenW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Receive Buffer" ]
    pub struct Ucb0rxbufSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Receive Buffer" ]
    pub mod ucb0rxbuf_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0rxbufSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Transmit Buffer" ]
    pub struct Ucb0txbufSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Transmit Buffer" ]
    pub mod ucb0txbuf_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0txbufSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub struct Ucb0ictlSpi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub mod ucb0ictl_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0ictlSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub struct Ucb0ieSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub mod ucb0ie_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ieSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxieR {
            bits: u8,
        }
        impl UcrxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxieR {
            bits: u8,
        }
        impl UctxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsttieR {
            bits: u8,
        }
        impl UcsttieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcstpieR {
            bits: u8,
        }
        impl UcstpieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcalieR {
            bits: u8,
        }
        impl UcalieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcnackieR {
            bits: u8,
        }
        impl UcnackieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsttieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsttieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcstpieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcstpieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcalieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcalieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcnackieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcnackieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&self) -> UcrxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxieR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&self) -> UctxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxieR { bits }
            }
            # [ doc = "Bit 2 - START Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucsttie(&self) -> UcsttieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsttieR { bits }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucstpie(&self) -> UcstpieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcstpieR { bits }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucalie(&self) -> UcalieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcalieR { bits }
            }
            # [ doc = "Bit 5 - NACK Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucnackie(&self) -> UcnackieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcnackieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&mut self) -> _UcrxieW {
                _UcrxieW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&mut self) -> _UctxieW {
                _UctxieW { w: self }
            }
            # [ doc = "Bit 2 - START Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucsttie(&mut self) -> _UcsttieW {
                _UcsttieW { w: self }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucstpie(&mut self) -> _UcstpieW {
                _UcstpieW { w: self }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucalie(&mut self) -> _UcalieW {
                _UcalieW { w: self }
            }
            # [ doc = "Bit 5 - NACK Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucnackie(&mut self) -> _UcnackieW {
                _UcnackieW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Flags Register" ]
    pub struct Ucb0ifgSpi {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Interrupt Flags Register" ]
    pub mod ucb0ifg_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ifgSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxifgR {
            bits: u8,
        }
        impl UcrxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxifgR {
            bits: u8,
        }
        impl UctxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&self) -> UcrxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxifgR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&self) -> UctxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&mut self) -> _UcrxifgW {
                _UcrxifgW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&mut self) -> _UctxifgW {
                _UctxifgW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Vector Register" ]
    pub struct Ucb0ivSpi {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Interrupt Vector Register" ]
    pub mod ucb0iv_spi {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0ivSpi {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "USCI_B0 SPI Mode" ]
pub struct UsciB0SpiMode {
    register_block: usci_b0_spi_mode::RegisterBlock,
}
impl Deref for UsciB0SpiMode {
    type Target = usci_b0_spi_mode::RegisterBlock;
    fn deref(&self) -> &usci_b0_spi_mode::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "USCI_B0 I2C Mode" ]
pub const USCI_B0_I2C_MODE: Peripheral<UsciB0I2cMode> = unsafe { Peripheral::new(0) };
# [ doc = "USCI_B0 I2C Mode" ]
pub mod usci_b0_i2c_mode {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 1504usize],
        # [ doc = "0x5e0 - USCI B0 Control Word Register 0" ]
        pub ucb0ctlw0: Ucb0ctlw0,
        _reserved1: [u8; 4usize],
        # [ doc = "0x5e6 - USCI B0 Baud Word Rate 0" ]
        pub ucb0brw: Ucb0brw,
        _reserved2: [u8; 2usize],
        # [ doc = "0x5ea - USCI B0 Status Register" ]
        pub ucb0stat: Ucb0stat,
        _reserved3: [u8; 1usize],
        # [ doc = "0x5ec - USCI B0 Receive Buffer" ]
        pub ucb0rxbuf: Ucb0rxbuf,
        _reserved4: [u8; 1usize],
        # [ doc = "0x5ee - USCI B0 Transmit Buffer" ]
        pub ucb0txbuf: Ucb0txbuf,
        _reserved5: [u8; 1usize],
        # [ doc = "0x5f0 - USCI B0 I2C Own Address" ]
        pub ucb0i2coa: Ucb0i2coa,
        # [ doc = "0x5f2 - USCI B0 I2C Slave Address" ]
        pub ucb0i2csa: Ucb0i2csa,
        _reserved6: [u8; 8usize],
        # [ doc = "0x5fc - USCI B0 Interrupt Enable Register" ]
        pub ucb0ictl: Ucb0ictl,
        # [ doc = "0x5fe - USCI B0 Interrupt Vector Register" ]
        pub ucb0iv: Ucb0iv,
    }
    # [ doc = "USCI B0 Control Word Register 0" ]
    pub struct Ucb0ctlw0 {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Control Word Register 0" ]
    pub mod ucb0ctlw0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0ctlw0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Control Register 0" ]
    pub struct Ucb0ctl0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Control Register 0" ]
    pub mod ucb0ctl0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ctl0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsyncR {
            bits: u8,
        }
        impl UcsyncR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCMODE`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcmodeR {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcmodeR::Ucmode0 => 0,
                    UcmodeR::Ucmode1 => 1,
                    UcmodeR::Ucmode2 => 2,
                    UcmodeR::Ucmode3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcmodeR {
                match bits {
                    0 => UcmodeR::Ucmode0,
                    1 => UcmodeR::Ucmode1,
                    2 => UcmodeR::Ucmode2,
                    3 => UcmodeR::Ucmode3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucmode0`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_0(&self) -> bool {
                *self == UcmodeR::Ucmode0
            }
            # [ doc = "Checks if the value of the field is `Ucmode1`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_1(&self) -> bool {
                *self == UcmodeR::Ucmode1
            }
            # [ doc = "Checks if the value of the field is `Ucmode2`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_2(&self) -> bool {
                *self == UcmodeR::Ucmode2
            }
            # [ doc = "Checks if the value of the field is `Ucmode3`" ]
            # [ inline ( always ) ]
            pub fn is_ucmode_3(&self) -> bool {
                *self == UcmodeR::Ucmode3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmstR {
            bits: u8,
        }
        impl UcmstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcmmR {
            bits: u8,
        }
        impl UcmmR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsla10R {
            bits: u8,
        }
        impl Ucsla10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Uca10R {
            bits: u8,
        }
        impl Uca10R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsyncW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsyncW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCMODE`" ]
        pub enum UcmodeW {
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            Ucmode0,
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            Ucmode1,
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            Ucmode2,
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            Ucmode3,
        }
        impl UcmodeW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcmodeW::Ucmode0 => 0,
                    UcmodeW::Ucmode1 => 1,
                    UcmodeW::Ucmode2 => 2,
                    UcmodeW::Ucmode3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmodeW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcmodeW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "Sync. Mode: USCI Mode: 0" ]
            # [ inline ( always ) ]
            pub fn ucmode_0(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode0)
            }
            # [ doc = "Sync. Mode: USCI Mode: 1" ]
            # [ inline ( always ) ]
            pub fn ucmode_1(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode1)
            }
            # [ doc = "Sync. Mode: USCI Mode: 2" ]
            # [ inline ( always ) ]
            pub fn ucmode_2(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode2)
            }
            # [ doc = "Sync. Mode: USCI Mode: 3" ]
            # [ inline ( always ) ]
            pub fn ucmode_3(self) -> &'a mut W {
                self.variant(UcmodeW::Ucmode3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcmmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcmmW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsla10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsla10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Uca10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Uca10W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&self) -> UcsyncR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsyncR { bits }
            }
            # [ doc = "Bits 2:3 - Sync. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&self) -> UcmodeR {
                UcmodeR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
            # [ doc = "Bit 3 - Sync. Mode: Master Select" ]
            # [ inline ( always ) ]
            pub fn ucmst(&self) -> UcmstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmstR { bits }
            }
            # [ doc = "Bit 5 - Multi-Master Environment" ]
            # [ inline ( always ) ]
            pub fn ucmm(&self) -> UcmmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcmmR { bits }
            }
            # [ doc = "Bit 6 - 10-bit Slave Address Mode" ]
            # [ inline ( always ) ]
            pub fn ucsla10(&self) -> Ucsla10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Ucsla10R { bits }
            }
            # [ doc = "Bit 7 - 10-bit Address Mode" ]
            # [ inline ( always ) ]
            pub fn uca10(&self) -> Uca10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                Uca10R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - Sync-Mode 0:UART-Mode / 1:SPI-Mode" ]
            # [ inline ( always ) ]
            pub fn ucsync(&mut self) -> _UcsyncW {
                _UcsyncW { w: self }
            }
            # [ doc = "Bits 2:3 - Sync. Mode: USCI Mode 1" ]
            # [ inline ( always ) ]
            pub fn ucmode(&mut self) -> _UcmodeW {
                _UcmodeW { w: self }
            }
            # [ doc = "Bit 3 - Sync. Mode: Master Select" ]
            # [ inline ( always ) ]
            pub fn ucmst(&mut self) -> _UcmstW {
                _UcmstW { w: self }
            }
            # [ doc = "Bit 5 - Multi-Master Environment" ]
            # [ inline ( always ) ]
            pub fn ucmm(&mut self) -> _UcmmW {
                _UcmmW { w: self }
            }
            # [ doc = "Bit 6 - 10-bit Slave Address Mode" ]
            # [ inline ( always ) ]
            pub fn ucsla10(&mut self) -> _Ucsla10W {
                _Ucsla10W { w: self }
            }
            # [ doc = "Bit 7 - 10-bit Address Mode" ]
            # [ inline ( always ) ]
            pub fn uca10(&mut self) -> _Uca10W {
                _Uca10W { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Control Register 1" ]
    pub struct Ucb0ctl1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Control Register 1" ]
    pub mod ucb0ctl1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ctl1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcswrstR {
            bits: u8,
        }
        impl UcswrstR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxsttR {
            bits: u8,
        }
        impl UctxsttR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxstpR {
            bits: u8,
        }
        impl UctxstpR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxnackR {
            bits: u8,
        }
        impl UctxnackR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctrR {
            bits: u8,
        }
        impl UctrR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `UCSSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum UcsselR {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    UcsselR::Ucssel0 => 0,
                    UcsselR::Ucssel1 => 1,
                    UcsselR::Ucssel2 => 2,
                    UcsselR::Ucssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> UcsselR {
                match bits {
                    0 => UcsselR::Ucssel0,
                    1 => UcsselR::Ucssel1,
                    2 => UcsselR::Ucssel2,
                    3 => UcsselR::Ucssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Ucssel0`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_0(&self) -> bool {
                *self == UcsselR::Ucssel0
            }
            # [ doc = "Checks if the value of the field is `Ucssel1`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_1(&self) -> bool {
                *self == UcsselR::Ucssel1
            }
            # [ doc = "Checks if the value of the field is `Ucssel2`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_2(&self) -> bool {
                *self == UcsselR::Ucssel2
            }
            # [ doc = "Checks if the value of the field is `Ucssel3`" ]
            # [ inline ( always ) ]
            pub fn is_ucssel_3(&self) -> bool {
                *self == UcsselR::Ucssel3
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcswrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcswrstW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxsttW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxsttW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxstpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxstpW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxnackW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxnackW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctrW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `UCSSEL`" ]
        pub enum UcsselW {
            # [ doc = "USCI 0 Clock Source: 0" ]
            Ucssel0,
            # [ doc = "USCI 0 Clock Source: 1" ]
            Ucssel1,
            # [ doc = "USCI 0 Clock Source: 2" ]
            Ucssel2,
            # [ doc = "USCI 0 Clock Source: 3" ]
            Ucssel3,
        }
        impl UcsselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    UcsselW::Ucssel0 => 0,
                    UcsselW::Ucssel1 => 1,
                    UcsselW::Ucssel2 => 2,
                    UcsselW::Ucssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: UcsselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "USCI 0 Clock Source: 0" ]
            # [ inline ( always ) ]
            pub fn ucssel_0(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel0)
            }
            # [ doc = "USCI 0 Clock Source: 1" ]
            # [ inline ( always ) ]
            pub fn ucssel_1(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel1)
            }
            # [ doc = "USCI 0 Clock Source: 2" ]
            # [ inline ( always ) ]
            pub fn ucssel_2(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel2)
            }
            # [ doc = "USCI 0 Clock Source: 3" ]
            # [ inline ( always ) ]
            pub fn ucssel_3(self) -> &'a mut W {
                self.variant(UcsselW::Ucssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&self) -> UcswrstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcswrstR { bits }
            }
            # [ doc = "Bit 1 - Transmit START" ]
            # [ inline ( always ) ]
            pub fn uctxstt(&self) -> UctxsttR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxsttR { bits }
            }
            # [ doc = "Bit 2 - Transmit STOP" ]
            # [ inline ( always ) ]
            pub fn uctxstp(&self) -> UctxstpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxstpR { bits }
            }
            # [ doc = "Bit 3 - Transmit NACK" ]
            # [ inline ( always ) ]
            pub fn uctxnack(&self) -> UctxnackR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxnackR { bits }
            }
            # [ doc = "Bit 4 - Transmit/Receive Select/Flag" ]
            # [ inline ( always ) ]
            pub fn uctr(&self) -> UctrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctrR { bits }
            }
            # [ doc = "Bits 7:8 - USCI 1 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&self) -> UcsselR {
                UcsselR::_from({
                                   const MASK: u8 = 3;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u8) as u8
                               })
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Software Reset" ]
            # [ inline ( always ) ]
            pub fn ucswrst(&mut self) -> _UcswrstW {
                _UcswrstW { w: self }
            }
            # [ doc = "Bit 1 - Transmit START" ]
            # [ inline ( always ) ]
            pub fn uctxstt(&mut self) -> _UctxsttW {
                _UctxsttW { w: self }
            }
            # [ doc = "Bit 2 - Transmit STOP" ]
            # [ inline ( always ) ]
            pub fn uctxstp(&mut self) -> _UctxstpW {
                _UctxstpW { w: self }
            }
            # [ doc = "Bit 3 - Transmit NACK" ]
            # [ inline ( always ) ]
            pub fn uctxnack(&mut self) -> _UctxnackW {
                _UctxnackW { w: self }
            }
            # [ doc = "Bit 4 - Transmit/Receive Select/Flag" ]
            # [ inline ( always ) ]
            pub fn uctr(&mut self) -> _UctrW {
                _UctrW { w: self }
            }
            # [ doc = "Bits 7:8 - USCI 1 Clock Source Select 1" ]
            # [ inline ( always ) ]
            pub fn ucssel(&mut self) -> _UcsselW {
                _UcsselW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Baud Word Rate 0" ]
    pub struct Ucb0brw {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Baud Word Rate 0" ]
    pub mod ucb0brw {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0brw {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Baud Rate 0" ]
    pub struct Ucb0br0 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Baud Rate 0" ]
    pub mod ucb0br0 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0br0 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Baud Rate 1" ]
    pub struct Ucb0br1 {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Baud Rate 1" ]
    pub mod ucb0br1 {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0br1 {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Status Register" ]
    pub struct Ucb0stat {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Status Register" ]
    pub mod ucb0stat {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0stat {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcbbusyR {
            bits: u8,
        }
        impl UcbbusyR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcgcR {
            bits: u8,
        }
        impl UcgcR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcscllowR {
            bits: u8,
        }
        impl UcscllowR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UclistenR {
            bits: u8,
        }
        impl UclistenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcbbusyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcbbusyW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcgcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcgcW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcscllowW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcscllowW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UclistenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UclistenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 4 - Bus Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbbusy(&self) -> UcbbusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcbbusyR { bits }
            }
            # [ doc = "Bit 5 - General Call address received Flag" ]
            # [ inline ( always ) ]
            pub fn ucgc(&self) -> UcgcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcgcR { bits }
            }
            # [ doc = "Bit 6 - SCL low" ]
            # [ inline ( always ) ]
            pub fn ucscllow(&self) -> UcscllowR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcscllowR { bits }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&self) -> UclistenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UclistenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 4 - Bus Busy Flag" ]
            # [ inline ( always ) ]
            pub fn ucbbusy(&mut self) -> _UcbbusyW {
                _UcbbusyW { w: self }
            }
            # [ doc = "Bit 5 - General Call address received Flag" ]
            # [ inline ( always ) ]
            pub fn ucgc(&mut self) -> _UcgcW {
                _UcgcW { w: self }
            }
            # [ doc = "Bit 6 - SCL low" ]
            # [ inline ( always ) ]
            pub fn ucscllow(&mut self) -> _UcscllowW {
                _UcscllowW { w: self }
            }
            # [ doc = "Bit 7 - USCI Listen mode" ]
            # [ inline ( always ) ]
            pub fn uclisten(&mut self) -> _UclistenW {
                _UclistenW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Receive Buffer" ]
    pub struct Ucb0rxbuf {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Receive Buffer" ]
    pub mod ucb0rxbuf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0rxbuf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Transmit Buffer" ]
    pub struct Ucb0txbuf {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Transmit Buffer" ]
    pub mod ucb0txbuf {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0txbuf {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 I2C Own Address" ]
    pub struct Ucb0i2coa {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 I2C Own Address" ]
    pub mod ucb0i2coa {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0i2coa {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa0R {
            bits: u8,
        }
        impl Ucoa0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa1R {
            bits: u8,
        }
        impl Ucoa1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa2R {
            bits: u8,
        }
        impl Ucoa2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa3R {
            bits: u8,
        }
        impl Ucoa3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa4R {
            bits: u8,
        }
        impl Ucoa4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa5R {
            bits: u8,
        }
        impl Ucoa5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa6R {
            bits: u8,
        }
        impl Ucoa6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa7R {
            bits: u8,
        }
        impl Ucoa7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa8R {
            bits: u8,
        }
        impl Ucoa8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucoa9R {
            bits: u8,
        }
        impl Ucoa9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcgcenR {
            bits: u8,
        }
        impl UcgcenR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucoa9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucoa9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcgcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcgcenW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - I2C Own Address 0" ]
            # [ inline ( always ) ]
            pub fn ucoa0(&self) -> Ucoa0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa0R { bits }
            }
            # [ doc = "Bit 1 - I2C Own Address 1" ]
            # [ inline ( always ) ]
            pub fn ucoa1(&self) -> Ucoa1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa1R { bits }
            }
            # [ doc = "Bit 2 - I2C Own Address 2" ]
            # [ inline ( always ) ]
            pub fn ucoa2(&self) -> Ucoa2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa2R { bits }
            }
            # [ doc = "Bit 3 - I2C Own Address 3" ]
            # [ inline ( always ) ]
            pub fn ucoa3(&self) -> Ucoa3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa3R { bits }
            }
            # [ doc = "Bit 4 - I2C Own Address 4" ]
            # [ inline ( always ) ]
            pub fn ucoa4(&self) -> Ucoa4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa4R { bits }
            }
            # [ doc = "Bit 5 - I2C Own Address 5" ]
            # [ inline ( always ) ]
            pub fn ucoa5(&self) -> Ucoa5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa5R { bits }
            }
            # [ doc = "Bit 6 - I2C Own Address 6" ]
            # [ inline ( always ) ]
            pub fn ucoa6(&self) -> Ucoa6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa6R { bits }
            }
            # [ doc = "Bit 7 - I2C Own Address 7" ]
            # [ inline ( always ) ]
            pub fn ucoa7(&self) -> Ucoa7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa7R { bits }
            }
            # [ doc = "Bit 8 - I2C Own Address 8" ]
            # [ inline ( always ) ]
            pub fn ucoa8(&self) -> Ucoa8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa8R { bits }
            }
            # [ doc = "Bit 9 - I2C Own Address 9" ]
            # [ inline ( always ) ]
            pub fn ucoa9(&self) -> Ucoa9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucoa9R { bits }
            }
            # [ doc = "Bit 15 - I2C General Call enable" ]
            # [ inline ( always ) ]
            pub fn ucgcen(&self) -> UcgcenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                UcgcenR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - I2C Own Address 0" ]
            # [ inline ( always ) ]
            pub fn ucoa0(&mut self) -> _Ucoa0W {
                _Ucoa0W { w: self }
            }
            # [ doc = "Bit 1 - I2C Own Address 1" ]
            # [ inline ( always ) ]
            pub fn ucoa1(&mut self) -> _Ucoa1W {
                _Ucoa1W { w: self }
            }
            # [ doc = "Bit 2 - I2C Own Address 2" ]
            # [ inline ( always ) ]
            pub fn ucoa2(&mut self) -> _Ucoa2W {
                _Ucoa2W { w: self }
            }
            # [ doc = "Bit 3 - I2C Own Address 3" ]
            # [ inline ( always ) ]
            pub fn ucoa3(&mut self) -> _Ucoa3W {
                _Ucoa3W { w: self }
            }
            # [ doc = "Bit 4 - I2C Own Address 4" ]
            # [ inline ( always ) ]
            pub fn ucoa4(&mut self) -> _Ucoa4W {
                _Ucoa4W { w: self }
            }
            # [ doc = "Bit 5 - I2C Own Address 5" ]
            # [ inline ( always ) ]
            pub fn ucoa5(&mut self) -> _Ucoa5W {
                _Ucoa5W { w: self }
            }
            # [ doc = "Bit 6 - I2C Own Address 6" ]
            # [ inline ( always ) ]
            pub fn ucoa6(&mut self) -> _Ucoa6W {
                _Ucoa6W { w: self }
            }
            # [ doc = "Bit 7 - I2C Own Address 7" ]
            # [ inline ( always ) ]
            pub fn ucoa7(&mut self) -> _Ucoa7W {
                _Ucoa7W { w: self }
            }
            # [ doc = "Bit 8 - I2C Own Address 8" ]
            # [ inline ( always ) ]
            pub fn ucoa8(&mut self) -> _Ucoa8W {
                _Ucoa8W { w: self }
            }
            # [ doc = "Bit 9 - I2C Own Address 9" ]
            # [ inline ( always ) ]
            pub fn ucoa9(&mut self) -> _Ucoa9W {
                _Ucoa9W { w: self }
            }
            # [ doc = "Bit 15 - I2C General Call enable" ]
            # [ inline ( always ) ]
            pub fn ucgcen(&mut self) -> _UcgcenW {
                _UcgcenW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 I2C Slave Address" ]
    pub struct Ucb0i2csa {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 I2C Slave Address" ]
    pub mod ucb0i2csa {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0i2csa {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa0R {
            bits: u8,
        }
        impl Ucsa0R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa1R {
            bits: u8,
        }
        impl Ucsa1R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa2R {
            bits: u8,
        }
        impl Ucsa2R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa3R {
            bits: u8,
        }
        impl Ucsa3R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa4R {
            bits: u8,
        }
        impl Ucsa4R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa5R {
            bits: u8,
        }
        impl Ucsa5R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa6R {
            bits: u8,
        }
        impl Ucsa6R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa7R {
            bits: u8,
        }
        impl Ucsa7R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa8R {
            bits: u8,
        }
        impl Ucsa8R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct Ucsa9R {
            bits: u8,
        }
        impl Ucsa9R {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa0W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa1W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa2W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa3W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa4W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa5W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa6W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa7W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa8W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _Ucsa9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ucsa9W<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bit 0 - I2C Slave Address 0" ]
            # [ inline ( always ) ]
            pub fn ucsa0(&self) -> Ucsa0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa0R { bits }
            }
            # [ doc = "Bit 1 - I2C Slave Address 1" ]
            # [ inline ( always ) ]
            pub fn ucsa1(&self) -> Ucsa1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa1R { bits }
            }
            # [ doc = "Bit 2 - I2C Slave Address 2" ]
            # [ inline ( always ) ]
            pub fn ucsa2(&self) -> Ucsa2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa2R { bits }
            }
            # [ doc = "Bit 3 - I2C Slave Address 3" ]
            # [ inline ( always ) ]
            pub fn ucsa3(&self) -> Ucsa3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa3R { bits }
            }
            # [ doc = "Bit 4 - I2C Slave Address 4" ]
            # [ inline ( always ) ]
            pub fn ucsa4(&self) -> Ucsa4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa4R { bits }
            }
            # [ doc = "Bit 5 - I2C Slave Address 5" ]
            # [ inline ( always ) ]
            pub fn ucsa5(&self) -> Ucsa5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa5R { bits }
            }
            # [ doc = "Bit 6 - I2C Slave Address 6" ]
            # [ inline ( always ) ]
            pub fn ucsa6(&self) -> Ucsa6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa6R { bits }
            }
            # [ doc = "Bit 7 - I2C Slave Address 7" ]
            # [ inline ( always ) ]
            pub fn ucsa7(&self) -> Ucsa7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa7R { bits }
            }
            # [ doc = "Bit 8 - I2C Slave Address 8" ]
            # [ inline ( always ) ]
            pub fn ucsa8(&self) -> Ucsa8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa8R { bits }
            }
            # [ doc = "Bit 9 - I2C Slave Address 9" ]
            # [ inline ( always ) ]
            pub fn ucsa9(&self) -> Ucsa9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                Ucsa9R { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - I2C Slave Address 0" ]
            # [ inline ( always ) ]
            pub fn ucsa0(&mut self) -> _Ucsa0W {
                _Ucsa0W { w: self }
            }
            # [ doc = "Bit 1 - I2C Slave Address 1" ]
            # [ inline ( always ) ]
            pub fn ucsa1(&mut self) -> _Ucsa1W {
                _Ucsa1W { w: self }
            }
            # [ doc = "Bit 2 - I2C Slave Address 2" ]
            # [ inline ( always ) ]
            pub fn ucsa2(&mut self) -> _Ucsa2W {
                _Ucsa2W { w: self }
            }
            # [ doc = "Bit 3 - I2C Slave Address 3" ]
            # [ inline ( always ) ]
            pub fn ucsa3(&mut self) -> _Ucsa3W {
                _Ucsa3W { w: self }
            }
            # [ doc = "Bit 4 - I2C Slave Address 4" ]
            # [ inline ( always ) ]
            pub fn ucsa4(&mut self) -> _Ucsa4W {
                _Ucsa4W { w: self }
            }
            # [ doc = "Bit 5 - I2C Slave Address 5" ]
            # [ inline ( always ) ]
            pub fn ucsa5(&mut self) -> _Ucsa5W {
                _Ucsa5W { w: self }
            }
            # [ doc = "Bit 6 - I2C Slave Address 6" ]
            # [ inline ( always ) ]
            pub fn ucsa6(&mut self) -> _Ucsa6W {
                _Ucsa6W { w: self }
            }
            # [ doc = "Bit 7 - I2C Slave Address 7" ]
            # [ inline ( always ) ]
            pub fn ucsa7(&mut self) -> _Ucsa7W {
                _Ucsa7W { w: self }
            }
            # [ doc = "Bit 8 - I2C Slave Address 8" ]
            # [ inline ( always ) ]
            pub fn ucsa8(&mut self) -> _Ucsa8W {
                _Ucsa8W { w: self }
            }
            # [ doc = "Bit 9 - I2C Slave Address 9" ]
            # [ inline ( always ) ]
            pub fn ucsa9(&mut self) -> _Ucsa9W {
                _Ucsa9W { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub struct Ucb0ictl {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub mod ucb0ictl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0ictl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub struct Ucb0ie {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Interrupt Enable Register" ]
    pub mod ucb0ie {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ie {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxieR {
            bits: u8,
        }
        impl UcrxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxieR {
            bits: u8,
        }
        impl UctxieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsttieR {
            bits: u8,
        }
        impl UcsttieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcstpieR {
            bits: u8,
        }
        impl UcstpieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcalieR {
            bits: u8,
        }
        impl UcalieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcnackieR {
            bits: u8,
        }
        impl UcnackieR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsttieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsttieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcstpieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcstpieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcalieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcalieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcnackieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcnackieW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&self) -> UcrxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxieR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&self) -> UctxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxieR { bits }
            }
            # [ doc = "Bit 2 - START Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucsttie(&self) -> UcsttieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsttieR { bits }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucstpie(&self) -> UcstpieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcstpieR { bits }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucalie(&self) -> UcalieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcalieR { bits }
            }
            # [ doc = "Bit 5 - NACK Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucnackie(&self) -> UcnackieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcnackieR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn ucrxie(&mut self) -> _UcrxieW {
                _UcrxieW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Enable" ]
            # [ inline ( always ) ]
            pub fn uctxie(&mut self) -> _UctxieW {
                _UctxieW { w: self }
            }
            # [ doc = "Bit 2 - START Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucsttie(&mut self) -> _UcsttieW {
                _UcsttieW { w: self }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucstpie(&mut self) -> _UcstpieW {
                _UcstpieW { w: self }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucalie(&mut self) -> _UcalieW {
                _UcalieW { w: self }
            }
            # [ doc = "Bit 5 - NACK Condition interrupt enable" ]
            # [ inline ( always ) ]
            pub fn ucnackie(&mut self) -> _UcnackieW {
                _UcnackieW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Flags Register" ]
    pub struct Ucb0ifg {
        register: VolatileCell<u8>,
    }
    # [ doc = "USCI B0 Interrupt Flags Register" ]
    pub mod ucb0ifg {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u8,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u8,
        }
        impl super::Ucb0ifg {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcrxifgR {
            bits: u8,
        }
        impl UcrxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UctxifgR {
            bits: u8,
        }
        impl UctxifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcsttifgR {
            bits: u8,
        }
        impl UcsttifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcstpifgR {
            bits: u8,
        }
        impl UcstpifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcalifgR {
            bits: u8,
        }
        impl UcalifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct UcnackifgR {
            bits: u8,
        }
        impl UcnackifgR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcrxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcrxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UctxifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UctxifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcsttifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcsttifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcstpifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcstpifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcalifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcalifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _UcnackifgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UcnackifgW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((bits & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&self) -> UcrxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcrxifgR { bits }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&self) -> UctxifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UctxifgR { bits }
            }
            # [ doc = "Bit 2 - START Condition interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucsttifg(&self) -> UcsttifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcsttifgR { bits }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucstpifg(&self) -> UcstpifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcstpifgR { bits }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucalifg(&self) -> UcalifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcalifgR { bits }
            }
            # [ doc = "Bit 5 - NAK Condition interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucnackifg(&self) -> UcnackifgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u8) as u8
                };
                UcnackifgR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bit 0 - USCI Receive Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucrxifg(&mut self) -> _UcrxifgW {
                _UcrxifgW { w: self }
            }
            # [ doc = "Bit 1 - USCI Transmit Interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn uctxifg(&mut self) -> _UctxifgW {
                _UctxifgW { w: self }
            }
            # [ doc = "Bit 2 - START Condition interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucsttifg(&mut self) -> _UcsttifgW {
                _UcsttifgW { w: self }
            }
            # [ doc = "Bit 3 - STOP Condition interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucstpifg(&mut self) -> _UcstpifgW {
                _UcstpifgW { w: self }
            }
            # [ doc = "Bit 4 - Arbitration Lost interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucalifg(&mut self) -> _UcalifgW {
                _UcalifgW { w: self }
            }
            # [ doc = "Bit 5 - NAK Condition interrupt Flag" ]
            # [ inline ( always ) ]
            pub fn ucnackifg(&mut self) -> _UcnackifgW {
                _UcnackifgW { w: self }
            }
        }
    }
    # [ doc = "USCI B0 Interrupt Vector Register" ]
    pub struct Ucb0iv {
        register: VolatileCell<u16>,
    }
    # [ doc = "USCI B0 Interrupt Vector Register" ]
    pub mod ucb0iv {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Ucb0iv {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
# [ doc = "USCI_B0 I2C Mode" ]
pub struct UsciB0I2cMode {
    register_block: usci_b0_i2c_mode::RegisterBlock,
}
impl Deref for UsciB0I2cMode {
    type Target = usci_b0_i2c_mode::RegisterBlock;
    fn deref(&self) -> &usci_b0_i2c_mode::RegisterBlock {
        &self.register_block
    }
}
# [ doc = "Watchdog Timer" ]
pub const WATCHDOG_TIMER: Peripheral<WatchdogTimer> = unsafe { Peripheral::new(0) };
# [ doc = "Watchdog Timer" ]
pub mod watchdog_timer {
    use vcell::VolatileCell;
    # [ doc = r" Register block" ]
    # [ repr ( C ) ]
    pub struct RegisterBlock {
        _reserved0: [u8; 348usize],
        # [ doc = "0x15c - Watchdog Timer Control" ]
        pub wdtctl: Wdtctl,
    }
    # [ doc = "Watchdog Timer Control" ]
    pub struct Wdtctl {
        register: VolatileCell<u16>,
    }
    # [ doc = "Watchdog Timer Control" ]
    pub mod wdtctl {
        # [ doc = r" Value read from the register" ]
        pub struct R {
            bits: u16,
        }
        # [ doc = r" Value to write to the register" ]
        pub struct W {
            bits: u16,
        }
        impl super::Wdtctl {
            # [ doc = r" Modifies the contents of the register" ]
            # [ inline ( always ) ]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            # [ doc = r" Reads the contents of the register" ]
            # [ inline ( always ) ]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            # [ doc = r" Writes to the register" ]
            # [ inline ( always ) ]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        # [ doc = "Possible values of the field `WDTIS`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum WdtisR {
            # [ doc = "WDT - Timer Interval Select: /2G" ]
            Wdtis0,
            # [ doc = "WDT - Timer Interval Select: /128M" ]
            Wdtis1,
            # [ doc = "WDT - Timer Interval Select: /8192k" ]
            Wdtis2,
            # [ doc = "WDT - Timer Interval Select: /512k" ]
            Wdtis3,
            # [ doc = "WDT - Timer Interval Select: /32k" ]
            Wdtis4,
            # [ doc = "WDT - Timer Interval Select: /8192" ]
            Wdtis5,
            # [ doc = "WDT - Timer Interval Select: /512" ]
            Wdtis6,
            # [ doc = "WDT - Timer Interval Select: /64" ]
            Wdtis7,
        }
        impl WdtisR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    WdtisR::Wdtis0 => 0,
                    WdtisR::Wdtis1 => 1,
                    WdtisR::Wdtis2 => 2,
                    WdtisR::Wdtis3 => 3,
                    WdtisR::Wdtis4 => 4,
                    WdtisR::Wdtis5 => 5,
                    WdtisR::Wdtis6 => 6,
                    WdtisR::Wdtis7 => 7,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> WdtisR {
                match bits {
                    0 => WdtisR::Wdtis0,
                    1 => WdtisR::Wdtis1,
                    2 => WdtisR::Wdtis2,
                    3 => WdtisR::Wdtis3,
                    4 => WdtisR::Wdtis4,
                    5 => WdtisR::Wdtis5,
                    6 => WdtisR::Wdtis6,
                    7 => WdtisR::Wdtis7,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Wdtis0`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_0(&self) -> bool {
                *self == WdtisR::Wdtis0
            }
            # [ doc = "Checks if the value of the field is `Wdtis1`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_1(&self) -> bool {
                *self == WdtisR::Wdtis1
            }
            # [ doc = "Checks if the value of the field is `Wdtis2`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_2(&self) -> bool {
                *self == WdtisR::Wdtis2
            }
            # [ doc = "Checks if the value of the field is `Wdtis3`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_3(&self) -> bool {
                *self == WdtisR::Wdtis3
            }
            # [ doc = "Checks if the value of the field is `Wdtis4`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_4(&self) -> bool {
                *self == WdtisR::Wdtis4
            }
            # [ doc = "Checks if the value of the field is `Wdtis5`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_5(&self) -> bool {
                *self == WdtisR::Wdtis5
            }
            # [ doc = "Checks if the value of the field is `Wdtis6`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_6(&self) -> bool {
                *self == WdtisR::Wdtis6
            }
            # [ doc = "Checks if the value of the field is `Wdtis7`" ]
            # [ inline ( always ) ]
            pub fn is_wdtis_7(&self) -> bool {
                *self == WdtisR::Wdtis7
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdtcntclR {
            bits: u8,
        }
        impl WdtcntclR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdttmselR {
            bits: u8,
        }
        impl WdttmselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Possible values of the field `WDTSSEL`" ]
        # [ derive ( Clone , Copy , Debug , PartialEq ) ]
        pub enum WdtsselR {
            # [ doc = "WDT - Timer Clock Source Select: SMCLK" ]
            Wdtssel0,
            # [ doc = "WDT - Timer Clock Source Select: ACLK" ]
            Wdtssel1,
            # [ doc = "WDT - Timer Clock Source Select: VLO_CLK" ]
            Wdtssel2,
            # [ doc = "WDT - Timer Clock Source Select: reserved" ]
            Wdtssel3,
        }
        impl WdtsselR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                match *self {
                    WdtsselR::Wdtssel0 => 0,
                    WdtsselR::Wdtssel1 => 1,
                    WdtsselR::Wdtssel2 => 2,
                    WdtsselR::Wdtssel3 => 3,
                }
            }
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _from(bits: u8) -> WdtsselR {
                match bits {
                    0 => WdtsselR::Wdtssel0,
                    1 => WdtsselR::Wdtssel1,
                    2 => WdtsselR::Wdtssel2,
                    3 => WdtsselR::Wdtssel3,
                    _ => unreachable!(),
                }
            }
            # [ doc = "Checks if the value of the field is `Wdtssel0`" ]
            # [ inline ( always ) ]
            pub fn is_wdtssel_0(&self) -> bool {
                *self == WdtsselR::Wdtssel0
            }
            # [ doc = "Checks if the value of the field is `Wdtssel1`" ]
            # [ inline ( always ) ]
            pub fn is_wdtssel_1(&self) -> bool {
                *self == WdtsselR::Wdtssel1
            }
            # [ doc = "Checks if the value of the field is `Wdtssel2`" ]
            # [ inline ( always ) ]
            pub fn is_wdtssel_2(&self) -> bool {
                *self == WdtsselR::Wdtssel2
            }
            # [ doc = "Checks if the value of the field is `Wdtssel3`" ]
            # [ inline ( always ) ]
            pub fn is_wdtssel_3(&self) -> bool {
                *self == WdtsselR::Wdtssel3
            }
        }
        # [ doc = r" Value of the field" ]
        pub struct WdtholdR {
            bits: u8,
        }
        impl WdtholdR {
            # [ doc = r" Value of the field as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        # [ doc = "Values that can be written to the field `WDTIS`" ]
        pub enum WdtisW {
            # [ doc = "WDT - Timer Interval Select: /2G" ]
            Wdtis0,
            # [ doc = "WDT - Timer Interval Select: /128M" ]
            Wdtis1,
            # [ doc = "WDT - Timer Interval Select: /8192k" ]
            Wdtis2,
            # [ doc = "WDT - Timer Interval Select: /512k" ]
            Wdtis3,
            # [ doc = "WDT - Timer Interval Select: /32k" ]
            Wdtis4,
            # [ doc = "WDT - Timer Interval Select: /8192" ]
            Wdtis5,
            # [ doc = "WDT - Timer Interval Select: /512" ]
            Wdtis6,
            # [ doc = "WDT - Timer Interval Select: /64" ]
            Wdtis7,
        }
        impl WdtisW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WdtisW::Wdtis0 => 0,
                    WdtisW::Wdtis1 => 1,
                    WdtisW::Wdtis2 => 2,
                    WdtisW::Wdtis3 => 3,
                    WdtisW::Wdtis4 => 4,
                    WdtisW::Wdtis5 => 5,
                    WdtisW::Wdtis6 => 6,
                    WdtisW::Wdtis7 => 7,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtisW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: WdtisW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "WDT - Timer Interval Select: /2G" ]
            # [ inline ( always ) ]
            pub fn wdtis_0(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis0)
            }
            # [ doc = "WDT - Timer Interval Select: /128M" ]
            # [ inline ( always ) ]
            pub fn wdtis_1(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis1)
            }
            # [ doc = "WDT - Timer Interval Select: /8192k" ]
            # [ inline ( always ) ]
            pub fn wdtis_2(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis2)
            }
            # [ doc = "WDT - Timer Interval Select: /512k" ]
            # [ inline ( always ) ]
            pub fn wdtis_3(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis3)
            }
            # [ doc = "WDT - Timer Interval Select: /32k" ]
            # [ inline ( always ) ]
            pub fn wdtis_4(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis4)
            }
            # [ doc = "WDT - Timer Interval Select: /8192" ]
            # [ inline ( always ) ]
            pub fn wdtis_5(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis5)
            }
            # [ doc = "WDT - Timer Interval Select: /512" ]
            # [ inline ( always ) ]
            pub fn wdtis_6(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis6)
            }
            # [ doc = "WDT - Timer Interval Select: /64" ]
            # [ inline ( always ) ]
            pub fn wdtis_7(self) -> &'a mut W {
                self.variant(WdtisW::Wdtis7)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtcntclW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtcntclW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdttmselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdttmselW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = "Values that can be written to the field `WDTSSEL`" ]
        pub enum WdtsselW {
            # [ doc = "WDT - Timer Clock Source Select: SMCLK" ]
            Wdtssel0,
            # [ doc = "WDT - Timer Clock Source Select: ACLK" ]
            Wdtssel1,
            # [ doc = "WDT - Timer Clock Source Select: VLO_CLK" ]
            Wdtssel2,
            # [ doc = "WDT - Timer Clock Source Select: reserved" ]
            Wdtssel3,
        }
        impl WdtsselW {
            # [ allow ( missing_docs ) ]
            # [ doc ( hidden ) ]
            # [ inline ( always ) ]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WdtsselW::Wdtssel0 => 0,
                    WdtsselW::Wdtssel1 => 1,
                    WdtsselW::Wdtssel2 => 2,
                    WdtsselW::Wdtssel3 => 3,
                }
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtsselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtsselW<'a> {
            # [ doc = r" Writes `variant` to the field" ]
            # [ inline ( always ) ]
            pub fn variant(self, variant: WdtsselW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            # [ doc = "WDT - Timer Clock Source Select: SMCLK" ]
            # [ inline ( always ) ]
            pub fn wdtssel_0(self) -> &'a mut W {
                self.variant(WdtsselW::Wdtssel0)
            }
            # [ doc = "WDT - Timer Clock Source Select: ACLK" ]
            # [ inline ( always ) ]
            pub fn wdtssel_1(self) -> &'a mut W {
                self.variant(WdtsselW::Wdtssel1)
            }
            # [ doc = "WDT - Timer Clock Source Select: VLO_CLK" ]
            # [ inline ( always ) ]
            pub fn wdtssel_2(self) -> &'a mut W {
                self.variant(WdtsselW::Wdtssel2)
            }
            # [ doc = "WDT - Timer Clock Source Select: reserved" ]
            # [ inline ( always ) ]
            pub fn wdtssel_3(self) -> &'a mut W {
                self.variant(WdtsselW::Wdtssel3)
            }
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        # [ doc = r" Proxy" ]
        pub struct _WdtholdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdtholdW<'a> {
            # [ doc = r" Writes raw bits to the field" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u16) << OFFSET);
                self.w.bits |= ((bits & MASK) as u16) << OFFSET;
                self.w
            }
        }
        impl R {
            # [ doc = r" Value of the register as raw bits" ]
            # [ inline ( always ) ]
            pub fn bits(&self) -> u16 {
                self.bits
            }
            # [ doc = "Bits 2:4 - WDT - Timer Interval Select 0" ]
            # [ inline ( always ) ]
            pub fn wdtis(&self) -> WdtisR {
                WdtisR::_from({
                                  const MASK: u8 = 7;
                                  const OFFSET: u8 = 2;
                                  ((self.bits >> OFFSET) & MASK as u16) as u8
                              })
            }
            # [ doc = "Bit 3 - WDT - Timer Clear" ]
            # [ inline ( always ) ]
            pub fn wdtcntcl(&self) -> WdtcntclR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WdtcntclR { bits }
            }
            # [ doc = "Bit 4 - WDT - Timer Mode Select" ]
            # [ inline ( always ) ]
            pub fn wdttmsel(&self) -> WdttmselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WdttmselR { bits }
            }
            # [ doc = "Bits 6:7 - WDT - Timer Clock Source Select 0" ]
            # [ inline ( always ) ]
            pub fn wdtssel(&self) -> WdtsselR {
                WdtsselR::_from({
                                    const MASK: u8 = 3;
                                    const OFFSET: u8 = 6;
                                    ((self.bits >> OFFSET) & MASK as u16) as u8
                                })
            }
            # [ doc = "Bit 7 - WDT - Timer hold" ]
            # [ inline ( always ) ]
            pub fn wdthold(&self) -> WdtholdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u16) as u8
                };
                WdtholdR { bits }
            }
        }
        impl W {
            # [ doc = r" Reset value of the register" ]
            # [ inline ( always ) ]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            # [ doc = r" Writes raw bits to the register" ]
            # [ inline ( always ) ]
            pub unsafe fn bits(&mut self, bits: u16) -> &mut Self {
                self.bits = bits;
                self
            }
            # [ doc = "Bits 2:4 - WDT - Timer Interval Select 0" ]
            # [ inline ( always ) ]
            pub fn wdtis(&mut self) -> _WdtisW {
                _WdtisW { w: self }
            }
            # [ doc = "Bit 3 - WDT - Timer Clear" ]
            # [ inline ( always ) ]
            pub fn wdtcntcl(&mut self) -> _WdtcntclW {
                _WdtcntclW { w: self }
            }
            # [ doc = "Bit 4 - WDT - Timer Mode Select" ]
            # [ inline ( always ) ]
            pub fn wdttmsel(&mut self) -> _WdttmselW {
                _WdttmselW { w: self }
            }
            # [ doc = "Bits 6:7 - WDT - Timer Clock Source Select 0" ]
            # [ inline ( always ) ]
            pub fn wdtssel(&mut self) -> _WdtsselW {
                _WdtsselW { w: self }
            }
            # [ doc = "Bit 7 - WDT - Timer hold" ]
            # [ inline ( always ) ]
            pub fn wdthold(&mut self) -> _WdtholdW {
                _WdtholdW { w: self }
            }
        }
    }
}
# [ doc = "Watchdog Timer" ]
pub struct WatchdogTimer {
    register_block: watchdog_timer::RegisterBlock,
}
impl Deref for WatchdogTimer {
    type Target = watchdog_timer::RegisterBlock;
    fn deref(&self) -> &watchdog_timer::RegisterBlock {
        &self.register_block
    }
}
